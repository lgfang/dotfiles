# -*-mode:org; coding:utf-8; time-stamp-pattern:"8/#\\+DATE:[ \t]+%Y-%02m-%02d %5z$" -*-
# Created: Lungang Fang 2024-05-17

#+TITLE: My Emacs Configurations
#+AUTHOR: Fang Lungang
#+DATE: 2026-01-13 +1100
#+DESCRIPTION: My Emacs configurations
#+KEYWORDS: Emacs
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el :mkdirp yes

* Timestamp for tangling

This block itself is not tangled into any configuration file. However, during
the tangling process, it produces a timestamp that other blocks may reference.

#+name: tangle-time-stamp
#+begin_src emacs-lisp :tangle no
(concat user-full-name " " (format-time-string "%Y-%m-%d %5z"))
#+end_src

* Header

#+begin_src emacs-lisp :noweb yes
  ;;; init.el --- Lungang's init.el -*- lexical-binding: t; -*-

  ;; Created: Fang Lungang 2004
  ;; Updated: <<tangle-time-stamp()>>

  ;;; Commentary:

  ;; This Emacs configuration file is generated from my "emacs.org" (see
  ;; https://github.com/lgfang/dotfiles)

  ;; Usage: Run Emacs with this configuration file. After start up, Emacs will
  ;; report missing packages. Normally you can continue using Emacs without these
  ;; packages. But, for better experience, please firstly run `M-x
  ;; package-refresh-contents` and then run `M-x package-install` to install
  ;; missing packages one after another.

  ;;; Code:
#+end_src

* Bootstrap

** Use-package settings

It is fun to see how long each package takes to load and optimize if possible.
Hence, I use the following configuration.
#+begin_src emacs-lisp
  (use-package use-package-core
    :custom
    ;; Uncomment the next line to automatically install all packages
    (use-package-always-ensure t)

    ;; Profile the start time
    (use-package-compute-statistics t))
#+end_src

Run =emacs --no-desktop= to ensure not opening any previous files. Then run the
following commands to see the statistics:
- =M-x use-package-report=
- =M-x emacs-init-time=

** Start up screen
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (inhibit-startup-screen t)
    (initial-scratch-message "")
    )
#+end_src

** Initialize "package"

#+begin_src emacs-lisp
  (use-package package
    :ensure nil                           ; Built-in
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    (package-initialize)
  )
#+end_src

To manually upgrade install packages in batch,
1. Run =M-x package-refresh-contents=
2. Run =M-x list-packages=
3. Then, following the prompt in the mini-buffer, type =U= and =x=

** Paths

Note that the =use-package emacs= thing is unnecessary. I'm using it to group
related configurations together.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (defvar my-emacs-d (file-name-as-directory (expand-file-name "~/.emacs.d")))
    (defvar my-downloads (file-name-as-directory (concat my-emacs-d "downloads")))
    (defvar my-elisps (file-name-as-directory (concat my-emacs-d "my-elisps")))
    (add-to-list 'load-path my-elisps t)
    (defvar my-personal-path (file-name-as-directory
                              (expand-file-name "~/mynotes/personal")))
  )
#+end_src

** Personal information

#+begin_src emacs-lisp
  (use-package my-confidential
     :load-path my-personal-path
     )
#+end_src

* Language environment and coding system

Set terminal coding system to utf-8 explicitly to display unicode chars
(including emojis/Chinese chars) correctly.

This block is needed only when utf-8 is supported but Emacs does not detect and
set it correctly, due to wrong shell locale etc. In such situation, try the
combinations of these settings until you find one that works.

Therefore, this block is *not* tangled by default. When necessary, delete
=:tangle no= from this block header to tangle it.

#+begin_src emacs-lisp :tangle no
  (set-terminal-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-language-environment 'utf-8)
#+end_src

* Environment Variables

When Emacs is launched as a GUI application on macOS, it does not inherit the
user's shell environment variables (such as ~$PATH~) by default.
~exec-path-from-shell~ imports environment variables not limited to PATH from
the user's shell, ensuring that Emacs behaves consistently whether started from
the terminal or as a GUI app.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :if (and (eq system-type 'darwin) (display-graphic-p))
    :config
    (exec-path-from-shell-initialize))
#+end_src

* ZWJ (Zero Width Joiner) emoji handling.

Disable =auto-complete-mode= if running in a terminal as most terminal emulators
cannot handle Emoji ZWJ. See ZWJ examples in [[file:~/mynotes/emacs/emacs-unicode-test.org][my ZWJ test file]].

NOTE: disabling it on the fly does not work very well, must restart Emacs.

#+begin_src emacs-lisp
  (use-package emacs
    :if (not (display-graphic-p))
    :config
    (setq-default auto-composition-mode nil)
    )
#+end_src

* Interaction convenience

** Mouse

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (mouse-yank-at-point t)
    (mouse-drag-copy-region t)
    :config
    (when (not window-system) (xterm-mouse-mode 1)) ;use mouse in xterm
    )
#+end_src

** y-or-n
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (fset 'yes-or-no-p 'y-or-n-p)         ; Type y/n to answer yes or no prompts.
    )
#+end_src

** Comment

*** Comment style
#+begin_src emacs-lisp
  (use-package newcomment
    :ensure nil                           ; Feature, not package
    :custom (comment-style 'extra-line)
    )
#+end_src

*** Comment dwim
#+begin_src emacs-lisp
  (define-advice comment-dwim (:before (&rest _) my-comment-dwim)
    "Smartly comment/un-comment current line when no region is active."
    (unless (or (use-region-p)
                (looking-at-p "[ \t]*$"))
      (push-mark (line-beginning-position) t t)
      (goto-char (line-end-position))))
#+end_src

** Copy/paste

*** Copy/cut the current line

If region is not active, copy or cut the current line instead.

#+begin_src emacs-lisp
  (use-package emacs
    :bind (:map global-map
                ("C-w" . my/cut-region-or-line)
                ("M-w" . my/copy-region-or-line))

    :config
    (defun my/cut-region-or-line ()
      "Cut region (if active) or current line."
      (interactive)
      (if (use-region-p)
          (kill-region (region-beginning) (region-end))
        (kill-whole-line)))

    (defun my/copy-region-or-line ()
      "Copy region (if active) or current line."
      (interactive)
      (if (use-region-p)
          (kill-ring-save (region-beginning) (region-end))
        (kill-ring-save (line-beginning-position) (line-beginning-position 2))))
    )
#+end_src

*** MacOS clipboard integration

#+begin_src emacs-lisp
  (use-package emacs
    :if (eq system-type 'darwin)
    :preface
    (defun my/copy-from-osx ()
      (let ((tramp-mode nil) (default-directory "~"))
        (shell-command-to-string "pbpaste")))
    (defun my/paste-to-osx (text &optional _push)
      (let ((process-connection-type nil))
        (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
          (process-send-string proc text)
          (process-send-eof proc))))
    :custom
    (interprogram-paste-function #'my/copy-from-osx)
    (interprogram-cut-function #'my/paste-to-osx)
    )
#+end_src

NOTE: To use this within tmux session, upgrade to tmux 2.6+.

*** Tmux buffer (clipboard) integration

#+begin_src emacs-lisp :tangle no
  (defun lgfang-send-to-tmux ()
    "Send content of active region or HEAD of the kill-ring to
  tmux's buffer"
    (interactive)
    (let ((file (make-temp-file "/tmp/emacs-to-tmux.clip")))
      (if (region-active-p) (kill-ring-save (region-beginning) (region-end)))
      (with-temp-file file (insert-for-yank (current-kill 0)))
      (call-process "tmux" nil nil nil "load-buffer" file)
      (delete-file file)))

  (defun lgfang-get-from-tmux ()
    "Get current tmux buffer."
    (interactive)
    (call-process "tmux" nil t nil "show-buffer"))
#+end_src

** Hippie expand

#+begin_src emacs-lisp
  (use-package hippie-exp
    ;; Use hippie-expand instead of dabbrev-expand,
    :ensure nil                           ; Built-in
    :bind (:map global-map ("M-/" . hippie-expand))
    :custom
    (hippie-expand-try-functions-list
     '(try-expand-dabbrev                 ; Words from current buffer
       try-expand-dabbrev-visible         ; Words from visible buffers
       try-expand-dabbrev-all-buffers     ; Words from all buffers
       try-expand-dabbrev-from-kill       ; Words from kill ring
       try-complete-file-name-partially   ; Partial file name completion
       try-complete-file-name             ; Full file name completion
       try-expand-all-abbrevs             ; User-defined abbrevs
       try-expand-list                    ; Expansion from `hippie-expand-list'
       try-expand-line                    ; Complete entire lines
       try-complete-lisp-symbol-partially ; Partial Lisp symbol
       try-complete-lisp-symbol           ; Full Lisp symbol
       ))
    )
#+end_src

** Ibuffer

#+begin_src emacs-lisp
  (defconst my/ibuffer-regexp-llm-buffers
    (rx line-start
        (or
         (seq "Claude Code Agent @ " (* nonl)) ; Claude in agent shell
         (seq "acp-client-" (* nonl))          ; agent shell debug buffers
         (seq "*claude-code" (* nonl) "*")     ; Claude in claude-code-ide
         (seq "*Copilot Chat" (* nonl))        ; Copilot chat
         (or                                   ; gptel
          "*DeepSeek*"
          "*CopilotChat*"
          "*Bedrock*"
          (seq "*" (* nonl) "GPT*")
          ))
        line-end))

  (use-package ibuffer                    ; built-in package
    :functions ibuffer-switch-to-saved-filter-groups
    :bind (:map global-map ("C-x C-b" . ibuffer))
    :hook (ibuffer-mode . (lambda() (ibuffer-switch-to-saved-filter-groups "my")))
    :custom
    (ibuffer-saved-filter-groups
     `(("my"
        ("Dired" (mode . dired-mode))
        ("LLM" (name . ,my/ibuffer-regexp-llm-buffers))
        ("Magit" (name . "^magit"))
        ("Emacs" (name . "^\\*.*\\*$"))
        )))
    ;; Sort by buffer names, to change sort mode interactively, press `,' or `M-x
    ;; ibuffer-toggle-sorting-mode' in the ibuffer.
    (ibuffer-default-sorting-mode 'alphabetic))
#+end_src

** Repeat mode

#+begin_src emacs-lisp
  (use-package repeat                     ; built-in package
    :custom
    (repeat-too-dangerous '(kill-this-buffer))
    (repeat-exit-timeout 6)
    ;; (repeat-exit-key  "RET")
    :init
    (repeat-mode)
    )
#+end_src

This section covers general settings for repeat mode. For an example of
mode-specific repeat mode configuration, please refer the [[*Repeat map][org mode repeat map]]
section.

Note that there is normally no need of setting =repeat-eixt-key=, to exit repeat
mode before =repeat-exit-timeout=, just type any character which is no bound for
repeat mode or =C-g=.

** Vertico + orderless + marginalia + consult
#+begin_src emacs-lisp
  (use-package vertico
    :defines vertico-map
    :functions vertico-mode vertico-multiform-mode
    :bind (:map vertico-map ("C-o" . vertico-quick-exit))
    :custom
    (vertico-resize nil)
    (vertico-cycle nil)
    ;; ;; Avoid `reverse' + `mouse', they are not compatible at the moment.
    ;; (vertico-multiform-categories '(
    ;;                                 ;; default, enable buffer & mouse
    ;;                                 (t buffer mouse)
    ;;                                 ))
    ;; (vertico-multiform-commands '(("imenu" buffer mouse)
    ;;                               ("recentf-.*" buffer mouse)
    ;;                               ))
    :init
    (vertico-mode 1)
    (vertico-multiform-mode 1))

  (use-package orderless
    :custom (completion-styles '(orderless partial-completion flex)))

  (use-package marginalia
    :functions marginalia-mode
    :init
    (marginalia-mode 1))

  (use-package consult
    :bind (:map global-map
                ;; ("M-s o" . occur)         ; Built-in
                ("M-g i" . consult-imenu)
                ("M-g l" . consult-line)
                ("M-g d" . consult-flymake)
                ("M-y"   . consult-yank-pop) ; replaces `browse-kill-ring'
                ))
#+end_src

Other useful consult commands:
- =M-x consult-find= :: when you are certain that a file is within the current
  directory or project, but unsure about its specific sub-directly.

** Embark

#+begin_src emacs-lisp
  (use-package embark
    :bind (:map global-map ("C-x ." . embark-act)))

  (use-package embark-consult)
#+end_src

** Subword

#+begin_src emacs-lisp
  (use-package subword
    :ensure nil                           ; Built-in
    :delight
    :config
    (global-subword-mode))
#+end_src

** Sentence

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil                           ; Built-in
    :custom (sentence-end-double-space nil))
#+end_src

- ~M-a~ :: backward sentence
- ~M-e~ :: forward sentence
- ~M-k~ :: kill sentence
- ~C-x <backspace>~ :: backward kill sentence

* Shortcuts to files and links

** ffap
#+begin_src emacs-lisp
  (use-package ffap                       ; built-in
    :bind (:map global-map ("C-x C-f" . ffap))
    :config
    ;; My extensions to ffap jira/sfsc tickets. Remember to define my-employer in
    ;; my-confidential.el
    (defun ffap-jira (name) ; ffap HELP-12345 etc. opens corresponding jira ticket
      (let ((company (if (boundp 'my-employer) my-employer "example")))
        (format "https://jira.%s.org/browse/%s" company name)))
    (add-to-list 'ffap-alist '("\\`\\(HELP\\|SERVER\\)-[0-9]+\\'" . ffap-jira))
    )
#+end_src

** Openwith mode
#+begin_src emacs-lisp
  (use-package openwith
    :defines openwith-associations
    :commands openwith-mode
    :custom (openwith-confirm-invocation t)
    :config
    (when (eq system-type 'darwin)
      ;; On MacOS, the system tool `open' opens the target file with system
      ;; default applications. So, for most types, passing the file to `open' is
      ;; enough.
      (setq openwith-associations '(("\\.mp4" "open" (file))
                                    )))
    :init
    (openwith-mode)
    )
#+end_src

** Webjump

This provides the functionality similar to [[file:~/mynotes/utils/apple.org::*Define Chrome site search shortcuts][Chrome site search shortcuts]].
Sometimes it can be more convenient than the later.

#+begin_src emacs-lisp
  (use-package webjump                    ; built-in package
    :bind (:map global-map ("M-g w" . webjump))
    :custom
    (webjump-sites '(("google"
                      . (concat "https://www.google.com/search?q="
                                (url-hexify-string
                                 (if (use-region-p)
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end))
                                   (thing-at-point 'word t)))))
                     ("github"
                      . (concat "https://github.com/"
                                (let ((str (completing-read
                                            "Choose GitHub option: "
                                            '("pulls/review-requested"
                                              "pulls/"
                                              "mongodb/mongo"
                                              "custom"))))
                                  (cond ((string= str "custom")
                                         (webjump-read-string "Enter custom GitHub path: "))
                                        (t str)))))
                     ("jira at point"
                      . (concat "https://jira.mongodb.org/browse/"  (thing-at-point 'symbol t)))
                     ("jira search"
                      . [simple-query "https://jira.mongodb.org/issues"
                                      "https://jira.mongodb.org/issues/?jql="
                                      ""])
                     ("jira my closed"    ; Tickets I closed in the last 7 days
                      . (url-encode-url
                         (concat "https://jira.mongodb.org/issues/?jql="
                                 "assignee = currentUser() and resolutiondate >= -7d")))
                     )))
#+end_src

** Custom URLs

#+begin_src emacs-lisp
  (defun custom-urls ()
    "Attach a URL to text matching the pattern `{JIRA_PROJECT}-{NUMBER}`.
  The URL format is `https://jira.mongodb.org/browse/{JIRA_PROJECT}-{NUMBER}`."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "\\b\\(SERVER\\|CXX\\)-[0-9]+\\b" nil t)
        (let* ((ticket (match-string 0))
               (url (concat "https://jira.mongodb.org/browse/" ticket))
               (overlay (make-overlay (match-beginning 0) (match-end 0))))
          (overlay-put overlay 'mouse-face 'highlight)
          (overlay-put overlay 'help-echo url)
          (overlay-put overlay 'keymap
                       (let ((map (make-sparse-keymap)))
                         (define-key map [mouse-1]
                           `(lambda ()
                              (interactive)
                              (browse-url ,url)))
                         map))))))
#+end_src

* Sessions and histories

#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; Save mini buffer history
    (savehist-mode t)
    ;; Save cursor places between sessions
    (save-place-mode t)
    ;; Dont reopen files etc. when Emacs restarts
    (desktop-save-mode -1)
    ;; Automatically close buffers inactive for a long time
    (midnight-mode t)
    )

  (use-package recentf                    ; built-in package
    :defines recentf-keep
    :custom (recentf-max-saved-items 666)
    :init
    (recentf-mode 1)
    (add-to-list 'recentf-keep 'file-remote-p)
    :bind (:map global-map ("<f1>" . recentf-open))
    )
#+end_src

Note that, for =recentf= we add =file-remote-p= to the head of the
=recentf-keep= list so that remote file names are kept without connecting to the
remote server to check if these files do exist.

* Server (daemon)

#+begin_src emacs-lisp
  (use-package server
    :ensure nil                           ; Built-in
    :functions (server-running-p server-start)
    :config (when (not (server-running-p)) (server-start)))
#+end_src

* Frame and window

#+begin_src emacs-lisp
  (use-package emacs
    :commands scroll-bar-mode             ; make flymake happy
    :init
    (menu-bar-mode (if (display-graphic-p) 1 -1)) ; turn it on for GUI only
    (tool-bar-mode -1)                            ; turn it off
    (when (display-graphic-p)
      (scroll-bar-mode -1)
      (add-to-list 'default-frame-alist '(fullscreen . maximized))
      )
    )

  (use-package emacs
    :custom
    (split-width-threshold 200)
    ;; Make scrolling behave more like modern applications
    ;; See: (info "(emacs) Auto Scrolling")
    (scroll-margin 0)
    (scroll-conservatively 100)
    )

  (use-package winner
    :init
    (winner-mode 1)
    ;; default key bindings: C-c <left>/<right>
    )

  (use-package transpose-frame
    ;; Do not bind any keys because the only command I use rather frequently is
    ;; `rotate-frame-clockwise' and I run it via `ace-window' dispatcher (see my
    ;; `ace-window' configuration)
    )

  (use-package ace-window
    :defines aw-dispatch-alist
    :bind (:map global-map ("M-o" . ace-window))
    :custom (aw-dispatch-always t)   ; dispatch even only two windows or less
    :config
    (add-to-list 'aw-dispatch-alist '(?t rotate-frame-clockwise)))

  (defun flg-toggle-window-dedicated ()
    "Toggle `set-window-dedicated-p' for the current window."
    (interactive)
    (let ((window (selected-window)))
      (set-window-dedicated-p window (not (window-dedicated-p window)))
      (message "Window %sdedicated to %s"
               (if (window-dedicated-p window) "" "no longer ")
               (buffer-name))))
#+end_src

With =ace-window= package, I feel no more need of =windmove=, =C-x 4 4= or
=lgf-tiling=. Below are Some =ace-window= hotkeys I frequently use (run =M-o ?=
to see more):
- =M-o N= :: jump to window numbered ~N~.
- =M-o m N= :: swap the current window with window ~N~.
- =M-o x N= :: delete window ~N~.
- =M-o u N= :: change the buffer of window ~N~.
- =M-o t= :: run =rotate-frame-clockwise= (from =transpose-frame=).

** Popper

Summon and dismiss "pop-up" buffers with a single key-chord, minimize the impact
to the current window layout.

#+begin_src emacs-lisp
  (use-package popper
    :commands popper-mode popper-echo-mode popper-toggle-type
    :bind (:map global-map
                ;; C-` unavailable in some terms as it is interpreted as C-@
                ("M-`" . popper-toggle)
                ("<f8>" . popper-toggle-type)
                )
    :custom
    (popper-reference-buffers
     '("personal.gtd"
       "work.gtd"
       "\\*Org Agenda\\*"

       "\\*maple-translate\\*"

       "\\*\\(Copilot Chat\\|aidermacs:\\).*\\*"
       "\\*\\(DeepSeek\\|.*GPT.*\\|LLM response\\)\\*" ; gptel

       "\\*Python\\*"

       "\\*Flymake diagnostics for .*\\*"
       "\\*Warnings\\*"

       "\\*Messages\\*"
       help-mode))

    :config
    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

* Fonts

Select the font for Chinese characters using =set-fontset-font=. This command
sets the fallback font when the default font doesn't support the current
character. By default, Emacs iterates all the fonts until it finds one that
supports the character.

Scale Chinese fonts so that the width of 1 Chinese char equals that of two
English chars. This list is manually maintained as the scale factors for
different fonts are determined through trial and error. Note:
- To check the font of the current character, run ~C-u C-x =~.
- To get more accurate data, compare longer lines of English/Chinese.

#+begin_src emacs-lisp
  (use-package emacs
    :if (display-graphic-p)
    :config
    (let ((preferred-font "FiraCode Nerd Font")
          (fallback-font "JetBrainsMono Nerd Font Propo"))
      (set-face-attribute 'default nil :font
                          (concat (if (member preferred-font (font-family-list))
                                      preferred-font fallback-font)
                                  "-18:weight=normal")))
    (let ((zh-font "SimSong"))
      (if ;; Check the availability first to avoid error
          (member zh-font (font-family-list))
           (set-fontset-font t 'han zh-font)))

    (setq face-font-rescale-alist '(("SimSong" . 1.25)
                                    ("PingFang SC" . 1.25)
                                    ))
    )
#+end_src

* Color themes

To fully utilize color themes in text-based Emacs, make sure your terminal is
set up to support "true color". See the [[file:shell.org::*Term & color][Term & color]] section in my shell
configuration file for the details

** COMMENT Wombat

My favorite Emacs built-in dark color theme. The contrast is a little bit too
high though.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (load-theme 'wombat))
#+end_src

** Solarized gruvbox

My favorite low-contrast color theme, though I dislike the background colors in
the Magit diff buffers.
#+begin_src emacs-lisp
  (use-package solarized-theme
    :config
    (load-theme 'solarized-gruvbox-dark t))
#+end_src

** COMMENT Doom tomorrow night

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (load-theme 'doom-tomorrow-night t))
#+end_src

** My colour theme tweaks

This theme provides only my color tweaks. It is not intended for standalone use;
enable it alongside another theme or themes.

#+begin_src emacs-lisp
  (deftheme my/color-theme-tweaks
    "My custom face tweaks.")

  (custom-theme-set-faces
   'my/color-theme-tweaks
   ;; No special background/foreground for flymake warnings. Use underline etc. to
   ;; indicate flymake warnings.
   '(flymake-warning ((t (:background unspecified :foreground unspecified))))
   ;; No special background for magit diff faces
   '(magit-diff-hunk-heading ((t (:background unspecified))))
   '(magit-diff-context ((t (:background unspecified))))
   '(magit-diff-context-highlight ((t (:background unspecified))))
   '(magit-diff-removed ((t (:background unspecified))))
   '(magit-diff-removed-highlight ((t (:background unspecified))))
   '(magit-diff-added ((t (:background unspecified))))
   '(magit-diff-added-highlight ((t (:background unspecified)))))

  (provide-theme 'my/color-theme-tweaks)

  (enable-theme 'my/color-theme-tweaks)
#+end_src

* Files and directories

** Auto revert-buffer

Auto-revert a buffer when corresponding file is modified by another process.
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (global-auto-revert-mode t)
    )
#+end_src

** Backup files
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (make-backup-files t)
    (version-control 'never)
    (backup-by-copying-when-linked t)
    )
#+end_src

** Dealing with huge files
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun lgf-huge-file-hook ()
      "Open huge files with minimum features.

  Huge files (normally log files) can make Emacs sluggish or even
  freeze. This hook tells Emacs to open such files with the
  `fundamental-mode' and turn off any extra features which cannot
  handle large files. In addition, it makes the buffer read only to
  avoid accidental modifications."
      (when (> (buffer-size) (* 1024 1024 16)) ; 16 MB
        (setq buffer-read-only t)
        (buffer-disable-undo)
        (fundamental-mode)
        (which-function-mode -1)
        (if (fboundp 'highlight-parentheses-mode) (highlight-parentheses-mode -1))
        ))
    (add-hook 'find-file-hook 'lgf-huge-file-hook)
    )
#+end_src

** Update timestamps before save

#+begin_src emacs-lisp
  (use-package emacs
    :hook ((before-save . time-stamp))
  )
#+end_src

Be aware that customizing =time-stamp-pattern= globally (for example, in
=init.el=) may conflict with others configuration. I.e. if you update files from
others who use a different timestamp format, then the timestamps will not be
updated. Hence, it is recommended to set timestamp format as a file local
variable.

Below are two examples:
- =#+DATE: 2024-07-11 +1000=

  #+begin_src org :tangle no
    # -*-mode:org; coding:utf-8; time-stamp-pattern:"8/#\\+DATE:[ \t]+%Y-%02m-%02d %5z$" -*-
  #+end_src

- =Modified: Fang Lungang 2024-07-11T16:41:47+1000=

  #+begin_src org :tangle no
    # -*-mode:org;coding:utf-8;time-stamp-pattern:"8/Updated[:][ \t]*%U %Y-%02m-%02dT%02H:%02M:%02S%5z$"-*-
  #+end_src

  Note: =Updated[:]= matches =Updated:=. The reason using the former is to avoid
  the pattern itself being replaced.

** Directories

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil                           ; Built-in
    :hook (dired-mode . dired-hide-details-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package dired-x
    :ensure nil                           ; Built-in
    :after dired
    :custom
    (dired-recursive-copies 'top)
    (dired-recursive-deletes 'top)
    (dired-guess-shell-alist-user
     '(("\\.gpg\\'" "gpg --decrypt-files")
       ;; By default use `open', which chooses the correct application On MacOS.
       ("\\.*\\'" "open")))
    (dired-kill-when-opening-new-dired-buffer nil)
    (dired-omit-files "\\`[.#].*")     ; omit dot files and auto save files
    (dired-omit-extensions '("~"))     ; omit backup files
    :hook (dired-mode . dired-omit-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package dired-subtree
    :after dired
    :bind (:map dired-mode-map
                ("i" . dired-subtree-insert)
                (";" . dired-subtree-remove)
                ("TAB" . dired-subtree-toggle)
                ("<backtab>" . dired-subtree-cycle)
                ("M-n" . dired-subtree-next-sibling)
                ("M-p" . dired-subtree-previous-sibling))
    :custom
    (dired-subtree-use-backgrounds nil))
#+end_src

Note: the following is not tangled because it does not work well with
~dired-subtree~.
#+begin_src emacs-lisp :tangle no
  (use-package dired-collapse
    :after dired
    :hook (dired-mode . dired-collapse-mode))
#+end_src

** Uniquify buffer names
#+begin_src emacs-lisp
  (use-package uniquify
    :ensure nil                           ; Feature, not package
    :custom
    (uniquify-buffer-name-style 'post-forward)
    (uniquify-strip-common-suffix t)
    (uniquify-separator "@"))
#+end_src
If two buffers are both named "buffer_name", they will be renamed to
=buffer_name@path1= and =buffer_name@path2= respectively.

** Buffer file path

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (defun my/current-file-path ()
      "Copy current path/to/file_name to the kill ring."
      (interactive)
      (let ((string (buffer-file-name)))
        (if string ;; Ensure there's a file name to copy
            (progn (message "Current file: %s" string) (kill-new string))
          (error "Current buffer is not associated with a file"))))
    )
#+end_src

* Basic editing
** Fill

In the past, the suggestion was to limit code lines to 80 characters for optimal
printing on A4 paper or for neat screen display.

Nowadays, although larger monitors can comfortably display two buffers side by
side, each with 100 characters, there are still times we work on the build-in
smaller screens. Hence, we keep the fill column to 80.

#+begin_src emacs-lisp
(setq-default fill-column 80 comment-fill-column nil)
#+end_src

** Whitespace
#+begin_src emacs-lisp
  (use-package emacs
    ;; tab, indent and whitespace related
    :custom
    (tab-width 4)
    ;; stops at every `tab-width' columns
    (tab-stop-list nil)
    ;; space instead of <tab> for indentation
    (indent-tabs-mode nil)
    ;; Add missing final newline, unless the mode applies
    ;; `mode-require-final-newline'.
    (require-final-newline t)
    :hook
    ((before-save . whitespace-cleanup)))
#+end_src

** Yasnippet
#+begin_src emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    ;; Put personal/customized snippets into the first dir of `yas-snippet-dirs',
    ;; which is `~/.emacs.d/snippets' by default. NOTE: it is `yas-snippet-dirs'
    ;; NOT `yasnippet-snippets-dir'. The later is where the package
    ;; `yasnippet-snippets' stores its snippets.
    ;; TODO: cleanup duplicated/similar snippets in different directories.
    :functions yas-global-mode
    :init (yas-global-mode 1)
    )

  (use-package yasnippet-snippets
    :after yasnippet-snippets)
#+end_src

Below are some common snippets. For mode specific snippets, see the
corresponding sections.

*** timestamp
#+begin_src snippet :tangle ~/.emacs.d/snippets/fundamental-mode/timestamp :mkdirp yes
  # -*- mode: snippet -*-
  # key: ts
  # name: timestamp

  # Insert the string and comment it in a tmp buffer and the copy it into
  # the current buffer. This is to avoid the warning 'modified buffer in a
  # backquote expression'.

  # --
  `(let* ((mode major-mode))
       (with-temp-buffer
         (insert "-*- mode:org; coding:utf-8; time-stamp-pattern:\"8/Updated:[ \\t]+%U %Y-%02m-%02d %5z$\" -*-\n"
          (format "Created: %s %s\n" (user-full-name) (format-time-string "%Y-%m-%d %5z"))
          (format "Updated: %s %s\n" (user-full-name) (format-time-string "%Y-%m-%d %5z")))
         (funcall mode)
         (comment-region (point-min) (point-max))
         (buffer-string)))`
#+end_src

** Find and replace in multiple files

*** rg

~rg~ (~ripgrep~) commands are often simpler, faster, and produce cleaner results
than their ~grep~ counterparts. This is because the default settings of ~rg~ are
designed to better meet developers' needs, such as automatically ignoring files
listed in ~.gitignore~.

#+begin_src emacs-lisp
  (use-package rg
    :commands (rg rg-project))
#+end_src

*** wgrep
#+begin_src emacs-lisp
  (use-package wgrep
    :after grep

    :preface
    ;; This var is defined when "grep" is loaded. Declare here to make flymake
    ;; happy.
    (defvar grep-mode-map)

    :bind
    ;; Explicitly bind this default hot key to defer loading wgrep until it is
    ;; needed.
    (:map grep-mode-map ("C-c C-p" . wgrep-change-to-wgrep-mode)))
#+end_src

1. Run =grep-find= or =rg= as usual.
   - IMPORTANT: With ~grep-find~, ensure ~grep~ is run with ~-nH~ so that both
     filenames and line numbers are shown in the buffer.
2. In the output buffer, run =C-c C-p= to enter =wgrep= mode.
3. Edit the buffer as if it is a normal buffer.
4. Press =C-x C-s= to apply the changes.

** Automatic parenthesis pairing

#+begin_src emacs-lisp
  (use-package elec-pair
    :config
    (electric-pair-mode 1)                ; enable the mode globally
    :custom
    (electric-pair-preserve-balance nil)
    :hook
    ((org-mode . (lambda ()
                   ;; auto pair "~"
                   (modify-syntax-entry ?~ "\"")
                   ;; do not auto pair "<>"
                   (modify-syntax-entry ?< ".")))))
#+end_src

In addition to the ~electric-pair-pairs~ variable, the ~electric-pair-mode~
consults the buffer's *syntax table* to determine which characters form a pair.

In Org mode, ~<~ and ~>~ are defined as a matching pair. You can inspect this by
running ~M-x describe-syntax~ while in an Org buffer. The output will include
the following lines:
#+begin_src text
...
<               (>	which means: open, matches >
>               )<	which means: close, matches <
...
#+end_src

The above hook disables auto-pairing for ~<~ because it modifies the syntax
table to change ~<~ to a punctuation. So far, I don't see any unwanted side
effects. If any such side effects arise, we can use using the following hook to
change ~electric-pair-inhibit-predicate~ instead.

#+begin_src emacs-lisp :tangle no
  (lambda ()
    (setq-local electric-pair-inhibit-predicate
                (lambda (c)
                  (if (char-equal c ?<)
                      t  ; Inhibit pairing for '<'
                    (electric-pair-default-inhibit c)))))
#+end_src

* Spelling check: flyspell

#+begin_src emacs-lisp
  (use-package flyspell
    :delight
    :hook ((prog-mode . flyspell-prog-mode)
           (markdown-mode . flyspell-mode)
           (git-commit-setup . flyspell-mode)
           (org-mode . flyspell-prog-mode)
           ))
#+end_src

* Visual aids

** Block cursor as wide as the glyph under it
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (x-stretch-cursor t))
#+end_src
Note, this works for GUI Emacs only.

** Long lines
#+begin_src emacs-lisp
  (use-package emacs
    :config
    ;; Disable line wrapping by default. Turn on `visual-line-mode' (built-in)
    ;; manually or via mode hooks if soft-wrapping is neeeded.
    (setq-default truncate-lines t)
    )
#+end_src

** Display column number in the mode line

#+begin_src emacs-lisp
(use-package emacs
  :config
  (column-number-mode t)
  )
#+end_src

** Display line numbers

No configuration is needed. Add this block just to remind myself the command name.

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :ensure nil                           ; Built-in
    :commands display-line-numbers-mode global-display-line-numbers-mode
    ;; :custom
    ;; (display-line-numbers-widen t)
    ;; (display-line-numbers-major-tick 50)
    ;; (display-line-numbers-minor-tick 10)
    )
#+end_src

** Clean up mode line

*** Tool to remove minor mode lighter texts

#+begin_src emacs-lisp
  (use-package delight
    :commands delight
    :config
    ;; delight built-in modes here.
    (delight '((subword-mode nil "subword") (global-subword-mode nil "subword")
               (superword-mode nil "subword") (global-superword-mode nil "subword")
               (eldoc-mode nil "eldoc")
               (hi-lock-mode nil "hi-lock")
               (hs-minor-mode nil "hideshow")
               ))
    )
#+end_src

*** Remove control (vc) info from the mode line

This info can take a lot of space (when the branch is long) and outdated (when
the file version change but the file is not re-opened).

Delete it from the mode line to make room for more useful information, say
"which-function-mode".

#+begin_src emacs-lisp
  (setq-default mode-line-format (delete '(vc-mode vc-mode) mode-line-format))
#+end_src

** Highlight whitespace

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (whitespace-line-column nil)          ; nil => use the value of `fill-column'
    (whitespace-style '(face
                        trailing
                        tabs
                        indentation
                        space-before-tab
                        space-after-tab
                        tab-mark
                        empty
                        ;; lines-tail - too harsh on eyes: highlights all the
                        ;; characters beyond the threshold can be harsh on eyes
                        ;; when the code has a lot of long lines.

                        ;; line-char - cannot highlight space: highlights the
                        ;; characters on the fill column only. If it happens to a
                        ;; be space, then no highlight.
                        ))

    :init
    ;; Do NOT turn `whitespace-mode' on globally. Because: a) in many situations,
    ;; like when using ediff or reading existing code, whitespace is expected but
    ;; may considered problem by `whitespace-mode'. b) Anyways whitespace issues
    ;; are fixed automatically because we add `whitespace-cleanup' (in a different
    ;; configuration section) to the before save hook.
    (global-whitespace-mode -1)
    )
#+end_src

** Show fill column indicator

#+begin_src emacs-lisp
  (use-package display-fill-column-indicator
    :ensure nil                           ; Built-in
    :delight
    :defines (display-fill-column-indicator-character
              display-fill-column-indicator-column)
    :commands (global-display-fill-column-indicator-mode
               display-fill-column-indicator-mode)
    :custom (display-fill-column-indicator-column 100))
#+end_src

** Highlight indentation levels

This package has been working well. The only downside is that the face may
require manual adjustment when changing color themes.

Another popular package is =highlight-indent-guides=. I didn't chose it because
it does not provide the equivalent of
=highlight-indentation-current-column-mode=.

#+begin_src emacs-lisp
  (use-package highlight-indentation
    :delight
    (highlight-indentation-current-column-mode)
    (highlight-indentation-mode)

    :custom
    ;; Disable highlight-indentation-blank-lines, as it prevents `C-a' from going
    ;; to the beginning of blank lines and causes some other issues.
    (highlight-indentation-blank-lines nil)

    :config
    ;; manually set the face to a color which suits most dark themes
    (set-face-background 'highlight-indentation-current-column-face "gray20")

    :hook (((python-mode python-ts-mode) . highlight-indentation-current-column-mode)
           ((yaml-mode yaml-ts-mode) . highlight-indentation-current-column-mode)
           ((sh-mode bash-ts-mode) . highlight-indentation-current-column-mode)
           )
    )
#+end_src

** Highlight matching parenthesis

#+begin_src emacs-lisp
  (use-package highlight-parentheses
    :delight
    :commands global-highlight-parentheses-mode
    :init (global-highlight-parentheses-mode t)
    ;; :custom (hl-paren-colors    ; `M-x list-colors-display' to see named colors
    ;;          '("brown" "orange" "yellow" "forest green" "cyan" "blue" "violet"))
    )
#+end_src

** Highlight current line

Normally unnecessary, add this section just to remind myself the command names
in case they are needed.
#+begin_src emacs-lisp
  (use-package hl-line
    :ensure nil                           ; Built-in
    :delight
    :commands global-hl-line-mode hl-line-mode)
#+end_src

NOTE: this package, along with similar ones such as beacon, only updates the
*active* window. This means that if an action is performed in the current window
that moves the cursor in another window, the visual indicator of the current
line of the other window (inactive) will not be updated until you switch to it.

** Highlight custom keywords
#+begin_src emacs-lisp
  (use-package font-lock
    :ensure nil                           ; Feature, not package
    :hook
    (font-lock-mode . (lambda ()
                        ;; Exclude dired-mode to prevent custom keywords (e.g.,
                        ;; 'lgfang' in the path) from incorrectly overriding the
                        ;; standard 'dired-header' face.
                        (unless (eq major-mode 'dired-mode)
                          (font-lock-add-keywords
                           nil
                           '(("\\<\\(lgfang\\|TODO\\|FIXME\\|NOTE\\|IMPORTANT\\)"
                              . (0 font-lock-warning-face t)))))))
    :config
    (font-lock-add-keywords
     'c-mode
     '(("\\<\\(TRUE\\|FALSE\\)\\>" . font-lock-constant-face)))
    )
#+end_src

** Focus mode
#+begin_src emacs-lisp
  (use-package focus
    :defines focus-mode-to-thing
    :config
    (add-to-list 'focus-mode-to-thing '(python-ts-mode . py-thing))
    )
#+end_src

** Minimap

#+begin_src emacs-lisp
  (use-package minimap
    ;; An eye candy which I rarely use.
    :commands minimap-mode
    :custom (minimap-window-location 'right))
#+end_src

NOTE: this does not work for org mode buffers.

* Finance bookkeeping

** COMMENT Ledger-cli

#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode "\\.ledger\\'"
    :defines ledger-mode-map
    :bind
    (:map ledger-mode-map
          ("C-c ." . (lambda() (interactive)
                       (insert (format-time-string "%Y-%m-%d"))))
          ("S-<right>" . ledger-date-up)
          ("S-<left>" . ledger-date-down))
    :custom
    (ledger-report-use-strict t)
    (ledger-reconcile-default-commodity "AUD")
    )
#+end_src

** Beancount

#+begin_src bash
  brew install beancount beanquery fava
#+end_src

#+begin_src emacs-lisp
  (use-package beancount
    :vc (:url "https://github.com/lgfang/beancount-mode" :rev :newest)
    :mode ("\\.beancount\\'". beancount-mode)
    :bind (
           (:map beancount-mode-map
                 ("C-c <down>" . beancount-date-down)
                 ("C-c <up>"   . beancount-date-up))
           (:repeat-map beancount-repeat-map
                        ("<down>" . beancount-date-down)
                        ("<up>"   . beancount-date-up))))
#+end_src

** Bookkeeping snippets (for beancount)

Note: all the keys start with ='= to avoid auto-completion of ledger mode
itself.

#+begin_src snippet :tangle ~/.emacs.d/snippets/ledger-mode/council-rate :mkdirp yes
  # -*- mode: snippet -*-
  # key: council
  # name: Council rate
  # --
  `(format-time-string "%Y-%m-%d"))` * "Council" "Quarterly Council Rates"
      Expenses:House${1:A}:Government       ${2:888}.${3:00} AUD
      Assets:Bank:${4:BankX}
#+end_src

** Bookkeeping functions (for beancount)

TODO: update functions

* Encryption and credential management

** COMMENT Encrypt files with passwords: ccrypt

Automatically encrypt/decrypt =.cpt= files using =ccrypt=.

#+begin_src emacs-lisp
  (use-package ps-ccrypt
    :load-path my-downloads
    ;; remember to "brew install ccrypt".
    )
#+end_src

Note: while this one is simple and straightforward, I've switched to GPG, which
might appear to be complicated at the first glance but is actually more
convenient (due to gpg agent) and more secure.

** Encrypt files using keys: GnuPG

Emacs automatically encrypts/decrypts =.gpg= files using GnuPG out of box,
needing NO additional configuration.

However, GnuPG must be install and configured properly. For MacOS, follow these
steps:
1. =brew install gpg=
2. =brew install pinentry-mac=
   * By default, =gpg= comes with =pinentry= which does not work well with GUI
     Emacs.
3. =echo "pinentry-program /opt/homebrew/bin/pinentry-mac" > ~/.gnupg/gpg-agent.conf=
   * Update =gpg-agent= configuration to use =pinentry-mac= instead of =pinentry=.
4. =killall gpg-agent=
   * Ensure the new gpg agent configuration takes effect.
5. Create/import gpg keys.
   * IMPORTANT: remember to export and backup keys.

*** Why

I prefer keys (this) than passwords (i.e. ccrypt) for the use case of protecting
a number of local files on my laptop.

- Pros:

  + Easier to change the password: instead of re-encrypt all the files using the
    new password, you only need to re-encrypt the key file.

  + Enables network backup: it is rather safe to backup your data to network so
    long as you *do not upload the key file as well*.

  + Easier to dispose data: similarly, dispose your device is safer as
    deleting/overwriting the key file ensure the data is not accessible even if
    the disk isn't properly formatted.

  + Encrypting new files/data does not require password: encrypt is done using
    the public key.

  + Enables others to encrypt and send data to you online.

  + Can attach comments and notations to keys as reminders of the theirs
    usages/passphrases.

- Cons:
  - One extra thing (the keys) to maintain. Must remember to backup and update
    when a key is edited (say changed passphrase).
  - =gpg= does not support in place file encryption as =ccrypt= does.

*** Manage gpg keys (outside Emacs)

- Show existing: =gpg --list-keys=
- Generate: =gpg --full-gen-key=, then follow the screen prompts.
  #+begin_src text
    $ gpg --full-generate-key
    gpg (GnuPG) 2.4.5; Copyright (C) 2024 g10 Code GmbH
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.

    Please select what kind of key you want:
       (1) RSA and RSA
       (2) DSA and Elgamal
       (3) DSA (sign only)
       (4) RSA (sign only)
       (9) ECC (sign and encrypt) *default*
      (10) ECC (sign only)
      (14) Existing key from card
    Your selection? 1
    RSA keys may be between 1024 and 4096 bits long.
    What keysize do you want? (3072) 4096
    Requested keysize is 4096 bits
    Please specify how long the key should be valid.
             0 = key does not expire
          <n>  = key expires in n days
          <n>w = key expires in n weeks
          <n>m = key expires in n months
          <n>y = key expires in n years
    Key is valid for? (0) 0
    Key does not expire at all
    Is this correct? (y/N) y

    GnuPG needs to construct a user ID to identify your key.

    Real name: Fang lu***
    Email address: fang.lu***@gmail
    Comment: easy
    You selected this USER-ID:
        "Fang lu*** (easy) <fang.lu**@gmail>"

    Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
    ...
    public and secret key created and signed.

    pub   rsa4096 2024-06-05 [SC]
          1EAE54292D6D1495679106947AF7AA621A22738C
    uid                      Fang lu*** (easy) <fang.lu***@gmail>
    sub   rsa4096 2024-06-05 [E]
  #+end_src
- Change passphrase: =gpg --edit-key "easy" passwd=
- Export: =gpg --armor --export-secret-keys > my-keys.asc=
- Import: =gpg --import my-keys.asc=, *then edit trust*

*** Create, read, write gpg files in Emacs

To create a such file:
1. Switch to a *non-existent* buffer "test.txt.gpg".
2. Type something or insert a file/buffer into this buffer.
3. Try save, you'll be prompted to select a key.
   1. Move cursor to the designated key.
   2. Press "m" to mark
   3. Move cursor to "OK" and enter.

Later on, when Emacs opens this file, it will automatically encrypt/decrypt the
file. You only need to provide the passphrase when prompted.

P.S. To encrypt multiple files in command line:
#+begin_src bash
gpg -r easy --encrypt-files file1 file2
#+end_src

*** Encrypt region

- =M-x epa-encrypt-region=
- =M-x epa-decrypt-region=

IMPORTANT: Avoid embedding encrypt regions in files without version control, as
accidental changes are hard to detect and changing a single character can render
the entire region unreadable.

*** Cache passphrase

By default, a gpg agent is started. Hence you needn't type in password every
time a password is needed.

** Store credentials: auth source

#+begin_src emacs-lisp
  (use-package auth-source
    :ensure nil                           ; Built-in
    :custom
    (auth-sources '("~/.authinfo.gpg" "~/my-another-authinfo.gpg"))
    ;; I manually run `auth-source-search' for certain passwords. Do not
    ;; attemp to retrieve passwords automatically
    (auth-source-protocols '()))
#+end_src

This allows you to store multiple credentials in a few files and query them
easily.

*** Example auth info file (gpg encrypted)
#+begin_src authinfo
  machine a_host login username password pa$$w0rd
  machine deepseek login deepseek password sk-****
  machine atlas_api_key login wnaglxyz password ****
  machine atlas_db_user login dsi-user-2025-09-09 password ****
#+end_src

*** Retrieve and use credentials

Below is an example of how to do that in an org file (with org-babel).

NOTE:
- If necessary, call ~(auth-source-forget-all-cached)~ to clear cached results
- Must =(funcall secret)= to get the actual secret string.

#+begin_src org
  ,#+name: my-token
  ,#+begin_src emacs-lisp
    (auth-source-forget-all-cached)
    (let* ((credential (car (auth-source-search :host "atlas")))
           (user (plist-get credential :user))
           (secret (plist-get credential :secret))
           )
      (format "%s:%s" user (funcall secret)))
  ,#+end_src

  ,#+begin_src bash :results raw :var token=my-token()
    echo "$token"
  ,#+end_src
#+end_src

** References
- blog: [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Keeping Secrets in Emacs with GnuPG and Auth Sources]]
- youtube: [[https://www.youtube.com/watch?v=nZ_T7Q49B8Y][How to Encrypt Your Passwords with Emacs]]

* IRC

This section is for record only, no configuration is tangled into the actual configuration file.

I started with ERC, then switched to RCIRC, which appeared to be easier to set up.

I attempted to use them as Slack clients, but the experience was suboptimal, so I stopped using
them.

** ERC                                                             :obsolete:

#+begin_src emacs-lisp :tangle no
(require 'erc)
(add-to-list 'erc-modules 'notifications)
(setq erc-auto-query 'buffer
      erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                "324" "329" "332" "333" "353" "477"))

(defun my-slack ()
  "Join join slack team of company."
  (interactive)
  ;; All confidential information defined in another file
  (erc-tls :server slack-server
           :port slack-port
           :nick slack-nick
           :password slack-pass
           ))
#+end_src

** RCIRC                                                           :obsolete:

#+begin_src emacs-lisp :tangle no
  ;; All confidential information defined in another file
  (setq rcirc-server-alist `((,slack-server
                              :port ,slack-port
                              :encryption tls
                              :nick ,slack-nick
                              :password ,(concat slack-pass "-no_mpdm_greet")
                              :channels ("#tse-notifications"))
                             ("irc.freenode.net"
                              :channels ("#emacs" "#rcirc" "#mongodb"))
                             )
        ;; register nick name: https://freenode.net/kb/answer/registration
        rcirc-authinfo `(("freenode" nickserv ,my-net-id ,my-pub-passwd))
        rcirc-omit-responses '("JOIN" "PART" "QUIT" "NICK" "AWAY")
        ;; rcirc-nick-completion-format "@%s"
        rcirc-fill-flag nil
        rcirc-default-nick my-net-id)

  (add-hook 'rcirc-mode-hook
            (lambda ()
              (rcirc-track-minor-mode 1)
              (flyspell-mode 1)))
#+end_src

* News groups and emails - gnus                                    :obsolete:

In my previous job, I used Gnus to read newsgroups (mainly internal) and occasionally emails. When
the company decommissioned the NNTP servers, I stopped using Gnus.

Corresponding configuration files are in my Emacs notes directory for record only.

* Kubernetes
#+begin_src emacs-lisp
  (use-package kubel
    :commands kubel)
#+end_src

The packages works with limited privileges. Frequently used hotkeys:
- R :: choose resource
- s :: set label selector
- ? :: help (dispatch list)

* Org mode

** Org-contrib

This package bundles a variety of unmaintained org-mode features that I still
use. Installing this package enables ~(use-pacakge individual-feature-xyz)~ to
work.

#+begin_src emacs-lisp
(use-package org-contrib)
#+end_src

** Agenda

#+begin_src emacs-lisp
  (use-package org-agenda
    :ensure nil                           ; Feature, not package
    :bind (:map global-map ("C-x c a" . org-agenda))
    :custom (org-agenda-use-time-grid nil)
  )
#+end_src

Turn off time grid as the grid lines between clocked items are annoying. An
alternative is to set =remove-match= as shown below. However, this can be
misleading as people typically expect equal intervals between grid lines.
Therefore, I chose to disable the time grid.
#+begin_src emacs-lisp :tangle no
  (setq org-agenda-time-grid
        '(((daily today remove-match)
           (800 1000 1200 1400 1600 1800 2000)
           "......" "----------------"))))
#+end_src

** Babel

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-ditaa-jar-path (concat my-downloads "ditaa.jar"))
    (org-plantuml-jar-path (concat my-downloads "plantuml.jar"))
    (org-babel-load-languages '((emacs-lisp . t)
                                (shell . t)
                                (ditaa . t)
                                (plantuml . t)
                                (dot . t)
                                ))
    (org-confirm-babel-evaluate
     (lambda (lang &rest _)
       "Don't ask for confirmation when evaluating ditaa, plantuml, or dot code blocks."
      (not (member lang '("ditaa" "plantuml" "dot")))))
    )
#+end_src

*** Automatically tangle configurations

To ensure that the corresponding configuration files are updated every time I
modify this configuration file, add a =after-save-hook= to org-mode: when the
buffer file is my configuration file, tangle it. Otherwise, do nothing.

#+begin_src emacs-lisp
  (use-package emacs
    :commands org-babel-tangle
    :config
    (defvar my-config-org-files (mapcar #'expand-file-name
                                        '("~/.dotfiles/emacs.org"
                                          "~/.dotfiles/tmux.org"
                                          "~/.dotfiles/git.org"
                                          "~/.dotfiles/shell.org"
                                          "~/.dotfiles/window-manager.org"
                                          "~/.dotfiles/terminal-emulator.org"
                                          "~/.dotfiles/karabiner.org"
                                          "~/.dotfiles/ai.org"
                                          )))
    (defun lgf-tangle-configs ()
      (add-hook 'after-save-hook
                (lambda()
                  (when (member (buffer-file-name) my-config-org-files)
                    (setq-local org-confirm-babel-evaluate nil)
                    (org-babel-tangle)))
                nil t))

    :hook ((org-mode . lgf-tangle-configs))
    )
#+end_src

*Note*:
- Remember to adjust =my-config-org-file= to point to your configuration file.

** Clock
#+begin_src emacs-lisp
  (use-package org-clock
    :ensure nil                           ; Feature, not package
    :bind (:map global-map
                ("<f9>"   . org-clock-in-last)
                ("S-<f9>" . org-clock-out))
    :custom
    (org-clock-heading-function
     (lambda ()
       (let* ((limit 2)                  ; show at most "limit" words in mode line
              (heading (org-get-heading t t t t))
              (words (split-string heading "[ \t]+" t)))
         (concat (string-join (seq-take words limit) " ")
                 (when (> (length words) limit) "...")))))
    )
#+end_src

** Scratch buffer

#+begin_src emacs-lisp
  (use-package org
    :custom
    ;; Major mode for the initial *scratch* buffer.
    (initial-major-mode 'org-mode))
#+end_src

** Ticket or review comments
#+begin_src emacs-lisp
  (use-package ox-confluence
    :ensure nil                           ; Feature provided by org-contrib
    :commands (org-confluence-export-as-confluence))

  (use-package ox-gfm
    :functions (org-before-first-heading-p
                outline-next-heading
                org-mark-subtree
                org-gfm-export-as-markdown
                org-confluence-export-as-confluence
                org-element--property)
    :commands (my/mark-comment
               comment-sanitize
               export-ticket-comment
               export-github-msg
               export-commit-msg)
    :config
    (defun my/mark-comment ()
      "Mark a conceptual `comment' as the active region.

    If the point is before the first Org heading, the `comment' is
    all text from the beginning of the buffer to just before that
    first heading. If the point is within an Org heading, the
    `comment' is the content of the top-level heading containing
    the point.

    Does nothing if a region is already active."
      (interactive)
      (cond
       ;; Do nothing if a region is already active.
       ((region-active-p) nil)

       ;; Case 1: Point is in the 'prologue', before any headlines.
       ((org-before-first-heading-p)
        (push-mark (point-min))
        ;; Find the position of the first heading, or the end of the buffer.
        (let ((end-pos (or (save-excursion (outline-next-heading)) (point-max))))
          ;; Go to one character before the heading, or the buffer end.
          ;; This avoids including the headline itself in the region.
          (goto-char (if (> end-pos (point-min)) (1- end-pos) end-pos)))
        (activate-mark))

       ;; Case 2: Point is within a headline section.
       (t
        ;; Mark the entire top-level entry, including its headline.
        ;; Using `most-positive-fixnum` is a robust way to say "go to the top".
        (org-mark-subtree most-positive-fixnum)
        ;; Move the point forward one line to exclude the headline from the region.
        (forward-line 1))))

    (defun comment-sanitize()
      "Remove the personal information in my screen outputs.

  Run this function after a screen output is copied into an Emacs
  buffer so that my personal info is not saved/shared."
      (interactive)
      (my/mark-comment)

      ;; remove the extra info in my PS1, which may be unnecessary & confusing.
      ;; An example PS1:
      ;;  1251 16:16:18 git:master kube:api.prod.corp.company.com/my-namespace
      ;;  lungang.fang@laptop:~/source/org-contrib
      ;;  $
      (replace-regexp-in-region "^\\( *\\) .*\n * .*\n * " "\\1"
                                (region-beginning) (region-end))
      ;; remove my username, don't want to be super smart with regex.
      (replace-regexp-in-region "lungang\\(.\\)fang" "<given_name>\\1<family_name>"
                                (region-beginning) (region-end))
      (replace-regexp-in-region "fang\\(.\\)lungang" "<family_name>\\1<given_name>"
                                (region-beginning) (region-end))
      )

    (defun export-ticket-comment ()
      "Export the current node to GFM or Confluence(Jira) markdown.

  The format is determined by the buffer name prefix. Headlines
  are offset to start at h3."
      (interactive)
      (my/mark-comment)
      (let* ((is-gfm (string-match-p "sf-" (or (buffer-file-name) "")))
             (export-function (if is-gfm
                                  #'org-gfm-export-as-markdown
                                #'org-confluence-export-as-confluence))
             (org-export-headline-levels 3) ; Start top-level headlines at level 3
             (org-export-with-toc nil))     ; Disable table of contents
        (funcall export-function)))

    (defun export-commit-msg()
      "Export the current node to github Markdown, preserving breaks."
      (interactive)
      (my/mark-comment)
      (let (;; Preserve line breaks, making the message terminal friendly.
            (org-export-preserve-breaks t)
            ;; Use the setext style ("---" and "===") for headlines. The atx style
            ;; ("#") is treated as comments by git.
            (org-md-headline-style 'setext))
        (org-gfm-export-as-markdown)))

    (defun export-github-msg ()
      "Export the current node to a github Markdown, removing breaks."
      (interactive)
      (my/mark-comment)
      (let ((org-export-preserve-breaks nil)
            (org-md-headline-style 'setext))
        (org-gfm-export-as-markdown))))
#+end_src

** Getting Things Done (GTD)
#+begin_src emacs-lisp
  (use-package org-capture
    :ensure nil                           ; Feature, not package
    :bind (:map global-map ("<f10>" . org-capture)))
#+end_src

** Links

The keybindings below are *not* tangled into the configuration file because they
either:
- Address less frequently used functionalities, or
- Duplicate existing default keybindings.
#+begin_src emacs-lisp :tangle no
  (use-package org
    :ensure nil                           ; Built-in
    :bind (;; `global-map' by default by :bind
           ("C-x c l" . org-store-link)
           ("C-x c o" . org-open-at-point-global)
           :map org-mode-map
           ("C-c C-l" . org-insert-link)
           ("C-c C-o" . org-open-at-point)
           )))
#+end_src

** Repeat map

#+begin_src emacs-lisp
  (use-package org
    :ensure nil                           ; Built-in
    :bind (:repeat-map my-org-repeat-map
                       ("C-n" . org-next-visible-heading)
                       ("C-p" . org-previous-visible-heading)
                       ("C-b" . org-backward-heading-same-level)
                       ("C-f" . org-forward-heading-same-level)
                       )
    )
#+end_src

** Structure templates
I.e. type =<s= + =TAB= to insert =#+begin_src= etc.
#+begin_src emacs-lisp
  (use-package org-tempo
    :ensure nil                           ; Feature, not package
    :config
    (add-to-list 'org-structure-template-alist '("sb" . "src bash"))
    (add-to-list 'org-structure-template-alist '("sj" . "src javascript"))
    ;; yasnippet-snippets/snippets/org-mode/style uses "<st" as well, which
    ;; overrides the one below. Modify that to "<sty" and then `yas-reload-all'
    (add-to-list 'org-structure-template-alist '("st" . "src text"))
    (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
    )
#+end_src

** To migrate

TODO:
1. [ ] migrate the content in =.org.el=.
2. [ ] when the above is done, delete =.org.el= from git and remove this
   section.
#+begin_src emacs-lisp
 (load "~/.org" t nil nil)
#+end_src

* PDF

#+begin_src emacs-lisp
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :commands pdf-tools-install
    :config
    (pdf-tools-install))
#+end_src

* EPUB
#+begin_src emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode)
  )
#+end_src

** Garbled text in Chinese books
According to [[https://emacs-china.org/t/emacs-epub/4713][this post in emacs-china]], the root cause is that these files do not
follow the standard, causing =nov= to handle UTF characters incorrectly.

The following workaround worked for me (at least for some books):
#+begin_src emacs-lisp
(with-no-warnings
    (defun my-nov-content-unique-identifier (content)
      "Return the the unique identifier for CONTENT."
      (when-let* ((name (nov-content-unique-identifier-name content))
                  (selector (format "package>metadata>identifier[id='%s']"
                                    (regexp-quote name)))
                  (id (car (esxml-node-children (esxml-query selector content)))))
        (intern id)))
    (advice-add #'nov-content-unique-identifier :override #'my-nov-content-unique-identifier))
#+end_src

** COMMENT EPUB 3 ID not found
Also from [[https://emacs-china.org/t/emacs-epub/4713][this post in emacs-china]], this is caused by epub2 books mistaken
identify them as epub3 ones.

Below is the workaround. Do not tangle this because I haven't hit issues and
hence haven't verified it yet.
#+begin_src emacs-lisp
(defun nov--content-epub2-files (content manifest files)
    (let* ((node (esxml-query "package>spine[toc]" content))
           (id (esxml-node-attribute 'toc node)))
      (when (not id)
        (throw 'error "EPUB 2 NCX ID not found"))
      (setq nov-toc-id (intern id))
      (let ((toc-file (assq nov-toc-id manifest)))
        (when (not toc-file)
          (throw 'error "EPUB 2 NCX file not found"))
        (cons toc-file files))))

  (defun nov--content-epub3-files (content manifest files)
    (let* ((node (esxml-query "package>manifest>item[properties~=nav]" content))
           (id (esxml-node-attribute 'id node)))
      (when (not id)
        (throw 'error "EPUB 3 <nav> ID not found"))
      (setq nov-toc-id (intern id))
      (let ((toc-file (assq nov-toc-id manifest)))
        (when (not toc-file)
          (throw 'error "EPUB 3 <nav> file not found"))
        (setq files (--remove (eq (car it) nov-toc-id) files))
        (cons toc-file files))))

  (defun nov-content-files (directory content)
    "Create correctly ordered file alist for CONTENT in DIRECTORY.
Each alist item consists of the identifier and full path."
    (let* ((manifest (nov-content-manifest directory content))
           (spine (nov-content-spine content))
           (files (mapcar (lambda (item) (assq item manifest)) spine)))
      (catch 'error (nov--content-epub3-files content manifest files))
      (catch 'error (nov--content-epub2-files content manifest files))))
#+end_src

* Terminal/shell

** erase keybindings

This setting is generally not required, as Emacs correctly handles keybindings
by default:
- The ~Backspace~ key deletes backward.
- The ~Delete~ key deletes forward.
- ~C-h~ is the standard prefix for help commands.

However, an issue can sometimes arise after activating a shell environment from
within Emacs (for example, using ~poetry-venv-workon~). This may cause
keybindings to behave unexpectedly, such as mapping ~Backspace~ to delete
forward and ~C-h~ to act as backspace.

If such behaviour is encountered, manually evaluating the following expression
can restore the correct keybindings. For this reason, the code block is not
tangled and is intended as a manual fix for this specific situation.

#+begin_src emacs-lisp :tangle no
  (normal-erase-is-backspace 0)
#+end_src

** vterm

#+begin_src emacs-lisp
  (use-package vterm :commands vterm)
#+end_src

Why:
- Integrated window/pane management & navigation
- Consistent color themes

Frequently used key bindings
- =C-c C-t= : toggle =copy-mode= (move around and copy in the vterm buffer).
- =C-c C-c= : send =C-c= to the term

Emacs as a terminal multiplexer:
1. Start Emacs daemon.
2. Run vterm (=M-x vterm=) in emacs clients.

** eshell

*** Customize prompt

Currently, there are no elaborate decorations. The primary changes are adding
the time and placing the path and dollar sign on separate lines.

#+begin_src emacs-lisp
  (use-package eshell
    :ensure nil                           ; Built-in
    :commands eshell
    :custom (eshell-prompt-function
             (lambda ()
               (concat
                (propertize " " 'face `(:foreground "green"))
                (propertize (format-time-string "%H:%M " (current-time)) 'face `(:foreground "yellow"))
                (propertize (user-login-name) 'face `(:foreground "green"))
                (propertize "@" 'face `(:foreground "green"))
                (propertize (system-name) 'face `(:foreground "green"))
                (propertize "\n " 'face `(:foreground "green"))
                (propertize (concat (eshell/pwd)) 'face `(:foreground "green"))
                (propertize "\n " 'face `(:foreground "green"))
                (propertize (if (= (user-uid) 0) "# " "$ ") 'face `(:foreground "green"))
                )))
    )
#+end_src

*** Customize aliases and commands
#+begin_src emacs-lisp
  (defun eshell/ep ()
    "In eshell, `ep' to go to the path of the previous buffer."
    (cd (with-current-buffer (other-buffer) default-directory)))

  (defun eshell/vi (&rest args)
    "Invoke `find-file' according to ARGS.
  `vi +66 foo` opens the file `foo` and goes to line 66 in the buffer."
    (while args
      (if (string-match "\\`\\+\\([0-9]+\\)\\'" (car args))
          (let* ((target-line (string-to-number (match-string 1 (pop args))))
                 (file (pop args)))
            (find-file file)
            (forward-line (- target-line (line-number-at-pos))))
        (find-file (pop args)))))
#+end_src

*** multiple eshell

To create an additional eshell buffer, run =C-u M-x eshell=.

* Utilities

** ASCII values

- To get the ASCII value of certain character
  + Move the cursor to it and then run ~C-x =~. The ASCII values in base 10, 8, 16
    are shown in the mini buffer as show below:
    #+begin_src text
      Char: a (97, #o141, #x61) ...
    #+end_src
  + Alternatively, put a question mark before the character and evaluate that
    expression (~C-x C-e~).
    #+begin_src text
      ?a ==> 97 (#o141, #x61, ?a)
    #+end_src

- To insert a character using its ASCII value, use the ~insert~ function
  #+begin_src text
    (insert 97)
    (insert #o141)
    (insert #x61)
  #+end_src

- Display the ASCII table in a dedicated buffer.
  #+begin_src emacs-lisp
    (use-package ascii-table
      :commands ascii-table
      :custom (ascii-table-base 10))
  #+end_src
  Press "b" "d" "o" "x" etc. to switch between different bases (see variable
  ~ascii-table-mode-map~).

** Calendar

#+begin_src emacs-lisp
  (use-package calendar
    :ensure nil                           ; Built-in
    :defines displayed-month displayed-year
    :functions calendar-day-of-week
    :commands calendar
    :config
    (require 'holidays)
    (require 'cal-china-x nil t))

  (use-package holidays
    :ensure nil                           ; Feature, not package
    :config
    (defun holiday-new-year-bank-holiday ()
      "This & next copied from https://emacs.stackexchange.com/a/45352/9670"
      (let ((m displayed-month) (y displayed-year))
        (calendar-increment-month m y 1)
        (when (<= m 3)
          (let ((d (calendar-day-of-week (list 1 1 y))))
            (cond ((= d 6)
                   (list (list (list 1 3 y)
                               "NSW: New Year's Day (day in lieu)")))
                  ((= d 0)
                   (list (list (list 1 2 y)
                               "NSW: New Year's Day (day in lieu)"))))))))

    (defun holiday-christmas-bank-holidays ()
      (let ((m displayed-month) (y displayed-year))
        (calendar-increment-month m y -1)
        (when (>= m 10)
          (let ((d (calendar-day-of-week (list 12 25 y))))
            (cond ((= d 5)
                   (list (list (list 12 28 y)
                               "NSW: Boxing Day (day in lieu)")))
                  ((= d 6)
                   (list (list (list 12 27 y)
                               "NSW: Boxing Day (day in lieu)")
                         (list (list 12 28 y)
                               "NSW: Christmas Day (day in lieu)")))
                  ((= d 0)
                   (list (list (list 12 27 y)
                               "NSW: Christmas Day (day in lieu)"))))))))

    (setq calendar-mark-holidays-flag t)
    (let ((holiday-nsw-holidays '((holiday-fixed 1 1 "NSW: New Year's Day")
                                  (holiday-new-year-bank-holiday)
                                  (holiday-fixed 1 26 "NSW: Austrlia Day")
                                  (holiday-easter-etc -2 "NSW: Good Friday")
                                  (holiday-easter-etc -1 "NSW: Easter Saturday")
                                  (holiday-easter-etc 0 "NSW: Easter Sunday")
                                  (holiday-easter-etc 1 "NSW: Easter Monday")
                                  (holiday-fixed 4 25 "NSW: Anzac Day")
                                  (holiday-float 6 1 2 "NSW: Queen's Birthday")
                                  (holiday-float 10 1 1 "NSW: Labour Day")
                                  (holiday-fixed 12 25 "NSW: Christmas Day")
                                  (holiday-fixed 12 26 "NSW: Boxing Day")
                                  (holiday-christmas-bank-holidays)))
          (holiday-other-holidays '((holiday-fixed 10 31 "Halloween"))))
      (setq calendar-holidays (append holiday-nsw-holidays
                                      holiday-other-holidays))))
#+end_src

*** Chinese calendar and holidays
#+begin_src emacs-lisp
  (use-package cal-china-x :defer t
    :defines cal-china-x-chinese-holidays
    :config
    (setq calendar-holidays (append calendar-holidays
                                    cal-china-x-chinese-holidays
                                    '((holiday-lunar 1 15 "")))))
#+end_src

** Dictionary and translation

Firstly, clone the package into the =my-downloads= directory:
#+begin_src bash
git clone https://github.com/honmaple/emacs-maple-translate ~/.emacs.d/downloads/emacs-maple-translate
#+end_src

#+begin_src emacs-lisp
  (use-package maple-translate
    :load-path (lambda() (concat my-downloads "emacs-maple-translate"))
    :commands (maple-translate maple-translate+)
    :custom (maple-translate-engine 'youdao)
    :bind (:map global-map
                ("C-h D" . maple-translate)
                ("C-h d" . maple-translate+))
    )
#+end_src

I no longer use =scdv= despite its offline capability due the difficulty in
finding and downloading dictionaries.

Using =webjump= to navigate to =dict.cn= etc. with the selected text or word at
point is another alternative. However, it is less inconvenient as it requires
closing the web browser tab and refocusing on Emacs.

** Diff
#+begin_src emacs-lisp
  (use-package ediff
    :ensure nil                           ; Built-in
    :custom
    ;; ignore whitespace
    ;; (ediff-diff-options "-w")
    ;; Do not pop up an additional frame for ediff
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    ;; split horizontally if the window is big enough
    (ediff-split-window-function 'split-window-sensibly)
  )
#+end_src

** Man pages
Nowadays the default "man" is already very convenient, no need of woman any
more.
#+begin_src emacs-lisp :tangle no
  (use-package woman
    :custom
    (woman-use-own-frame nil)
    (woman-fill-frame t))
#+end_src

** Htmlize
#+begin_src emacs-lisp
  (use-package htmlize
    :commands (htmlize-file
               htmlize-buffer
               htmlize-region
               htmlize-many-files
               htmlize-many-files-dired))
#+end_src

** Speed type
#+begin_src emacs-lisp
  (use-package speed-type
    :commands speed-type-region speed-type-text
    )
#+end_src

To improve typing speed, install =speed-type= and then use =speed-type-text= to
practice with random text snippets from the Gutenburg Project or
=speed-type-region= for the active region.

To avoid get boredom, I sometimes use =eww= to open a news page and then
=speed-type-region= it.

** Spelling alphabet

This is useful when you need to explain how to spell something over phone calls.
- Type in the word and =nato-region= it, then read it out. Or,
- =C-h v nato-alphabet= to list the alphabet in the HELP buffer and refer to it.

#+begin_src emacs-lisp
  (use-package morse                      ; built in
    ;; Nothing to customize, just list the commands etc. as a reminder
    :commands nato-region denato-region morse-region unmorse-region
    :defines nato-alphabet morse-code
    )
#+end_src

** Weather
#+begin_src emacs-lisp
  (use-package wttrin
    :defines wttrin-default-locations
    :commands wttrin
    :custom
    (wttrin-default-locations '("Sydney, NSW"))
    ;; Explicitly specify a mono-space font for GUI Emacs
    (wttrin-font-name 'monaco))
#+end_src

** World clock
#+begin_src emacs-lisp
  (use-package time                       ; built-in package
    ;; use `M-x world-clock' to display
    :custom
    (world-clock-time-format "%R %a %b\t%d %Z\t%z")
    (world-clock-list '(("UTC" "UTC")
                        ("Australia/Sydney" "Sydney")
                        ("America/New_York" "New York")
                        ("America/Chicago" "Chicago")
                        ("America/Los_Angeles" "Palo Alto")
                        ("Asia/Shanghai" "Beijing")
                        ("Asia/Kolkata" "Delhi")
                        ("Asia/Tel_Aviv" "Tel Aviv")
                        ("Europe/London" "Dublin")))
    )
#+end_src

* IDE

** Treemacs

#+begin_src emacs-lisp
  (use-package treemacs :commands treemacs)
#+end_src

Instead of using projectile etc., we can manually edit =treemacs-persist-file=
to add projects we need. Below is an example:
#+begin_src org
  ,* Default
  ,** My .dotfiles
   - path :: ~/.dotfiles
  ,** structure log mode
   - path :: ~/projects/emacs/structured-log-mode
#+end_src

** Completion: company

#+begin_src emacs-lisp
  (use-package company
    :delight
    :functions global-company-mode
    :init (global-company-mode)
    )
#+end_src

** Syntax check: flymake

#+begin_src emacs-lisp
  (use-package flymake
    ;; To jump to flymake diagnostics, use `consult-flymake'. To see the checkers
    ;; being used, check the buffer local var `flymake-diagnostic-functions'.
    ;; Sometimes it may be handy to list all the diagnostics in a buffer, this can
    ;; be done using `flymake-show-buffer-diagnostics' or
    ;; `flymake-show-project-diagnostics'.

    :bind (:map flymake-mode-map
                ("C-c p" . flymake-goto-prev-error)
                ("C-c n" . flymake-goto-next-error))

    :hook (prog-mode yaml-ts-mode))
#+end_src

** Syntax parser: tree-sitter

#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil                           ; Feature, not package

    ;; Remember to run `treesit-install-language-grammar' to install the grammar
    ;; for each designated language.
    :when
    (and (fboundp 'treesit-available-p) (treesit-available-p))

    :custom
    (major-mode-remap-alist
     '(
       (sh-mode . bash-ts-mode)
       (c++-mode . c++-ts-mode)
       (c-mode . c-ts-mode)
       (cmake-mode . cmake-ts-mode)
       (conf-toml-mode . toml-ts-mode)
       (js-json-mode . json-ts-mode)
       (python-mode . python-ts-mode)
       (yaml-mode . yaml-ts-mode)
       ))

    :functions py-thing

    :defines flg-up-level-thing-alist

    :config
    ;; define `py-thing' for `thing-at-point' so that the `focus-mode' can focus
    ;; on such python things.
    (defvar py-thing--thing nil
      "Store the thing at point. `thing-at-point' moves to the end of
  the thing first. We should not re-run `py-thing' after that."
      )

    (defvar py-things-to-focus
      '("class_definition"
        "function_definition"
        "try_statement"
        "except_clause"
        "if_statement"
        "else_clause"
        "for_statement"
        "while_statement"
        "module")
      "Node types considered as python thing.")

    (defun py-thing ()
      (treesit-parent-until
       (treesit-node-at (point))
       (lambda (parent) (member (treesit-node-type parent) py-things-to-focus))))

    (defun py-thing-begin ()
      (when-let ((thing (or py-thing--thing (py-thing))))
        (goto-char (treesit-node-start thing))))

    (defun py-thing-end ()
      (when-let ((thing (py-thing)))
        (setq py-thing--thing thing)
        (goto-char (treesit-node-end thing))))

    (put 'py-thing 'beginning-op 'py-thing-begin)
    (put 'py-thing 'end-op 'py-thing-end)

    (defcustom flg-up-level-thing-alist '((python-ts-mode . py-thing)
                                          (prog-mode . defun)
                                          (org-mode . org-element))
      "Used by `one-level-up` to determine thing at point."
      :type 'alist
      :group 'fanglungang
      )

    (defun up-level ()
      "Move point to the beginning of the parent of the thing at point."
      (interactive)
      (let* ((thing (or (cdr (assoc major-mode flg-up-level-thing-alist)) 'defun)))
        (goto-char (car (bounds-of-thing-at-point thing)))
        (forward-line -1)
        (goto-char (car (bounds-of-thing-at-point thing)))))

    )
#+end_src

** Code Formatter

Below are two general code formatter packages. For language-specific formatter
settings, refer to the corresponding programming language section.

*** reformatter

This package itself does not format code itself but provides functions necessary
to implement an formatter. It is required by tools =ruff-format= etc.

#+begin_src emacs-lisp
  (use-package reformatter
    :delight
    )
#+end_src

*** Prettier

This package formats JSON, YAML, and other file types.

NOTE:
- It is advisable to adhere to the default format settings as Prettier aims to
  standardize formatting and minimize disputes over style.
- To stop =yamllint= from complaining "too many spaces inside braces" for legacy
  code, add =bracketSpacing: false= to your =.prettierrc= temporarily.

1. *Globally* install the package (=-g=): =npm install -g prettier=.

2. Verify that =prettier= works, for example:
   #+begin_src bash
     npx prettier test.yml
   #+end_src

3. Hook prettier in Emacs
   #+begin_src emacs-lisp
     (use-package prettier
       :delight
       ;; Format json, yaml, markdown etc.;
       :hook (yaml-mode yaml-ts-mode)
       )
   #+end_src

**** COMMENT For shell scripts

Note: I'm using shfmt instead of this at the moment.

This does not work as Prettier is unable to find globally installed
plugins. Installing Prettier and the plugin locally and launching Emacs from the
same directory works; however, this approach is not ideal due to the
restriction of having to start Emacs from that specific directory.

- *Globally* install [[https://github.com/un-ts/prettier/tree/master/packages/sh][the shell script plugin]]
  #+begin_src bash
    npm install -g prettier-plugin-sh
  #+end_src
- Enable the plugin in =~/.prettierrc=:
  #+begin_src json
    {
      "plugins": ["prettier-plugin-sh"]
    }
  #+end_src

** Which function
#+begin_src emacs-lisp
  (use-package which-func
    :init (which-function-mode t)
    )
#+end_src

** Breadcrumb
#+begin_src emacs-lisp
  (use-package breadcrumb
    :commands breadcrumb-mode
    :custom
    (breadcrumb-project-max-length 0.3)
    (breadcrumb-imenu-max-length 0.9))
#+end_src
- Note: consider replacing =which-function= with this.

** Imenu

#+begin_src emacs-lisp
  (use-package imenu
    :custom (imenu-auto-rescan t)
    )

  (use-package imenu-list
    :after imenu
    :bind (:map global-map ("M-s i" . imenu-list ))
    )
#+end_src

** Project

This now built-in package detects the current project and provides some utility
functions used by many other packages.

#+begin_src emacs-lisp
  (use-package project
    :custom
    ;; Help `project' to correctly identify project root directories
    (project-vc-extra-root-markers '("pyproject.toml"))
    )
#+end_src

** LSP: eglot

Works very well out of box without any configuration.
#+begin_src emacs-lisp
  (use-package eglot :commands eglot)
#+end_src

*** Note for MacOS

If you run Eglot + Pyright on macOS, you may need to increase the open files
limit (=ulimit -n=), for example, to 65536.The default limit is 256, which
Pyright can easily exceed in non-trivial Python projects.

To diagnose the issue:
1. Set =debug-on-error= to =t=.
2. Try enabling Eglot again to view the error message.

** DAP: dape

#+begin_src emacs-lisp
  (use-package dape
    :after eglot
    :commands (dape dape-breakpoint-toggle)
    :custom
    ;; `left' is better than `right' as it places the source code area in the
    ;; primary focus area (the centre of the screen).
    (dape-buffer-window-arrangement 'left)
    :config
    ;; Save files before sessions, useful for interpreted languages, such as
    ;; python; Cannot use `:hook' since this hook name doesn't end with "-hook"
    (add-hook 'dape-on-start-hooks 'save-some-buffers))
#+end_src

*** Python examples

For Python, `pip3 install debugpy'. Run adapter `debugpy' to test a program,
adapter `debugpy-module' for testing a module.

IMPORTANT: Ensure the Python project's virtual environment is activated, if
applicable. For example, if the project uses poetry, run ~poetry-venv-workon~
before activating dape.

- Debug a python script
  #+begin_src text
    Run adapter: debugpy :cwd "/home/lgfang/" :program "test.py" :args ["arg1"
    "arg2" ...]
  #+end_src

- Debug a unit test run by =pytest=
  #+begin_src text
    Run adapter: debugpy-module :cwd "/home/lgfang/myproject/" :module "pytest"
    :args ["src/tests/test_xyz.py::TestCustomBuild" "--no-cov"]
  #+end_src
  IMPORTANT: without the additional ~--no-cov~ argument, pytest tests will not
  stop at break points.

- Debug a locust run
  #+begin_src text
    Run adapter: debugpy-module :cwd "/home/lgfang/myproject/workloads/currentOp/"
    :module "locust" :args ["--locustfile" "./src/currentOp_workload.py" ...]
  #+end_src

** Xcscope

This section is kept for reference but excluded from the actual config. The
recommended alternative is ~eglot~ + a language server (e.g., ~clangd~ for C++).
See language-specific sections for details.

#+begin_src emacs-lisp :tangle no
  (use-package xcscope
    :custom
    ;; Use `global' (brew install global) instead of `cscope'
    (cscope-program "gtags-cscope")
    ;; The default database filename of `global'
    (cscope-database-file "GTAGS")
    ;; Disable database auto-rebuild (for huge projects)
    (cscope-do-not-update-database t)
    ;; Cross-project search paths
    (cscope-database-regexps
     '(
       (
        ( "^/users/jdoe/sources/proj1"
          ( t )
          ( "/users/jdoe/sources/proj2")
          ( "/users/jdoe/sources/proj3/mycscope.out")
          ( "/users/jdoe/sources/proj4")
          t
          ( "/some/master/directory" ("-d" "-I/usr/local/include") )
          )
        ( "^/users/jdoe/sources/gnome/"
          ( "/master/gnome/database" ("-d") )
          )
        )))

    :config
    (cscope-setup)
    )
#+end_src

* Text folding/hiding

** Hide show
#+begin_src emacs-lisp
  (use-package hideshow
    :ensure nil                           ; Built-in
    :delight
    :commands (hs-show-block hs-hide-level)
    :custom
    (hs-allow-nesting t)
    (hs-isearch-open t)
    :config
    (defun my/toggle-hs-level ()
      "hide/show the next level"
      (interactive) (hs-show-block) (hs-hide-level 1))
    )
#+end_src

** Selective display
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil                           ; Feature, not package
    :bind ("C-x $" . my/toggle-selective-display)
    :config
    ;; Define the function here, as it's a custom command.
    (defun my/toggle-selective-display ()
      "Set selective-display to current column or toggle selective-display."
      (interactive)
      (let ((arg (progn (back-to-indentation) (1+ (current-column)))))
        (set-selective-display (if (eq arg selective-display) nil arg))))
    )
#+end_src

** Narrowing
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil                           ; Feature, not package
    :config
    ;; enable 'narrow-to-region', which is disabled by default.
    (put 'narrow-to-region 'disabled nil)
    )
#+end_src

* AI/LLM

** gptel

#+begin_src emacs-lisp
  (use-package gptel
    :defines gptel-mode-map
    :commands (gptel-make-gh-copilot gptel-make-deepseek gptel-make-openai auth-source-search)
    :bind (:map gptel-mode-map ("C-c C-c" . gptel-send))
    :hook ((gptel-post-stream . gptel-auto-scroll))

    :custom
    (gptel-default-mode 'org-mode)

    :config
    (gptel-make-gh-copilot "CopilotChat")

    (gptel-make-deepseek "DeepSeek"
      :stream t
      :key (lambda ()
             (require 'auth-source)
             (let ((result (auth-source-search :host "deepseek" :require '(:secret))))
               (if result
                   (funcall (plist-get (car result) :secret))
                 (error "Failed to retrieve DeepSeek API key"))))
      )

    (with-eval-after-load 'gptel-bedrock
      (setq gptel-bedrock--model-ids
            (append gptel-bedrock--model-ids
                    '((sonnet-previous . "us.anthropic.claude-sonnet-4-20250514-v1:0")
                      (sonnet-latest . "us.anthropic.claude-sonnet-4-5-20250929-v1:0")))))

    (gptel-make-bedrock "Bedrock"
      :stream t
      :region "us-east-1"
      :models '(sonnet-previous sonnet-latest)
      :aws-profile "ai-coder-llm"))
#+end_src

*** DeepSeek authentication note

To authenticate with the DeepSeek API, ensure your auth source includes an entry
like this:
#+begin_src text
machine deepseek login apikey password sk-*******
#+end_src

See [[*Store credentials: auth source][Store credentials: auth source]] for more information with regards to auth
source.

*** Choose backend

I didn't find an elegant approach to register multiple backends and switch
~gptel-backend~ (the default backend) among them with one-line configuration
change. Therefore, I decided to not set ~gptel-backend~ in the configuration
file but choose the model when start to use gptel.
1. Call ~C-u M-x gptel-send~
2. In transient menu: type in ~-m~ then select the designated backend (for
   instance, "DeepSeek:deepseek-reasoner")
3. Press ~<Enter>~ to actually send prompt or ~C-g~ to cancel.

*** Chat in a dedicated buffer
1. Run =M-x gptel= to create a dedicated buffer.
2. Type your questions or input in the buffer.
3. Run =M-x gptel-send= to send the text to the LLM backend.
4. Repeat steps 2 and 3 as needed.

NOTE: Unless a region is active, =gptel-send= sends all text from the
beginning of the buffer to the cursor position to maintain context. To save
costs, avoid unnecessarily long sessions.

*** Custom prompt on selected text

1. Select a snippet of text.
2. Run =C-u M-x gptel-send=
3. Optional: press =s= to set system message. (Ask AI for what is "system
   message").
4. Optional: press =d= and enter a custom instruction, say "explain this code
   snippet".
5. Optional: tweak other settings via the transient menu.
6. Press =RET= and wait for the response to complete.

*** Rewrite selected text

Rewriting selected text is a more specific type of request for selected text and
has a dedicated function: =gptel-rewrite=. This function offers slightly
simplified interactions.

1. Run =M-x gptel-rewrite= (no prefix =C-u= needed).
2. Optional: Press =s/d= to adjust settings if necessary.
3. Press =r= to send the request.
4. Wait for the server to respond.
5. Ensure the cursor is in the rewritten region, press =RET= and then choose an
   action following the screen output.

** Copilot chat

While gptel is already powerful and supports Copilot Chat, this package provides
additional convenience. For example, =M-x copilot-chat-explain= is much simpler
than manually crafting prompts with =C-u M-x gptel-send=.

#+begin_src emacs-lisp
  (use-package copilot-chat
    :commands (copilot-chat-display
               copilot-chat-custom-prompt-selection
               copilot-chat-optimize
               copilot-chat-explain
               copilot-chat-how
               )

    :defines (copilot-chat-prompt-mode-map copilot-chat-mode-map)

    :bind (:map global-map
                ("<f7>" . copilot-chat-display)
                :map copilot-chat-prompt-mode-map
                ("C-c C-c" . copilot-chat-prompt-send))

    :hook ((copilot-chat-prompt-mode copilot-chat-mode) . visual-line-mode)

    :custom
    (copilot-chat-frontend 'org)
    ;; Only `gpt-4.1' provides unlimited access. To temporarily switch to another
    ;; modle, please use `M-x copilot-chat-set-model'.
    (copilot-chat-default-model "gpt-4.1")

    :config
    (defun copilot-chat-how ()
      (interactive)
      (copilot-chat-custom-prompt-selection "how to "))
    )
#+end_src

*** Authentication
On first use, you must authenticate via a web browser.
- Local GUI Host: The browser will open automatically.
- Remote Headless Host:
  1. Ensure Emacs can open a browser successfully although we do not use that
     browser for the login flow. Typically this is done by setting the browser
     function to the built-in ~eww~.
     #+begin_src emacs-lisp :tangle no
       (setq browse-url-browser-function 'eww-browse-url)
     #+end_src
  2. Copy the authentication URL provided by Emacs.
  3. Open it in a browser on a windowing device (e.g., your local machine).
  4. Complete the login flow.

*** Usage
- How to ask questions (send prompts to the LLM):
  - In the dedicated buffer: press ~<f7>~ (bound to ~copilot-chat-display~) to
    go to the Copilot Chat buffer, type in your query in it and then press ~C-c
    C-c~ (~copilot-chat-prompt-send~) to send the query to the LLM server.
  - In any buffer: select the text of concern, then run =M-x
    copilot-chat-custom-prompt-selection= and type in your custom prompt and
    enter.
- An alternative configuration that use a shell CLI style front-end
  #+begin_src emacs-lisp :tangle no
    (use-package copilot-chat
       :load-path (lambda() (concat my-downloads "copilot-chat.el"))
       :custom
       (copilot-chat-frontend 'shell-maker)
       )

     (use-package copilot-chat-shell-maker
       :load-path (lambda() (concat my-downloads "copilot-chat.el"))
       :config
       (push '(shell-maker . copilot-chat-shell-maker-init) copilot-chat-frontend-list)
       )
  #+end_src

** Copilot

This is a plugin for copilot code completion.

For first time use, remember to run =M-x copilot-install-server= and =M-x
copilot-login=.

#+begin_src emacs-lisp
  (use-package copilot
    :commands copilot-mode
    :defines copilot-completion-map
    :bind (:map copilot-completion-map
                ("C-e" . copilot-accept-completion)
                ("M-f" . copilot-accept-completion-by-word)
                ("M-n" . copilot-next-completion)
                ("M-p" . copilot-previous-completion)
                )
    :custom (copilot-log-max 50000)
    ;; :hook (python-ts-mode python)
    )
#+end_src

** COMMENT Minuet

This is another code completion plugin. The following configuration uses
DeepSeek as its backend. It is currently disabled due to performance latency I
observed, which may be or be not specific to my setup.

Firstly, add your DeepSeek API key to one of your =auth-source= files in the
following format:
#+begin_src text
  machine deepseek login apikey password your_deepseek_api_key
#+end_src
Replace =your_deepseek_api_key= with your actual API key (e.g., =sk-xxxxx=).

Then, add the following to your Emacs configuration file.
#+begin_src emacs-lisp :tangle no
  (use-package minuet
    :after auth-source
    :defines minuet-openai-fim-compatible-options
    :functions auth-source-search minuet-set-optional-options

    :bind
    (:map global-map
          ("<f6>" . minuet-next-suggestion))

    :init                  ; use `:init` to set env *before* this module is loaded
    (let ((auth (auth-source-search :host "deepseek" :require '(:secret))))
      (if auth (setenv "DEEPSEEK_API_KEY" (funcall (plist-get (car auth) :secret)))
        (warn "DeepSeek unavailable: API key not in auth source")))

    :custom
    (minuet-provider 'openai-fim-compatible)
    (minuet-request-timeout 20)

    :config
    (minuet-set-optional-options minuet-openai-fim-compatible-options :max_tokens 256)
  )
#+end_src

** Claude Code

*** Prerequisite

Install and configure Claude Code. See [[file:ai.org::*Claude][my Claude notes]] for details.

*** Agent Shell

This package is a *native Emacs shell* that interacts with LLM agents using ACP
(Agent Client Protocol), providing a more native Emacs experience than most
other implementations, including ~claude-code-ide.el~, which are essentially
thin wrappers around the Claude Code CLI.

However, it currently lacks some features offered by ~claude-code-ide.el~, such
as typing prompts in the minibuffer and context awareness.

Additional dependency:
- ~claude-code-acp~
  #+begin_src bash
    npm install -g @zed-industries/claude-code-acp
  #+end_src

#+begin_src emacs-lisp
  (use-package agent-shell
    :bind (:map agent-shell-mode-map
                ;; Use RET for newline as S-RET does not work in terminals.
                ;; Original RET functionality is bound to `C-c C-c', matching
                ;; other LLM packages.
                ("RET" . agent-shell-newline)
                ("C-c C-c" . shell-maker-submit)))
#+end_src

*** claude-code-ide.el

#+begin_src emacs-lisp
  (use-package claude-code-ide
    :vc (:url "https://github.com/manzaltu/claude-code-ide.el" :rev :newest)
    :bind (:map global-map  ("C-c c" . claude-code-ide-menu))
    :config (claude-code-ide-emacs-tools-setup) ; Optionally enable Emacs MCP tools
    )
#+end_src

** Aider

#+begin_src emacs-lisp
  (use-package aidermacs
    :bind (;; `global-map' by default by :bind
           ("C-c a" . aidermacs-transient-menu)
           :map aidermacs-comint-mode-map
           ;; <return> does the job. Adding "C-c C-c" for ergonomic consistency.
           ("C-c C-c" . comint-send-input)))
#+end_src

*** Prerequisites

- Install Aider, follow the install instructions from [[https://aider.chat/docs/llms/bedrock.html#amazon-bedrock][aider docs]].
- Access to AWS Bedrock.
- Configure Aider to use AWS Bedrock. Below is an example =~/.aider.conf.yml=.
  #+begin_src yaml-ts
    # Use bedrock
    set-env:
      - AWS_PROFILE=ai-coder-llm
      - AWS_REGION=us-east-1
    model: bedrock/us.anthropic.claude-sonnet-4-20250514-v1:0
  #+end_src

* Version Control

** magit
#+begin_src emacs-lisp
  (use-package magit
    :bind (:map global-map ("C-x g" . magit-status))

    :custom
    ;; Show committer date instead of author date in log margin
    (magit-log-margin-show-committer-date t)
    ;; In magit status buffer, show log margin including author and age
    (magit-status-margin '(t age magit-log-margin-width t 18))
    ;; In magit log buffer, display date instead of age
    (magit-log-margin '(t "%y-%m-%d %H:%M %z" magit-log-margin-width t 18))

    :hook
    (magit-refresh-buffer
     . (lambda() (when (fboundp 'custom-urls) (custom-urls)))))
#+end_src

If you see errors from ~magit~ or ~forge~ after an update, your built-in
~transient~ package is likely outdated. To fix it, force a re-installation:
1. Enable upgrades for built-in packages:
   #+BEGIN_SRC emacs-lisp :tangle no
   (setq package-install-upgrade-built-in t)
   #+END_SRC
2. Reinstall packages (using ~M-x package-reinstall~) in the following order:
   1) ~transient~
   2) ~magit~
   3) ~magit-section~
   4) ~forge~
3. Restart Emacs (mandatory)

*** Notes on ediff

By default, ~e~ (~magit-ediff-dwim~) on an unstaged or staged change (not a
commit) performs a 3-way ediff between the worktree, index, and HEAD. This
behavior may not always be what you want. In such case, you can use ~E~ (capital
~E~, ~magit-ediff~) to perform 2-way ediff. Below are some examples:
+ ~E u~ :: ediff the worktree against indexed, i.e. view unstaged changes
+ ~E w~ :: ediff the worktree against HEAD

** git-gutter
#+begin_src emacs-lisp
  ;; Choose this package over diff-hl because the later does not work in 'emacs
  ;; -nw'.
  (use-package git-gutter
    :delight
    :commands global-git-gutter-mode
    :custom
    (git-gutter:modified-sign " ")
    (git-gutter:added-sign " ")
    (git-gutter:deleted-sign " ")
    :init
    (global-git-gutter-mode t)
    :config
    (set-face-background 'git-gutter:modified "DarkOrange")
    (set-face-background 'git-gutter:added "green")
    (set-face-background 'git-gutter:deleted "red")
    :bind (:map global-map
                ("C-x v [" . git-gutter:previous-hunk)
                ("C-x v ]" . git-gutter:next-hunk)
                ("C-x v =" . git-gutter:popup-hunk)
                ("C-x v s" . git-gutter:stage-hunk)
                ("C-x v r" . git-gutter:revert-hunk)
                )
    )
#+end_src

To diff with a revision other than the latest one, in the repo root directory,
add content similar to the following to the emacs directory local variable file
(=.dir-locals.el=):
#+begin_src emacs-lisp :tangle no
((prog-mode . ((git-gutter:start-revision . "my_branch"))))
#+end_src
Or
#+begin_src text
((nil . ((git-gutter:start-revision . "my_branch"))))
#+end_src

** git-link

The following setup is optimised for a common workflow where I am frequently
working on local, unpushed branches.

#+begin_src emacs-lisp
  (use-package git-link
    :custom
    (git-link-open-in-browser t)
    (git-link-default-branch "master")
    (git-link-use-commit nil))
#+end_src

*** Rationale and Usage

This configuration provides flexibility for two common scenarios:

- Linking to code when I am on a local, unpushed branch

  + Problem :: When working on a local branch, the commit hash is not yet
    visible to others. A permalink to that commit would be a broken link.
  + Solution :: With the configuration above, running ~M-x git-link~ generates a
    link to the file's latest version on the default branch (e.g., ~master~).
    This provides a stable, shareable reference point. The link opens in your
    browser, where I can manually select lines and create a permalink.

- Linking to code when I am on a pushed commit
  + Problem :: Since the commit is already on the remote, we can get a permalink
    without directly.
  + Solution :: Simply use double prefix argument, i.e. ~C-u C-u M-x git-link~.
    This overrides the default settings and copies a full permalink (including
    the commit hash) directly to my kill-ring, ready to be shared.

** blamer

#+begin_src emacs-lisp
  (use-package blamer
    :commands (blamer-mode global-blamer-mode))
#+end_src

- I do not turn on =global-blamer-mode= but instead run =M-x blamer-mode= in a
  specific buffer when designated.

** code review

Our development process is centered around GitHub, with code review requests
being managed through GitHub Pull Requests (PRs). However, using the GitHub web
UI for reviewing PRs presents some challenges:
- Navigating to related code can be cumbersome.
- An active internet connection is required at all times.

*** Navigation made easy by checking out code locally

To mitigate the first issue, I review code locally using Emacs. Here's how I
streamline the process:
1. Preparation
   1) Fetch and Checkout: Begin by fetching and checking out the PR branch on your local machine.
   2) Generate a Diff: In the Magit status or Magit log buffer, select all the commits you need to review. Press d r to generate the diff.
2. Review
   - Press =e= to use ediff if needed.
   - Press =C-j= at a line to navigate to the corresponding source file,
     allowing you to move around the codebase as usual to examine related code.

*** Read and write feedback offline with forge and code-review

Normally I do not require this. However, when needed, I use a combination of
forge and code-review, though this setup is not entirely perfect. Forge can
fetch the PR list but could not display inline comments, whereas Code Review
displays inline comments but does not fetch PR lists. Heres how I use both
tools together:
1. Use =N f f= to fetch the PR list.
2. Move cursor to the desired PR and copy its link by pressing =C-c C-w=.
3. Execute =M-x code-review-start= and paste the copied link from the previous
   step.

#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :defines magit-status-mode-map
    :bind (:map magit-status-mode-map
                ;; To defer loading this package until N is pressed in
                ;; magit-status buffer
                ("N" . forge-dispatch))
    :custom-face
    ;; Do not share "MediumPurple" with merged pull requests.
    (forge-pullreq-rejected ((t (:foreground "DarkRed" :strike-through t)))))
#+end_src

#+begin_src emacs-lisp
  (use-package code-review
    :load-path (lambda() (concat my-downloads "code-review"))
    :commands (code-review-start)
    )
#+end_src

Apart from the above Emacs configuration, also remember to:
- Add github username into git config.
- Add the corresponding github token to auth source. For me, it is adding the
  following two lines to =~/.authinfo.gpg=
  #+begin_src text
        machine api.github.com login lgfang^forge password ******
        machine api.github.com login lgfang^code-review password ******
  #+end_src

NOTE:
- Display all PRs in the magit status buffer can slow down normal magit
  operations quit a bit. Use =M-x forge-toggle-display-in-status-buffer= to hide
  PR information when it is unnecessary.
- The official code-review is broken, use the following one
  #+begin_src text
    $ git remote -v
    origin  git@github.com:phelrine/code-review.git (fetch)
    origin  git@github.com:phelrine/code-review.git (push)

    $ git branch
    ,* fix/closql-update
  #+end_src

* ANSI color code

#+begin_src emacs-lisp
  (use-package ansi-color
    :hook (;; render color codes in the compilation buffer.
           (compilation-filter . ansi-color-compilation-filter))
    )

  (use-package flg-ansi-color-mode
    :load-path my-elisps
    :after ansi-color
    :commands flg-ansi-color-mode
    )
#+end_src

* ASM

#+begin_src emacs-lisp
  (use-package asm-mode
    :ensure nil                           ; Built-in
    :mode "\\.asm\\'"
    :custom
    (asm-comment-char 59)                 ; 35 -> '#', 59 -> ';'
    )
#+end_src

* Bash

#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil                           ; Built-in
    :commands (sh-mode shell-script-mode)
    :custom ((sh-basic-offset 2) (sh-indentation 2))
    )
#+end_src

** Language server
Eglot + [[https://github.com/bash-lsp/bash-language-server][bash-language-server]]

** Formatter
See also [[* Prettier]]

1. Install [[https://github.com/mvdan/sh][shfmt]] in command line.
2. Package install =shfmt=.

#+begin_src emacs-lisp
  (use-package shfmt
    :delight shfmt-on-save-mode
    :hook ((sh-mode bash-ts-mode) . shfmt-on-save-mode)
    :custom (shfmt-arguments
             '("-i" "2"   ; indent by 2 spaces
               "-bn"      ; binary ops like && and | may start a line
               "-ci"      ; switch cases will be indented
               "-s"       ; simplify the code
               "-sr"      ; redirect operators will be followed by a space
               )))
#+end_src

* C/C++

** Language server

Eglot + =clangd= (on MacOS, =clangd= comes with Developer Command Line Tools)

** Formatter

First, install =clang-format=:
- MacOS :: =brew install clang-format=
- Ubuntu =sudo apt install clang-format=.

Then configure in Emacs:
#+begin_src emacs-lisp
  (use-package clang-format
    :commands clang-format-buffer clang-format-region clang-format-on-save-mode
    :delight clang-format-on-save-mode
    ;; do not hook `clang-format-on-save-mode' due to legacy code
    )
#+end_src

** hide ifdefs

#+begin_src emacs-lisp
  (use-package hideif
    :ensure nil                           ; Built-in
    :delight hide-ifdef-mode
    :hook ((c-mode c-ts-mode c++-mode c++-ts-mode) . hide-ifdef-mode)

    :custom
    ;; Fold all #ifdef blocks by default when `hide-ifdef-mode' is activated. This
    ;; prevents accidentally working in undefined blocks.
    (hide-ifdef-initially t)
    ;; (hide-ifdef-shadow t)                 ; shadow instead hide the text

    :config
    ;; Must set it in `:config' as `:custom' doesn't work for this variable
    (setq hide-ifdef-define-alist
     '(
       ;; Default alist (empty), fold all #ifdef (but *not* #ifndef) blocks
       (default)
       ;; MongoDB-specific macros for macOS
       (mongodb-mac __APPLE__
                    (__LIBCPP_STD_VER . 14)
                    )

       ))
    )
#+end_src

** GDB

#+begin_src emacs-lisp
  (use-package gud
    :ensure nil                           ; Built-in
    :mode ("\\.gdb\\'" . gdb-script-mode))
#+end_src

* CSV

Aligning columns in CSV files (=csv-align-mode=) is usually the most intuitive
presentation method. However, the added whitespace can sometimes extend lines
far beyond the screen width. In such cases, consider highlighting the columns
with different colors instead (=rainbow-csv-mode=).

#+begin_src emacs-lisp
  (use-package csv-mode
    :commands (csv-mode csv-align-mode tsv-mode)
    :hook ((csv-mode . csv-align-mode)))
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-csv
    :load-path (lambda() (concat my-downloads "rainbow-csv"))
    :delight
    :commands rainbow-csv-mode
    :hook ((csv-mode . rainbow-csv-mode)))
#+end_src

* Emacs lisp (elisp)
#+begin_src emacs-lisp
  (use-package elisp-mode
    :ensure nil                           ; Feature, not package
    ;; ".el"    -
    ;; ".eli"   - Emacs Lisp Info files
    ;; ".emacs" - Legacy configuration file
    :mode ("\\.\\(el\\|eli\\|emacs\\)\\'" . emacs-lisp-mode))
#+end_src

* Golang

No extra set up needed except for installing [[https://github.com/golang/tools/blob/master/gopls/README.md][gopls]] (the official language server
for golang).
- LSP: eglot + gopls
- Formatter: =eglot-format=
- Flymake: eglot as the backend

* Java

** Language server
Eglot + [[https://github.com/eclipse-jdtls/eclipse.jdt.ls][Eclipse JDT Language Server (JDTLS)]]

1. Download a milestone build of JDTLS and extract it to =~/.local=.
2. Add the path to =jdtls= to Emacs exec path:
   #+begin_src emacs-lisp
   (add-to-list 'exec-path (expand-file-name "~/.local/jdt-language-server/bin"))
   #+end_src
   Alternatively, add the path to the OS environment variable =PATH= and restart
   Emacs.

* JavaScript
#+begin_src emacs-lisp
  (use-package js
    :mode "\\.js\\'"
    :hook (js-mode . hs-minor-mode)
    :bind (:map js-mode-map
                ("M-'" . my/toggle-hs-level)
                ("<mouse-3>" . my/toggle-hs-level))
    :custom
    (js-basic-offset 2))
#+end_src

* JSON, JSON Lines

** JSON ts mode
#+begin_src emacs-lisp
  (use-package json-ts-mode
    :ensure nil                           ; Built-in
    :mode "\\.json\\(l?\\)\\'" "mongod.*\\.log" ; mongod logs are json lines
    )
#+end_src

** Formatter
#+begin_src emacs-lisp
  (use-package json
    :ensure nil                           ; Built-in
    :commands (json-pretty-print-buffer
               json-pretty-print-buffer-ordered
               json-pretty-print
               json-pretty-print-ordered)
    :hook (((json-mode json-ts-mode) . my/json-prettify))
    :config
    (defun my/json-prettify()
        (add-hook 'before-save-hook #'json-pretty-print-buffer nil t)))
#+end_src

** Structured log mode
This is a minor I wrote to display log files formatted as JSON lines in a more
human friendly way.
#+begin_src emacs-lisp
  (use-package structured-log-mode
    ;; my own package for viewing json format log files.
    :load-path (lambda() (concat my-elisps "structured-log-mode"))
    :commands structured-log-mode
    )
#+end_src

** JSON path to the node at point

This function is based on treesit (=json-ts-mode=)
#+begin_src emacs-lisp
  (use-package json-ts-mode
    :commands
    (treesit-node-at treesit-parent-until treesit-node-text treesit-node-index
                     lgf-json-path)
    :config
    (defun lgf-json-path (&rest _ignored)
      (let* ((pos (point))
             (node (treesit-node-at pos)) ; can be a punctuation node
             (filter (lambda(n)
                       (member (treesit-node-type n) '("pair" "array"))))
             (parent (treesit-parent-until node filter))
             (path nil))
        (while parent
          (setq path
                (cons
                 (pcase (treesit-node-type parent)
                   ("pair"
                    (treesit-node-text
                     (treesit-node-child (treesit-node-child parent 0) 1)
                     t))
                   ("array"
                    ;; NOTE: Cannot handle comments, but it is fine because the
                    ;; JSON standard says no comments.
                    (let* ((one-level-up (treesit-node-parent node))
                           (not-in-object (treesit-node-eq one-level-up parent))
                           (array-elem (if not-in-object node one-level-up))
                           )
                      (/ (1- (treesit-node-index array-elem)) 2))))
                 path))
          (setq node parent)
          (setq parent (treesit-parent-until parent filter)))
        (mapconcat (lambda(p) (format "%s" p)) path ".")))
    (defun lgf-json-path-set-up-eldoc ()
      (if (boundp 'eldoc-documentation-functions)
          (add-hook 'eldoc-documentation-functions #'lgf-json-path nil t)
        (setq-local eldoc-documentation-function #'lgf-json-path)))
    :hook ((json-ts-mode . lgf-json-path-set-up-eldoc))
    )
#+end_src

* LDAP Schema (LDIF)

Currently Emacs lacks support for editing LDAP schema (LDIF) files:
- The built-in package ~ldap.el~ is for LDAP server connections, *not* LDIF
  editing.
- The ~ldap-mode.el~ (v1.2, by Dave Love) offers very limited functionality
  (i.e. incomplete syntax highlighting) and is no longer maintained.

Hence, I recommend using ~fundamental-mode~ for LDIF files until a better
alternative emerges.

* Markdown

** Markdown language support

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode ("\\.md\\'" . markdown-mode)
    :custom (markdown-command "pandoc"))
#+end_src

** Realtime preview using markdown-preview-mode

#+begin_src emacs-lisp
  (use-package markdown-preview-mode
    :commands markdown-preview-mode
    :custom
    (markdown-preview-stylesheets
     (list "https://cdn.jsdelivr.net/gh/hyrious/github-markdown-css@main/dist/light.css")))
#+end_src

+ Advantage: A key benefit is the ability to use online CSS files, which offers
  great flexibility for styling the preview.
+ Challenge: Find a compatible CSS file to replicate the GitHub markdown style.

*** How It Works

1. With a Markdown file open, you run the command ~M-x markdown-preview-mode~.
2. The package converts the current buffer's Markdown content to HTML using an
   internal parser.
3. It starts a simple, built-in web server within Emacs to serve the generated
   content.
4. It automatically opens your default web browser to a local URL, displaying
   the rendered page.
5. As you edit the Emacs buffer, the preview in the browser is updated when you
   save the buffer or idle.
6. Toggling ~M-x markdown-preview-mode~ off or killing the buffer stops the the
   associated server process.

** COMMENT Realtime preview using grip-mode

Firstly install the command line tool [[https://github.com/chrishrb/go-grip][go-grip]], then configure [[https://github.com/seagle0128/grip-mode][grip-mode]] in
Emacs:

#+begin_src emacs-lisp
  (use-package grip-mode)
#+end_src

This package offers an alternative to ~markdown-preview-mode~ by using the
external command-line tool [[https://github.com/chrishrb/go-grip][go-grip]] to render Markdown and Org-mode files with
GitHub's styling.

For Org-mode files, ~grip-mode~ first exports the buffer content to Markdown
before passing it to ~go-grip~ for rendering.

A benefit of this approach is that it functions entirely offline, as it
does not depend on an internet connection to download CSS files.

*Important Security Notice*

However, please note the following behaviors of the ~go-grip~ web server:
- It listens on all network interfaces, not just ~localhost~.
- It provides web access to all files in the target directory.

* Mermaid chart

#+begin_src emacs-lisp
  (use-package mermaid-mode
    :mode "\\.mmd\\|.mermaid\\'")
#+end_src

The ~mermaid-mode~ package depends on the mermaid cli tool, which is installed
on macOS using the following command:
#+begin_src bash
npm install -g @mermaid-js/mermaid-cli
#+end_src

* Perl

Both ~perl-mode~ and ~cperl-mode~ are now built-in packages. While ~perl-mode~
is the simpler default, I generally prefer the more sophisticated ~cperl-mode~.
#+begin_src emacs-lisp
  (use-package cperl-mode
    :ensure nil                           ; Built-in
    :mode ("\\.\\([pP]\\([Llm]\\|erl\\|od\\)\\|al\\)\\'" . cperl-mode)
    :interpreter ("perl" . cperl-mode)    ; shebang support
    :init
    ;; Disable the default perl-mode autoloading
    (setq auto-mode-alist (rassq-delete-all 'perl-mode auto-mode-alist))
    :custom
    (cperl-indent-level 4)
    (cperl-close-paren-offset -4)
    (cperl-continued-statement-offset 4)
    (cperl-indent-parens-as-block t)
    (cperl-tab-always-indent t))
#+end_src

* PHP
#+begin_src emacs-lisp
  (use-package php-mode
    :mode ("\\.php\\'" "\\.phtml\\'") ; Auto-activate for .php and .phtml files
    :custom
    (php-mode-indent-offset 4)
    (php-align-assignments t)  ; Align assignments like $var = 'value';
    (php-electric-colon t)     ; Automatically insert '->' after class/object name
    (php-template-mode nil)    ; Set to t if work with mixed HTML/PHP extensively
    )
#+end_src

* Python

** Tree-sitter enhanced major mode
#+begin_src emacs-lisp
  (use-package python
    :hook ((python-mode python-ts-mode) . hs-minor-mode)
    :custom
    ;; triple quotes on their own lines
    (python-fill-docstring-style 'django)
    ;; for empty python files, as existing files use existing indent offset.
    (python-indent-offset 4)
    )
#+end_src

** Formatter
#+begin_src emacs-lisp
  (use-package ruff-format
    :delight ruff-format-on-save-mode
    :after reformatter
    :hook ((python-mode python-ts-mode) . ruff-format-on-save-mode)
    )
#+end_src

#+begin_src emacs-lisp
  (use-package ruff-fix
    :load-path (lambda() (concat my-elisps "emacs-ruff-fix"))
    :after reformatter
    :delight ruff-fix-on-save-mode
    :commands ruff-fix-buffer
    ;; :hook ((python-mode python-ts-mode) . ruff-fix-on-save-mode)
    )
#+end_src
NOTE: I prefer not to turn on the on =ruff-fix-on-save-mode= because it
sometimes can be a little bit obtrusive.

** Basic syntax check
#+begin_src emacs-lisp
  (use-package flymake-ruff
    ;; in addition to LSP
    :after flymake
    :hook ((python-mode . flymake-ruff-load)
           (python-ts-mode . flymake-ruff-load)
           ;; `flymake-ruff-load' can be safely added to `eglot-managed-mode-hook'
           ;; because it targets on python modes only.
           (eglot-managed-mode . flymake-ruff-load)))
#+end_src

** Poetry virtual environment

If the Python project uses Poetry for dependency management, this
package can activate the project's virtual environment in Emacs.

#+begin_src emacs-lisp
  (use-package poetry
    :commands (poetry-tracking-mode poetry-venv-workon poetry-venv-deactivate)
    )
#+end_src

IMPORTANT:
- Run =poetry install= first to ensure packages are installed into the virtual
  environment.
- Run =M-x poetry-venv-workon= to manually activate a virtual environment.
- Run =M-x vterm= (or =M-x poetry-shell=), then execute =poetry env info= to
  verify the correct virtual environment is active.
  + If the wrong environment is activated (e.g., due to nested =pyproject.toml=
    files), re-run =poetry-venv-workon= with the desired =pyproject.toml= as the
    current buffer.
- Restart processes that depend on the virtual environment after activation. For
  example:
  - Run =M-x eglot-shutdown= followed by =M-x eglot= to restart the =pyright=
    used by =eglot=.
  - Kill the *Python* buffer and re-create it (=C-c C-p= or =M-x run-python=).

** LSP

pyright

* RFC
#+begin_src emacs-lisp
  (use-package rfc-mode
    :mode ("/rfc[0-9]+\\.txt\\'" . rfc-mode)
    :custom
    ;; ffap tries to find RFCs in these directories before giving a URL
    (ffap-rfc-directories '("~/projects/rfc"))
    ;; ffap no longer downloads RFCs, `rfc-mode-read` downloads RFC to this
    ;; directory.
    (rfc-mode-directory "~/projects/rfc")
    )
#+end_src
- g :: go to section
  - Note: it is *not* a =rfc-mode= issue that this (and imenu) does not work for
    some RFCs, such as RFC-3262. The issue lies with the RFCs themselves: they
    lack periods (.) after section numbers.
- n/p :: next/previous section
- PageDown/PageUp :: previous/next page
- TODO: u/d :: one level up/one level down

* Tcl & expect
#+begin_src emacs-lisp
  (use-package tcl
    :ensure nil                           ; Built-in
    :mode ("\\.tcl\\'" . tcl-mode)
    :config
    (add-to-list 'interpreter-mode-alist '("expect" . tcl-mode)))
#+end_src

* Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :mode "\\.tf\\'"
    :custom (terraform-indent-level 2))
#+end_src

* Verilog
#+begin_src emacs-lisp
  (use-package verilog-mode
    :ensure nil                           ; Built-in
    :mode ("\\.v\\'" . verilog-mode))
#+end_src

* Vimrc

#+begin_src emacs-lisp
  (use-package vimrc-mode
    :mode  ("._vimrc\\'" . vimrc-mode))
#+end_src

* XML

** nXML
#+begin_src emacs-lisp
  (use-package nxml
    :ensure nil                           ; Built-in
    :mode ("\\.xml\\'"
           "\\.xsd\\'"
           "\\.sch\\'"
           "\\.rng\\'"
           "\\.xslt\\'"
           "\\.svg\\'"
           "\\.rss\\'")
    :magic ("<\\?xml ") ; Match files starting with <?xml
    :hook (nxml-mode . hs-minor-mode)
    :commands (nxml-backward-up-element xmltok-start-tag-local-name)
    :bind (:map nxml-mode-map
                ("M-'" . my/toggle-hs-level)
                ("<mouse-3>" . my/toggle-hs-level)
                )
    :config
    (defun nxml-where ()
      "Display XPath in mini buffer, from http://www.emacswiki.org/emacs/NxmlMode."
      (interactive)
      (let ((path nil))
        (save-excursion
          (save-restriction
            (widen)
            (while
                (and (< (point-min) (point)) ;; Doesn't error if point is at
                     ;; beginning of buffer
                     (condition-case nil
                         (progn
                           (nxml-backward-up-element) ; always returns nil
                           t)
                       (error nil)))
              (setq path (cons (xmltok-start-tag-local-name) path)))
            (if (called-interactively-p t)
                (message "/%s" (mapconcat 'identity path "/"))
              (format "/%s" (mapconcat 'identity path "/")))))))

    (add-to-list 'hs-special-modes-alist
                 '(nxml-mode
                   ;; "<!--\\|<[^/>]*[^/]>" ;; regexp for start block
                   ;; "-->\\|</[^/>]*[^/]>" ;; regexp for end block
                   "<!--\\|<[^/>][^>]*[^/]>" ;; our xml has names like calea/li
                   "-->\\|</[^/>][^>]*[^/]>"
                   "<!--" ;; regexp for comment start. (need this??)
                   nxml-forward-element
                   nil))
    )
#+end_src

** Relax-NG Compact (RNG & RNC)

#+begin_src emacs-lisp
  (use-package rnc-mode
    :mode ("\\.rnc\\'" . rnc-mode)
    :config
    (defun rnc2rng ()
      "Convert current RNC buffer to RNG."
      (interactive)
      (let* ((rnc (buffer-file-name))
             (rng (concat (file-name-sans-extension rnc) ".rng")))
        (call-process "java" nil nil nil "-jar"
                      (expand-file-name "~/.emacs.d/downloads/trang.jar")
                      rnc rng))))
#+end_src

* YAML

** Formatter
See [[* Prettier]]

** Tree-sitter enhanced major mode
#+begin_src emacs-lisp
  (use-package yaml-ts-mode
    :mode ("\\.y\\(a?\\)ml\\'" . yaml-ts-mode)
    )
#+end_src

** YAML pro
#+begin_src emacs-lisp
  (use-package yaml-pro
    :hook ((yaml-ts-mode . yaml-pro-ts-mode))
    :bind (:map yaml-pro-ts-mode-map
                ;; `yaml-pro-ts-yank' is annoying, keep the standard `yank' by
                ;; removing the command remapping.
                ([remap yank] . nil)
                ;; Reserve this for `org-edit-src-exit'
                ("C-c '" . nil)))
#+end_src

I don't perform complex YAML edits. I install yaml-pro for two features:
- YAML path in the mini buffer
- Imenu support

** Flymake
#+begin_src emacs-lisp
  (use-package flymake-yamllint
    :after flymake
    :hook ((yaml-ts-mode . flymake-yamllint-setup))
    )
#+end_src

* Footer
#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src
