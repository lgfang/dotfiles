# -*-mode:org; coding:utf-8; time-stamp-pattern:"8/#\\+DATE:[ \t]+%Y-%02m-%02d %5z$" -*-
# Created: Lungang Fang 2024-05-17

#+TITLE: My Emacs Configurations
#+AUTHOR: Fang Lungang
#+DATE: 2025-05-26 +1000
#+DESCRIPTION: My Emacs configurations
#+KEYWORDS: Emacs
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el :mkdirp yes

* Timestamp for tangling

This block itself is not tangled into any configuration file. However, during
the tangling process, it produces a timestamp that other blocks may reference.

#+name: tangle-time-stamp
#+begin_src emacs-lisp :tangle no
(concat user-full-name " " (format-time-string "%Y-%m-%d %5z"))
#+end_src

* Header

#+begin_src emacs-lisp :noweb yes
  ;;; init.el --- Lungang's init.el -*- lexical-binding: t; -*-

  ;; Created: Fang Lungang 2004
  ;; Updated: <<tangle-time-stamp()>>

  ;;; Commentary:

  ;; This Emacs configuration file is generated from my "emacs.org" (see
  ;; https://github.com/lgfang/dotfiles)

  ;; Usage: Run Emacs with this configuration file. After start up, Emacs will
  ;; report missing packages. Normally you can continue using Emacs without these
  ;; packages. But, for better experience, please firstly run `M-x
  ;; package-refresh-contents` and then run `M-x package-install` to install
  ;; missing packages one after another.

  ;;; Code:
#+end_src

* Bootstrap

** Profile Emacs start time

It is fun to see how long each package takes to load and optimize if possible.
Hence, I use the following configuration.
#+begin_src emacs-lisp
  (use-package use-package-core
    :custom
    (use-package-compute-statistics t)
    )
#+end_src

Run =emacs --no-desktop= to ensure not opening any previous files. Then run the
following commands to see the statistics:
- =M-x use-package-report=
- =M-x emacs-init-time=

** Start up screen
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (inhibit-startup-screen t)
    (initial-scratch-message "")
    )
#+end_src

** Initialize "package"

#+begin_src emacs-lisp
  (use-package package
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    (package-initialize)
  )
#+end_src

To manually upgrade install packages in batch,
1. Run =M-x package-refresh-contents=
2. Run =M-x list-packages=
3. Then, following the prompt in the mini-buffer, type =U= and =x=

** Paths

Note that the =use-package emacs= thing is unnecessary. I'm using it to group
related configurations together.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (defvar my-emacs-d (file-name-as-directory (expand-file-name "~/.emacs.d")))
    (defvar my-downloads (file-name-as-directory (concat my-emacs-d "downloads")))
    (defvar my-elisps (file-name-as-directory (concat my-emacs-d "my-elisps")))
    (add-to-list 'load-path my-elisps t)
    (defvar my-personal-path (file-name-as-directory
                              (expand-file-name "~/mynotes/personal")))
  )
#+end_src

** Personal information

#+begin_src emacs-lisp
  (use-package my-confidential
     :load-path my-personal-path
     )
#+end_src

* Language environment and coding system

Set terminal coding system to utf-8 explicitly to display unicode chars
(including emojis/Chinese chars) correctly.

This block is needed only when utf-8 is supported but Emacs does not detect and
set it correctly, due to wrong shell locale etc. In such situation, try the
combinations of these settings until you find one that works.

Therefore, this block is *not* tangled by default. When necessary, delete
=:tangle no= from this block header to tangle it.

#+begin_src emacs-lisp :tangle no
  (set-terminal-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-language-environment 'utf-8)
#+end_src

* ZWJ (Zero Width Joiner) emoji handling.

Disable =auto-complete-mode= if running in a terminal as most terminal emulators
cannot handle Emoji ZWJ. See ZWJ examples in [[file:~/mynotes/emacs/emacs-unicode-test.org][my ZWJ test file]].

NOTE: disabling it on the fly does not work very well, must restart Emacs.

#+begin_src emacs-lisp
  (use-package emacs
    :if (not (display-graphic-p))
    :config
    (setq-default auto-composition-mode nil)
    )
#+end_src

* Interaction convenience

** Mouse

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (mouse-yank-at-point t)
    (mouse-drag-copy-region t)
    :config
    (when (not window-system) (xterm-mouse-mode 1)) ;use mouse in xterm
    )
#+end_src

** y-or-n
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (fset 'yes-or-no-p 'y-or-n-p)         ; Type y/n to answer yes or no prompts.
    )
#+end_src

** Comment

*** Comment style
#+begin_src emacs-lisp
  (use-package newcomment
    :ensure nil                           ; Built-in
    :custom (comment-style 'extra-line)
    )
#+end_src

*** Comment dwim
#+begin_src emacs-lisp
  (define-advice comment-dwim (:before (&rest _) my-comment-dwim)
    "Smartly comment/un-comment current line when no region is active."
    (unless (or (use-region-p)
                (looking-at-p "[ \t]*$"))
      (push-mark (line-beginning-position) t t)
      (goto-char (line-end-position))))
#+end_src

** Copy/paste

*** Copy/cut the current line

If region is not active, copy or cut the current line instead.

#+begin_src emacs-lisp
  (use-package emacs
    :bind (:map global-map
                ("C-w" . my/cut-region-or-line)
                ("M-w" . my/copy-region-or-line))

    :config
    (defun my/cut-region-or-line ()
      "Cut region (if active) or current line."
      (interactive)
      (if (use-region-p)
          (kill-region (region-beginning) (region-end))
        (kill-whole-line)))

    (defun my/copy-region-or-line ()
      "Copy region (if active) or current line."
      (interactive)
      (if (use-region-p)
          (kill-ring-save (region-beginning) (region-end))
        (kill-ring-save (line-beginning-position) (line-beginning-position 2))))
    )
#+end_src

*** MacOS clipboard integration

#+begin_src emacs-lisp
  (use-package emacs
    :if (eq system-type 'darwin)
    :preface
    (defun my/copy-from-osx ()
      (let ((tramp-mode nil) (default-directory "~"))
        (shell-command-to-string "pbpaste")))
    (defun my/paste-to-osx (text &optional _push)
      (let ((process-connection-type nil))
        (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
          (process-send-string proc text)
          (process-send-eof proc))))
    :custom
    (interprogram-paste-function #'my/copy-from-osx)
    (interprogram-cut-function #'my/paste-to-osx)
    )
#+end_src

NOTE: To use this within tmux session, upgrade to tmux 2.6+.

*** Tmux buffer (clipboard) integration

#+begin_src emacs-lisp :tangle no
  (defun lgfang-send-to-tmux ()
    "Send content of active region or HEAD of the kill-ring to
  tmux's buffer"
    (interactive)
    (let ((file (make-temp-file "/tmp/emacs-to-tmux.clip")))
      (if (region-active-p) (kill-ring-save (region-beginning) (region-end)))
      (with-temp-file file (insert-for-yank (current-kill 0)))
      (call-process "tmux" nil nil nil "load-buffer" file)
      (delete-file file)))

  (defun lgfang-get-from-tmux ()
    "Get current tmux buffer."
    (interactive)
    (call-process "tmux" nil t nil "show-buffer"))
#+end_src

** Ibuffer

#+begin_src emacs-lisp
  (use-package ibuffer                    ; built-in package
    :commands ibuffer-switch-to-saved-filter-groups
    :custom
    (ibuffer-saved-filter-groups
     (quote
      (("default"
        ("Dired" (mode . dired-mode))
        ("LLM" (name . "^\\*\\(Copilot.*\\|\\(DeepSeek\\|.*GPT.*\\|LLM response\\)\\*\\)$"))
        ("Magit" (name . "^magit"))
        ("Emacs" (name . "^\\*.*\\*$"))
        ))))
    ;; Sort by buffer names, to change sort mode interactively, press `,' or `M-x
    ;; ibuffer-toggle-sorting-mode' in the ibuffer.
    (ibuffer-default-sorting-mode 'alphabetic)
    :bind (:map global-map ("C-x C-b" . ibuffer))
    :hook (ibuffer-mode . (lambda() (ibuffer-switch-to-saved-filter-groups "default")))
    )
#+end_src

** Repeat mode

#+begin_src emacs-lisp
  (use-package repeat                     ; built-in package
    :custom
    (repeat-too-dangerous '(kill-this-buffer))
    (repeat-exit-timeout 6)
    ;; (repeat-exit-key  "RET")
    :init
    (repeat-mode)
    )
#+end_src

This section contains general settings for repeat mode. To add repeat mode
support for modes without build in repeat mode support, see [[*org mode repeat map][org mode repeat map]]
for an example.


Note that there is normally no need of setting =repeat-eixt-key=, to exit repeat
mode before =repeat-exit-timeout=, just type any character which is no bound in
this particular repeat mode or =C-g=.

** Vertico + orderless + marginalia + consult
#+begin_src emacs-lisp
  (use-package vertico
    :defer t
    :defines vertico-map
    :functions vertico-mode vertico-multiform-mode
    :bind (:map vertico-map ("C-o" . vertico-quick-exit))
    :custom
    (vertico-resize nil)
    (vertico-cycle nil)
    ;; ;; Avoid `reverse' + `mouse', they are not compatible at the moment.
    ;; (vertico-multiform-categories '(
    ;;                                 ;; default, enable buffer & mouse
    ;;                                 (t buffer mouse)
    ;;                                 ))
    ;; (vertico-multiform-commands '(("imenu" buffer mouse)
    ;;                               ("recentf-.*" buffer mouse)
    ;;                               ))
    :init
    (vertico-mode 1)
    (vertico-multiform-mode 1)
    )

  (use-package orderless
    :defer t
    :custom (completion-styles '(basic
                                 partial-completion
                                 substring
                                 orderless
                                 flex))
    )

  (use-package marginalia
    :defer t
    :functions marginalia-mode
    :init
    (marginalia-mode 1)
    )

  (use-package consult
    :bind (:map global-map
                ;; ("M-s o" . occur)         ; Built-in
                ("M-g i" . consult-imenu)
                ("M-g l" . consult-line)
                ("M-g d" . consult-flymake)
                ("M-y"   . consult-yank-pop) ; replaces `browse-kill-ring'
                )
    )
#+end_src

Other useful consult commands:
- =M-x consult-find= :: when you are certain that a file is within the current
  directory or project, but unsure about its specific sub-directly.

** Embark

#+begin_src emacs-lisp
  (use-package embark
    :defer t
    :bind (:map global-map ("C-x ." . embark-act))
    )
  (use-package embark-consult)
#+end_src

** Subword

#+begin_src emacs-lisp
  (use-package subword
    :ensure nil                           ; Built-in
    :delight
    :config
    (global-subword-mode)
    )
#+end_src

** Sentence

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil                           ; Built-in
    :custom (sentence-end-double-space nil)
    )
#+end_src

- ~M-a~ :: backward sentence
- ~M-e~ :: forward sentence
- ~M-k~ :: kill sentence
- ~C-x <backspace>~ :: backward kill sentence

* Shortcuts to files and links

** ffap
#+begin_src emacs-lisp
  (use-package ffap                       ; built-in
    :defer t
    :bind (:map global-map ("C-x C-f" . ffap))
    :config
    ;; My extensions to ffap jira/sfsc tickets. Remember to define my-employer in
    ;; my-confidential.el
    (defun ffap-jira (name) ; ffap HELP-12345 etc. opens corresponding jira ticket
      (let ((company (if (boundp 'my-employer) my-employer "example")))
        (format "https://jira.%s.org/browse/%s" company name)))
    (add-to-list 'ffap-alist '("\\`\\(HELP\\|SERVER\\)-[0-9]+\\'" . ffap-jira))
    )
#+end_src

** Openwith mode
#+begin_src emacs-lisp
  (use-package openwith
    :defines openwith-associations
    :commands openwith-mode
    :custom (openwith-confirm-invocation t)
    :config
    (when (eq system-type 'darwin)
      ;; On MacOS, the system tool `open' opens the target file with system
      ;; default applications. So, for most types, passing the file to `open' is
      ;; enough.x
      (setq openwith-associations '(("\\.mp4" "open" (file))
                                    )))
    :init
    (openwith-mode)
    )
#+end_src

** Webjump

This provides the functionality similar to [[file:~/mynotes/utils/apple.org::*Define Chrome site search shortcuts][Chrome site search shortcuts]].
Sometimes it can be more convenient than the later.

#+begin_src emacs-lisp
  (use-package webjump                    ; built-in package
    :bind (:map global-map ("M-g w" . webjump))
    :custom
    (webjump-sites '(("google"
                      . (concat "https://www.google.com/search?q="
                                (url-hexify-string
                                 (if (use-region-p)
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end))
                                   (thing-at-point 'word t)))))
                     ("github"
                      . (concat "https://github.com/"
                                (let ((str (completing-read
                                            "Choose GitHub option: "
                                            '("pulls/review-requested"
                                              "pulls/"
                                              "mongodb/mongo"
                                              "custom"))))
                                  (cond ((string= str "custom")
                                         (webjump-read-string "Enter custom GitHub path: "))
                                        (t str)))))
                     ("jira ticket"
                      . (concat "https://jira.mongodb.org/browse/"  (thing-at-point 'symbol t)))
                     )))
#+end_src

** Custom URLs

#+begin_src emacs-lisp
  (defun custom-urls ()
    "Attach a URL to text matching the pattern `{JIRA_PROJECT}-{NUMBER}`.
  The URL format is `https://jira.mongodb.org/browse/{JIRA_PROJECT}-{NUMBER}`."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "\\b\\(SERVER\\|CXX\\)-[0-9]+\\b" nil t)
        (let* ((ticket (match-string 0))
               (url (concat "https://jira.mongodb.org/browse/" ticket))
               (overlay (make-overlay (match-beginning 0) (match-end 0))))
          (overlay-put overlay 'mouse-face 'highlight)
          (overlay-put overlay 'help-echo url)
          (overlay-put overlay 'keymap
                       (let ((map (make-sparse-keymap)))
                         (define-key map [mouse-1]
                           `(lambda ()
                              (interactive)
                              (browse-url ,url)))
                         map))))))
#+end_src

* Sessions and histories

#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; Save mini buffer history
    (savehist-mode t)
    ;; Save cursor places between sessions
    (save-place-mode t)
    ;; Reopen files etc. when Emacs restarts
    (desktop-save-mode 1)
    ;; Automatically close buffers inactive for a long time
    (midnight-mode t)
    )

  (use-package recentf                    ; built-in package
    :defines recentf-keep
    :custom (recentf-max-saved-items 666)
    :init
    (recentf-mode 1)
    (add-to-list 'recentf-keep 'file-remote-p)
    :bind (:map global-map ("<f1>" . recentf-open))
    )
#+end_src

Note that, for =recentf= we add =file-remote-p= to the head of the
=recentf-keep= list so that remote file names are kept without connecting to the
remote server to check if these files do exist.

* Frame and window

#+begin_src emacs-lisp
  (use-package emacs
    :commands scroll-bar-mode             ; make flymake happy
    :init
    (menu-bar-mode (if (display-graphic-p) 1 -1)) ; turn it on for GUI only
    (tool-bar-mode -1)                            ; turn it off
    (when (display-graphic-p)
      (scroll-bar-mode -1)
      (add-to-list 'default-frame-alist '(fullscreen . maximized))
      )
    )

  (use-package emacs
    :custom
    (split-width-threshold 200)
    ;; Make scrolling behave more like modern applications
    ;; See: (info "(emacs) Auto Scrolling")
    (scroll-margin 0)
    (scroll-conservatively 100)
    )

  (use-package winner
    :init
    (winner-mode 1)
    ;; default key bindings: C-c <left>/<right>
    )

  (use-package transpose-frame
    ;; Do not bind any keys because the only command I use rather frequently is
    ;; `rotate-frame-clockwise' and I run it via `ace-window' dispatcher (see my
    ;; `ace-window' configuration)
    )

  (use-package ace-window
    :defines aw-dispatch-alist
    :bind (:map global-map ("M-o" . ace-window))
    :custom (aw-dispatch-always t)   ; dispatch even only two windows or less
    :config
    (add-to-list 'aw-dispatch-alist '(?t rotate-frame-clockwise))
    )

  (defun flg-toggle-window-dedicated ()
    "Toggle `set-window-dedicated-p' for the current window."
    (interactive)
    (let ((window (selected-window)))
      (set-window-dedicated-p window (not (window-dedicated-p window)))
      (message "Window %sdedicated to %s"
               (if (window-dedicated-p window) "" "no longer ")
               (buffer-name))))
#+end_src

With =ace-window= package, I feel no more need of =windmove=, =C-x 4 4= or
=lgf-tiling=. Below are Some =ace-window= hotkeys I frequently use (run =M-o ?=
to see more):
- =M-o n= :: jump back and forth between two windows.
- =M-o m= :: swap two windows.
- =M-o u= :: change the buffer of another window.
- =M-o t= :: run =rotate-frame-clockwise= (from =transpose-frame=).

** Popper

Summon and dismiss "pop-up" buffers with a single key-chord, minimize the impact
to the current window layout.

#+begin_src emacs-lisp
  (use-package popper
    :commands popper-mode popper-echo-mode popper-toggle-type
    :bind (:map global-map
                ;; C-` unavailable in some terms as it is interpreted as C-@
                ("M-`" . popper-toggle)
                ("<f8>" . popper-toggle-type)
                )
    :custom
    (popper-reference-buffers
     '("personal.gtd"
       "work.gtd"
       "\\*Copilot.*\\*"
       "\\*\\(DeepSeek\\|.*GPT.*\\|LLM response\\)\\*" ; gptel
       "\\*maple-translate\\*"
       "\\*Python\\*"
       "\\*Org Agenda\\*"
       "\\*Flymake diagnostics for .*\\*"
       help-mode
       compilation-mode))
    :config
    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

* Fonts

Select the font for Chinese characters using =set-fontset-font=. This command
sets the fallback font when the default font doesn't support the current
character. By default, Emacs iterates all the fonts until it finds one that
supports the character.

Scale Chinese fonts so that the width of 1 Chinese char equals that of two
English chars. This list is manually maintained as the scale factors for
different fonts are determined through trial and error. Note:
- To check the font of the current character, run ~C-u C-x =~.
- To get more accurate data, compare longer lines of English/Chinese.

#+begin_src emacs-lisp
  (use-package emacs
    :if (display-graphic-p)
    :config
    (let ((preferred-font "JetBrainsMono Nerd Font Propo")
          (fallback-font "Andale Mono"))
      (set-face-attribute 'default nil :font
                          (concat (if (member preferred-font (font-family-list))
                                      preferred-font fallback-font)
                                  "-20:weight=normal")))
    (let ((zh-font "SimSong"))
      (if ;; Check the availability first to avoid error
          (member zh-font (font-family-list))
           (set-fontset-font t 'han zh-font)))

    (setq face-font-rescale-alist '(("SimSong" . 1.25)
                                    ("PingFang SC" . 1.25)
                                    ))
    )
#+end_src

* Color themes

To fully utilize color themes in text-based Emacs, make sure your terminal is
set up to support "true color". See the [[file:shell.org::*Term & color][Term & color]] section in my shell
configuration file for the details

** COMMENT Wombat

My favorite Emacs built-in dark color theme. The contrast is a little bit too
high though.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (load-theme 'wombat))
#+end_src

** Solarized gruvbox

My favorite low-contrast color theme, though I dislike the background colors in
the Magit diff buffers.
#+begin_src emacs-lisp
  (use-package solarized-theme
    :config
    (load-theme 'solarized-gruvbox-dark t))
#+end_src

** COMMENT Sanityinc tomorrow

The contrast is not very low, but I prefer its Magit diff buffers over the ones
in Solarized Gruvbox.
#+begin_src emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :config
    (load-theme 'sanityinc-tomorrow-night t))
#+end_src

* Files and directories

** Auto revert-buffer

Auto-revert a buffer when corresponding file is modified by another process.
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (global-auto-revert-mode t)
    )
#+end_src

** Backup files
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (make-backup-files t)
    (version-control 'never)
    (backup-by-copying-when-linked t)
    )
#+end_src

** Dealing with huge files
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun lgf-huge-file-hook ()
      "Open huge files with minimum features.

  Huge files (normally log files) can make Emacs sluggish or even
  freeze. This hook tells Emacs to open such files with the
  `fundamental-mode' and turn off any extra features which cannot
  handle large files. In addition, it makes the buffer read only to
  avoid accidental modifications."
      (when (> (buffer-size) (* 1024 1024 16)) ; 16 MB
        (setq buffer-read-only t)
        (buffer-disable-undo)
        (fundamental-mode)
        (which-function-mode -1)
        (if (fboundp 'highlight-parentheses-mode) (highlight-parentheses-mode -1))
        ))
    (add-hook 'find-file-hook 'lgf-huge-file-hook)
    )
#+end_src

** Update timestamps before save

#+begin_src emacs-lisp
  (use-package emacs
    :hook ((before-save . time-stamp))
  )
#+end_src

Be aware that customizing =time-stamp-pattern= globally (for example, in
=init.el=) may conflict with others configuration. I.e. if you update files from
others who use a different timestamp format, then the timestamps will not be
updated. Hence, it is recommended to set timestamp format as a file local
variable.

Below are two examples:
- =#+DATE: 2024-07-11 +1000=

  #+begin_src org :tangle no
    # -*-mode:org; coding:utf-8; time-stamp-pattern:"8/#\\+DATE:[ \t]+%Y-%02m-%02d %5z$" -*-
  #+end_src

- =Modified: Fang Lungang 2024-07-11T16:41:47+1000=

  #+begin_src org :tangle no
    # -*-mode:org;coding:utf-8;time-stamp-pattern:"8/Updated[:][ \t]*%U %Y-%02m-%02dT%02H:%02M:%02S%5z$"-*-
  #+end_src

  Note: =Updated[:]= matches =Updated:=. The reason using the former is to avoid
  the pattern itself being replaced.

** Directories
#+begin_src emacs-lisp
  (use-package dired-x                    ; built-in package
    :custom
    (dired-recursive-copies 'top)
    (dired-recursive-deletes 'top)
    (dired-guess-shell-alist-user
     '(("\\.gpg\\'" "gpg --decrypt-files")
       ;; By default use `open', which chooses the correct application On MacOS.
       ("\\.*\\'" "open")))
    ;; `dired-omit-mode' hides all dot files, like `ls'
    (dired-omit-files "\\`[.#].*")
    (dired-kill-when-opening-new-dired-buffer nil)
    )
#+end_src

** Uniquify buffer names
#+begin_src emacs-lisp
  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'post-forward)
    (uniquify-strip-common-suffix t)
    (uniquify-separator "@"))
#+end_src
If two buffers are both named "buffer_name", they will be renamed to
=buffer_name@path1= and =buffer_name@path2= respectively.

* Basic editing
** Fill

In the past, the suggestion was to limit code lines to 80 characters for optimal
printing on A4 paper or for neat screen display.

Nowadays, although larger monitors can comfortably display two buffers side by
side, each with 100 characters, there are still times we work on the build-in
smaller screens. Hence, we keep the fill column to 80.

#+begin_src emacs-lisp
(setq-default fill-column 80 comment-fill-column nil)
#+end_src

** White space
#+begin_src emacs-lisp
  (use-package emacs                      ; clean up tab, indent and whitespace
    :custom
    (tab-width 4)
    (tab-stop-list nil)                   ; stops at every `tab-width' columns
    (indent-tabs-mode nil)                ; space instead of <tab> for indentation
    :hook
    ((before-save . whitespace-cleanup))
    )
#+end_src

- No longer necessary to set ~require-final-newline~ (or
  ~mode-require-final-newline~).

** Yasnippet
#+begin_src emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    ;; Put personal/customized snippets into the first dir of `yas-snippet-dirs',
    ;; which is `~/.emacs.d/snippets' by default. NOTE: it is `yas-snippet-dirs'
    ;; NOT `yasnippet-snippets-dir'. The later is where the package
    ;; `yasnippet-snippets' stores its snippets.
    ;; TODO: cleanup duplicated/similar snippets in different directories.
    :functions yas-global-mode
    :init (yas-global-mode 1)
    )

  (use-package yasnippet-snippets
    :after yasnippet-snippets)
#+end_src

Below are some common snippets. For mode specific snippets, see the
corresponding sections.

*** timestamp
#+begin_src snippet :tangle ~/.emacs.d/snippets/fundamental-mode/timestamp :mkdirp yes
  # -*- mode: snippet -*-
  # key: ts
  # name: timestamp

  # Insert the string and comment it in a tmp buffer and the copy it into
  # the current buffer. This is to avoid the warning 'modified buffer in a
  # backquote expression'.

  # --
  `(let* ((mode major-mode))
       (with-temp-buffer
         (insert "-*- time-stamp-pattern:\"8/Updated:[ \\t]+%U %Y-%02m-%02d %5z$\" -*-\n"
          (format "Created: %s %s\n" (user-full-name) (format-time-string "%Y-%m-%d"))
          (format "Updated: %s %s\n" (user-full-name) (format-time-string "%Y-%m-%d %5z")))
         (funcall mode)
         (comment-region (point-min) (point-max))
         (buffer-string)))`
#+end_src

** Find and replace in multiple files

#+begin_src emacs-lisp
  (use-package wgrep
    :after grep
    ;; ;; Explicitly bind this default hot key to defer loading wgrep until it is
    ;; ;; needed.
    ;; :bind (:map grep-mode-map
    ;;             ("C-c C-p" . wgrep-change-to-wgrep-mode))
    )
#+end_src

1. Run =grep-find= as usual. IMPORTANT: Ensure that the command outputs both
   filenames and line numbers (normally via =-nH=).
2. In the output buffer, run =C-c C-p= to enter =wgrep= mode.
3. Edit the buffer as if it is a normal buffer.
4. Press =C-x C-s= to apply the changes.

* Spelling check: flyspell

#+begin_src emacs-lisp
  (use-package flyspell
    :delight
    :hook ((prog-mode . flyspell-prog-mode)
           (yaml-mode . flyspell-prog-mode)
           (yaml-ts-mode . flyspell-prog-mode)
           (markdown-mode . flyspell-mode)
           (git-commit-setup . flyspell-mode)
           (org-mode . flyspell-prog-mode)
           )
    )
#+end_src

* Visual aids

** Block cursor as wide as the glyph under it
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (x-stretch-cursor t))
#+end_src
Note, this works for GUI Emacs only.

** Long lines
#+begin_src emacs-lisp
  (use-package emacs
    :config
    ;; Disable line wrapping by default. Turn on `visual-line-mode' (built-in)
    ;; manually or via mode hooks if soft-wrapping is neeeded.
    (setq-default truncate-lines t)
    )
#+end_src

** Display column number in the mode line

#+begin_src emacs-lisp
(use-package emacs
  :config
  (column-number-mode t)
  )
#+end_src

** Display line numbers

No configuration is needed. Add this block just to remind myself the command name.

#+begin_src emacs-lisp
  (use-package display-line-numbers       ; built-in package
    :defer t
    :commands display-line-numbers-mode global-display-line-numbers-mode
    ;; :custom
    ;; (display-line-numbers-widen t)
    ;; (display-line-numbers-major-tick 50)
    ;; (display-line-numbers-minor-tick 10)
    )
#+end_src

** Clean up mode line

*** Tool to remove minor mode lighter texts

#+begin_src emacs-lisp
  (use-package delight
    :ensure t
    :commands delight
    :config
    ;; delight built-in modes here.
    (delight '((subword-mode nil "subword") (global-subword-mode nil "subword")
               (superword-mode nil "subword") (global-superword-mode nil "subword")
               (eldoc-mode nil "eldoc")
               (hi-lock-mode nil "hi-lock")
               (hs-minor-mode nil "hideshow")
               ))
    )
#+end_src

*** Remove control (vc) info from the mode line

This info can take a lot of space (when the branch is long) and outdated (when
the file version change but the file is not re-opened).

Delete it from the mode line to make room for more useful information, say
"which-function-mode".

#+begin_src emacs-lisp
  (setq-default mode-line-format (delete '(vc-mode vc-mode) mode-line-format))
#+end_src

** Highlight whitespace

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (whitespace-line-column nil)          ; nil => use the value of `fill-column'
    (whitespace-style '(face
                        trailing
                        tabs
                        indentation
                        space-before-tab
                        space-after-tab
                        tab-mark
                        empty
                        ;; lines-tail - too harsh on eyes: highlights all the
                        ;; characters beyond the threshold can be harsh on eyes
                        ;; when the code has a lot of long lines.

                        ;; line-char - cannot highlight space: highlights the
                        ;; characters on the fill column only. If it happens to a
                        ;; be space, then no highlight.
                        ))

    :init
    ;; Do NOT turn `whitespace-mode' on globally. Because: a) in many situations,
    ;; like when using ediff or reading existing code, whitespace is expected but
    ;; may considered problem by `whitespace-mode'. b) Anyways whitespace issues
    ;; are fixed automatically because we add `whitespace-cleanup' (in a different
    ;; configuration section) to the before save hook.
    (global-whitespace-mode -1)
    )
#+end_src

** Show fill column indicator

#+begin_src emacs-lisp
  (use-package display-fill-column-indicator-mode ; built-in package
    :delight
    :defer t
    :commands (global-display-fill-column-indicator-mode
               display-fill-column-indicator-mode)
    :defines (display-fill-column-indicator-character
              display-fill-column-indicator-column)
    :custom (display-fill-column-indicator-column 100)
    )
#+end_src

** Highlight indentation levels

This package has been working well. The only downside is that the face may
require manual adjustment when changing color themes.

Another popular package is =highlight-indent-guides=. I didn't chose it because
it does not provide the equivalent of
=highlight-indentation-current-column-mode=.

#+begin_src emacs-lisp
  (use-package highlight-indentation
    :delight
    (highlight-indentation-current-column-mode)
    (highlight-indentation-mode)

    :custom
    ;; Disable highlight-indentation-blank-lines, as it prevents `C-a' from going
    ;; to the beginning of blank lines and causes some other issues.
    (highlight-indentation-blank-lines nil)

    :config
    ;; manually set the face to a color which suits most dark themes
    (set-face-background 'highlight-indentation-current-column-face "gray20")

    :hook (((python-mode python-ts-mode) . highlight-indentation-current-column-mode)
           ((yaml-mode yaml-ts-mode) . highlight-indentation-current-column-mode)
           ((sh-mode bash-ts-mode) . highlight-indentation-current-column-mode)
           )
    )
#+end_src

** Highlight matching parenthesis

#+begin_src emacs-lisp
  (use-package highlight-parentheses
    :delight
    :commands global-highlight-parentheses-mode
    :init (global-highlight-parentheses-mode t)
    ;; :custom (hl-paren-colors    ; `M-x list-colors-display' to see named colors
    ;;          '("brown" "orange" "yellow" "forest green" "cyan" "blue" "violet"))
    )
#+end_src

** Highlight current line

Normally unnecessary, add this section just to remind myself the command names
in case they are needed.
#+begin_src emacs-lisp
  (use-package hl-line                    ; built-in
    :defer t
    :commands global-hl-line-mode hl-line-mode
    )
#+end_src

NOTE: this package, along with similar ones such as beacon, only updates the
*active* window. This means that if an action is performed in the current window
that moves the cursor in another window, the visual indicator of the current
line of the other window (inactive) will not be updated until you switch to it.

** Hide show minor mode
#+begin_src emacs-lisp
  (use-package hideshow
    :ensure nil                           ; built-in
    :delight
    :commands (hs-show-block hs-hide-level)
    :custom
    (hs-allow-nesting t)
    (hs-isearch-open t)
    :config
    (defun lgfang-toggle-level ()
      "hide/show the next level"
      (interactive) (hs-show-block) (hs-hide-level 1))
    )
#+end_src

** Focus mode
#+begin_src emacs-lisp
  (use-package focus
    :defines focus-mode-to-thing
    :config
    (add-to-list 'focus-mode-to-thing '(python-ts-mode . py-thing))
    )
#+end_src

** Minimap

#+begin_src emacs-lisp
  (use-package minimap
    :defer t                         ; Just an eye candy which I almost never use.
    :custom (minimap-window-location 'right)
  )
#+end_src

* Finance bookkeeping
#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode "\\.ledger\\'"
    :defines ledger-mode-map
    :bind
    (:map ledger-mode-map
          ("C-c ." . (lambda() (interactive)
                       (insert (format-time-string "%Y-%m-%d"))))
          ("S-<right>" . ledger-date-up)
          ("S-<left>" . ledger-date-down))
    :custom
    (ledger-report-use-strict t)
    (ledger-reconcile-default-commodity "AUD")
    )
#+end_src

** Snippets for ledger mode

#+begin_src snippet :tangle ~/.emacs.d/snippets/ledger-mode/council-rate :mkdirp yes
  # -*- mode: snippet -*-
  # key: council
  # name: Council rate
  # --
  `(format-time-string "%Y-%m-%d"))` * Council
      Expenses:House${1:A}:Fee         ${2:888}.${3:00} AUD
      Assets:Cash:${4:BankX}
#+end_src

* Encryption and credential management

** COMMENT Encrypt files with passwords: ccrypt

Automatically encrypt/decrypt =.cpt= files using =ccrypt=.

#+begin_src emacs-lisp
  (use-package ps-ccrypt
    :load-path my-downloads
    ;; remember to "brew install ccrypt".
    )
#+end_src

Note: while this one is simple and straightforward, I've switched to GPG, which
might appear to be complicated at the first glance but is actually more
convenient (due to gpg agent) and more secure.

** Encrypt files using keys: GnuPG

Emacs automatically encrypts/decrypts =.gpg= files using GnuPG out of box,
needing NO additional configuration.

However, GnuPG must be install and configured properly. For MacOS, follow these
steps:
1. =brew install gpg=
2. =brew install pinentry-mac=
   * By default, =gpg= comes with =pinentry= which does not work well with GUI
     Emacs.
3. =echo "pinentry-program /opt/homebrew/bin/pinentry-mac" > ~/.gnupg/gpg-agent.conf=
   * Update =gpg-agent= configuration to use =pinentry-mac= instead of =pinentry=.
4. =killall gpg-agent=
   * Ensure the new gpg agent configuration takes effect.
5. Create/import gpg keys.
   * IMPORTANT: remember to export and backup keys.

*** Why

I prefer keys (this) than passwords (i.e. ccrypt) for the use case of protecting
a number of local files on my laptop.

- Pros:

  + Easier to change the password: instead of re-encrypt all the files using the
    new password, you only need to re-encrypt the key file.

  + Enables network backup: it is rather safe to backup your data to network so
    long as you *do not upload the key file as well*.

  + Easier to dispose data: similarly, dispose your device is safer as
    deleting/overwriting the key file ensure the data is not accessible even if
    the disk isn't properly formatted.

  + Encrypting new files/data does not require password: encrypt is done using
    the public key.

  + Enables others to encrypt and send data to you online.

  + Can attach comments and notations to keys as reminders of the theirs
    usages/passphrases.

- Cons:
  - One extra thing (the keys) to maintain. Must remember to backup and update
    when a key is edited (say changed passphrase).
  - =gpg= does not support in place file encryption as =ccrypt= does.

*** Manage gpg keys (outside Emacs)

- Show existing: =gpg --list-keys=
- Generate: =gpg --full-gen-key=, then follow the screen prompts.
  #+begin_src text
    $ gpg --full-generate-key
    gpg (GnuPG) 2.4.5; Copyright (C) 2024 g10 Code GmbH
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.

    Please select what kind of key you want:
       (1) RSA and RSA
       (2) DSA and Elgamal
       (3) DSA (sign only)
       (4) RSA (sign only)
       (9) ECC (sign and encrypt) *default*
      (10) ECC (sign only)
      (14) Existing key from card
    Your selection? 1
    RSA keys may be between 1024 and 4096 bits long.
    What keysize do you want? (3072) 4096
    Requested keysize is 4096 bits
    Please specify how long the key should be valid.
             0 = key does not expire
          <n>  = key expires in n days
          <n>w = key expires in n weeks
          <n>m = key expires in n months
          <n>y = key expires in n years
    Key is valid for? (0) 0
    Key does not expire at all
    Is this correct? (y/N) y

    GnuPG needs to construct a user ID to identify your key.

    Real name: Fang lu***
    Email address: fang.lu***@gmail
    Comment: easy
    You selected this USER-ID:
        "Fang lu*** (easy) <fang.lu**@gmail>"

    Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
    ...
    public and secret key created and signed.

    pub   rsa4096 2024-06-05 [SC]
          1EAE54292D6D1495679106947AF7AA621A22738C
    uid                      Fang lu*** (easy) <fang.lu***@gmail>
    sub   rsa4096 2024-06-05 [E]
  #+end_src
- Change passphrase: =gpg --edit-key "easy" passwd=
- Export: =gpg --armor --export-secret-keys > my-keys.asc=
- Import: =gpg --import my-keys.asc=, *then edit trust*

*** Create, read, write gpg files in Emacs

To create a such file:
1. Switch to a *non-existent* buffer "test.txt.gpg".
2. Type something or insert a file/buffer into this buffer.
3. Try save, you'll be prompted to select a key.
   1. Move cursor to the designated key.
   2. Press "m" to mark
   3. Move cursor to "OK" and enter.

Later on, when Emacs opens this file, it will automatically encrypt/decrypt the
file. You only need to provide the passphrase when prompted.

P.S. To encrypt multiple files in command line:
#+begin_src bash
gpg -r easy --encrypt-files file1 file2
#+end_src

*** Encrypt region

- =M-x epa-encrypt-region=
- =M-x epa-decrypt-region=

IMPORTANT: Avoid embedding encrypt regions in files without version control, as
accidental changes are hard to detect and changing a single character can render
the entire region unreadable.

*** Cache passphrase

By default, a gpg agent is started. Hence you needn't type in password every
time a password is needed.

** Store credentials: auth source

#+begin_src emacs-lisp
  (use-package auth-source                ; built-in
    :defer t
    :custom
    (auth-sources '("~/.authinfo.gpg" "~/my-another-authinfo.gpg"))
    ;; I manually run `auth-source-search' for certain passwords. Do not
    ;; attemp to retrieve passwords automatically
    (auth-source-protocols '())
    )
#+end_src

This allows you to store multiple credentials in a few files and query them
easily.

*** Example auth info file (gpg encrypted)
#+begin_src authinfo
  machine atlas login api_pub_key password api-private-key-xxx
  machine some_host login username password pa$$w0rd
#+end_src

*** Retrieve and use credentials
Below is an example of how to do that in an org file (with org-babel).

NOTE: We must =(funcall secret)= to get the actual secret string.

#+begin_src org
  ,#+name: my-token
  ,#+begin_src emacs-lisp
    (let* ((credential (car (auth-source-search :host "atlas")))
           (user (plist-get credential :user))
           (secret (plist-get credential :secret))
           )
      (format "%s:%s" user (funcall secret)))
  ,#+end_src

  ,#+begin_src bash :results raw :var token=my-token()
    echo "$token"
  ,#+end_src
#+end_src

** References
- blog: [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Keeping Secrets in Emacs with GnuPG and Auth Sources]]
- youtube: [[https://www.youtube.com/watch?v=nZ_T7Q49B8Y][How to Encrypt Your Passwords with Emacs]]

* IRC

This section is for record only, no configuration is tangled into the actual configuration file.

I started with ERC, then switched to RCIRC, which appeared to be easier to set up.

I attempted to use them as Slack clients, but the experience was suboptimal, so I stopped using
them.

** ERC                                                             :obsolete:

#+begin_src emacs-lisp :tangle no
(require 'erc)
(add-to-list 'erc-modules 'notifications)
(setq erc-auto-query 'buffer
      erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                "324" "329" "332" "333" "353" "477"))

(defun my-slack ()
  "Join join slack team of company."
  (interactive)
  ;; All confidential information defined in another file
  (erc-tls :server slack-server
           :port slack-port
           :nick slack-nick
           :password slack-pass
           ))
#+end_src

** RCIRC                                                           :obsolete:

#+begin_src emacs-lisp :tangle no
  ;; All confidential information defined in another file
  (setq rcirc-server-alist `((,slack-server
                              :port ,slack-port
                              :encryption tls
                              :nick ,slack-nick
                              :password ,(concat slack-pass "-no_mpdm_greet")
                              :channels ("#tse-notifications"))
                             ("irc.freenode.net"
                              :channels ("#emacs" "#rcirc" "#mongodb"))
                             )
        ;; register nick name: https://freenode.net/kb/answer/registration
        rcirc-authinfo `(("freenode" nickserv ,my-net-id ,my-pub-passwd))
        rcirc-omit-responses '("JOIN" "PART" "QUIT" "NICK" "AWAY")
        ;; rcirc-nick-completion-format "@%s"
        rcirc-fill-flag nil
        rcirc-default-nick my-net-id)

  (add-hook 'rcirc-mode-hook
            (lambda ()
              (rcirc-track-minor-mode 1)
              (flyspell-mode 1)))
#+end_src

* News groups and emails - gnus                                    :obsolete:

In my previous job, I used Gnus to read newsgroups (mainly internal) and occasionally emails. When
the company decommissioned the NNTP servers, I stopped using Gnus.

Corresponding configuration files are in my Emacs notes directory for record only.

* Kubernetes
#+begin_src emacs-lisp
  (use-package kubel
    :defer t
    )
#+end_src

The packages works with limited privileges. Frequently used hotkeys
- R :: choose resource
- s :: set label selector
- ? :: help (dispatch list)

* Org mode

** Agenda

#+begin_src emacs-lisp
  (use-package org-agenda
    :bind (:map global-map ("C-x c a" . org-agenda))
    :custom (org-agenda-use-time-grid nil)
  )
#+end_src

Turn off time grid as the grid lines between clocked items are annoying. An
alternative is to set =remove-match= as shown below. However, this can be
misleading as people typically expect equal intervals between grid lines.
Therefore, I chose to disable the time grid.
#+begin_src emacs-lisp :tangle no
  (setq org-agenda-time-grid
        '(((daily today remove-match)
           (800 1000 1200 1400 1600 1800 2000)
           "......" "----------------"))))
#+end_src

** Babel

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-ditaa-jar-path (concat my-downloads "ditaa.jar"))
    (org-plantuml-jar-path (concat my-downloads "plantuml.jar"))
    (org-babel-load-languages '((emacs-lisp . t)
                                (shell . t)
                                (ditaa . t)
                                (plantuml . t)
                                (dot . t)
                                ))
    (org-confirm-babel-evaluate
     (lambda (lang &rest _)
       "Don't ask for confirmation when evaluating ditaa, plantuml, or dot code blocks."
      (not (member lang '("ditaa" "plantuml" "dot")))))
    )
#+end_src

*** Automatically tangle configurations

To ensure that the corresponding configuration files are updated every time I
modify this configuration file, add a =after-save-hook= to org-mode: when the
buffer file is my configuration file, tangle it. Otherwise, do nothing.

#+begin_src emacs-lisp
  (use-package emacs
    :commands org-babel-tangle
    :config
    (defvar my-config-org-files (mapcar #'expand-file-name
                                        '("~/.dotfiles/emacs.org"
                                          "~/.dotfiles/tmux.org"
                                          "~/.dotfiles/git.org"
                                          "~/.dotfiles/shell.org"
                                          "~/.dotfiles/window-manager.org"
                                          "~/.dotfiles/terminal-emulator.org"
                                          "~/.dotfiles/karabiner.org"
                                          )))
    (defun lgf-tangle-configs ()
      (add-hook 'after-save-hook
                (lambda()
                  (when (member (buffer-file-name) my-config-org-files)
                    (setq-local org-confirm-babel-evaluate nil)
                    (org-babel-tangle)))
                nil t))

    :hook ((org-mode . lgf-tangle-configs))
    )
#+end_src

*Note*:
- Remember to adjust =my-config-org-file= to point to your configuration file.

** Clock
#+begin_src emacs-lisp
  (use-package org-clock
    :bind (:map global-map
                ("<f9>"   . org-clock-in-last)
                ("S-<f9>" . org-clock-out))
    :custom
    (org-clock-heading-function
     (lambda ()
       (let* ((limit 2)                  ; show at most "limit" words in mode line
              (heading (org-get-heading t t t t))
              (words (split-string heading "[ \t]+" t)))
         (concat (string-join (seq-take words limit) " ")
                 (when (> (length words) limit) "...")))))
    )
#+end_src

** Getting Things Done (GTD)
#+begin_src emacs-lisp
  (use-package org-capture
    :bind (:map global-map
                ("<f10>" . org-capture))
    )
#+end_src

** Links

The keybindings below are *not* tangled into the configuration file because they
either:
- Address less frequently used functionalities, or
- Duplicate existing default keybindings.
#+begin_src emacs-lisp :tangle no
  (use-package org
    :ensure nil ; Org is built-in, so we don't need package.el to try and install it.
    :bind (;; `global-map' by default by :bind
           ("C-x c l" . org-store-link)
           ("C-x c o" . org-open-at-point-global)
           :map org-mode-map
           ("C-c C-l" . org-insert-link)
           ("C-c C-o" . org-open-at-point)
           )))
#+end_src

** Repeat map

#+begin_src emacs-lisp
  (use-package org
    :bind (:repeat-map my-org-repeat-map
                       ("C-n" . org-next-visible-heading)
                       ("C-p" . org-previous-visible-heading)
                       ("C-b" . org-backward-heading-same-level)
                       ("C-f" . org-forward-heading-same-level)
                       )
    )
#+end_src

** Structure templates
I.e. type =<s= + =TAB= to insert =#+begin_src= etc.
#+begin_src emacs-lisp
  (use-package org-tempo
    :config
    (add-to-list 'org-structure-template-alist '("sb" . "src bash"))
    (add-to-list 'org-structure-template-alist '("sj" . "src javascript"))
    ;; yasnippet-snippets/snippets/org-mode/style uses "<st" as well, which
    ;; overrides the one below. Modify that to "<sty" and then 'yas-reload-all"
    (add-to-list 'org-structure-template-alist '("st" . "src text"))
    (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
    )
#+end_src

* PDF

#+begin_src emacs-lisp
  (use-package pdf-tools
    :defer t
    :magic ("%PDF" . pdf-view-mode)
    :commands pdf-tools-install
    :config
    (pdf-tools-install)
    )
#+end_src

* EPUB
#+begin_src emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode)
  )
#+end_src

** Garbled text in Chinese books
According to [[https://emacs-china.org/t/emacs-epub/4713][this post in emacs-china]], the root cause is that these files do not
follow the standard, causing =nov= to handle UTF characters incorrectly.

The following workaround worked for me (at least for some books):
#+begin_src emacs-lisp
(with-no-warnings
    (defun my-nov-content-unique-identifier (content)
      "Return the the unique identifier for CONTENT."
      (when-let* ((name (nov-content-unique-identifier-name content))
                  (selector (format "package>metadata>identifier[id='%s']"
                                    (regexp-quote name)))
                  (id (car (esxml-node-children (esxml-query selector content)))))
        (intern id)))
    (advice-add #'nov-content-unique-identifier :override #'my-nov-content-unique-identifier))
#+end_src

** COMMENT EPUB 3 ID not found
Also from [[https://emacs-china.org/t/emacs-epub/4713][this post in emacs-china]], this is caused by epub2 books mistaken
identify them as epub3 ones.

Below is the workaround. Do not tangle this because I haven't hit issues and
hence haven't verified it yet.
#+begin_src emacs-lisp
(defun nov--content-epub2-files (content manifest files)
    (let* ((node (esxml-query "package>spine[toc]" content))
           (id (esxml-node-attribute 'toc node)))
      (when (not id)
        (throw 'error "EPUB 2 NCX ID not found"))
      (setq nov-toc-id (intern id))
      (let ((toc-file (assq nov-toc-id manifest)))
        (when (not toc-file)
          (throw 'error "EPUB 2 NCX file not found"))
        (cons toc-file files))))

  (defun nov--content-epub3-files (content manifest files)
    (let* ((node (esxml-query "package>manifest>item[properties~=nav]" content))
           (id (esxml-node-attribute 'id node)))
      (when (not id)
        (throw 'error "EPUB 3 <nav> ID not found"))
      (setq nov-toc-id (intern id))
      (let ((toc-file (assq nov-toc-id manifest)))
        (when (not toc-file)
          (throw 'error "EPUB 3 <nav> file not found"))
        (setq files (--remove (eq (car it) nov-toc-id) files))
        (cons toc-file files))))

  (defun nov-content-files (directory content)
    "Create correctly ordered file alist for CONTENT in DIRECTORY.
Each alist item consists of the identifier and full path."
    (let* ((manifest (nov-content-manifest directory content))
           (spine (nov-content-spine content))
           (files (mapcar (lambda (item) (assq item manifest)) spine)))
      (catch 'error (nov--content-epub3-files content manifest files))
      (catch 'error (nov--content-epub2-files content manifest files))))
#+end_src
* Terminal/shell
** vterm
#+begin_src emacs-lisp
  (use-package vterm
    :defer t
    )
#+end_src

Why:
- Integrated window/pane management & navigation
- Consistent color themes

Frequently used key bindings
- =C-c C-t= : toggle =copy-mode= (move around and copy in the vterm buffer).
- =C-c C-c= : send =C-c= to the term

Emacs as a terminal multiplexer:
1. Start Emacs daemon.
2. Run vterm (=M-x vterm=) in emacs clients.

** eshell

*** Customize prompt

Currently, there are no elaborate decorations. The primary changes are adding
the time and placing the path and dollar sign on separate lines.

#+begin_src emacs-lisp
  (use-package eshell
    :defer t
    :custom (eshell-prompt-function
             (lambda ()
               (concat
                (propertize "╭ " 'face `(:foreground "green"))
                (propertize (format-time-string "%H:%M " (current-time)) 'face `(:foreground "yellow"))
                (propertize (user-login-name) 'face `(:foreground "green"))
                (propertize "@" 'face `(:foreground "green"))
                (propertize (system-name) 'face `(:foreground "green"))
                (propertize "\n│ " 'face `(:foreground "green"))
                (propertize (concat (eshell/pwd)) 'face `(:foreground "green"))
                (propertize "\n╰ " 'face `(:foreground "green"))
                (propertize (if (= (user-uid) 0) "# " "$ ") 'face `(:foreground "green"))
                )))
    )
#+end_src

*** Customize aliases and commands
#+begin_src emacs-lisp
  (defun eshell/ep ()
    "In eshell, `ep' to go to the path of the previous buffer."
    (cd (with-current-buffer (other-buffer) default-directory)))

  (defun eshell/vi (&rest args)
    "Invoke `find-file' according to ARGS.
  `vi +66 foo` opens the file `foo` and goes to line 66 in the buffer."
    (while args
      (if (string-match "\\`\\+\\([0-9]+\\)\\'" (car args))
          (let* ((target-line (string-to-number (match-string 1 (pop args))))
                 (file (pop args)))
            (find-file file)
            (forward-line (- target-line (line-number-at-pos))))
        (find-file (pop args)))))
#+end_src

*** multiple eshell

To create an additional eshell buffer, run =C-u M-x eshell=.

* Utilities

** ASCII values

- To get the ASCII value of certain character
  + Move the cursor to it and then run ~C-x =~. The ASCII values in base 10, 8, 16
    are shown in the mini buffer as show below:
    #+begin_src text
      Char: a (97, #o141, #x61) ...
    #+end_src
  + Alternatively, put a question mark before the character and evaluate that
    expression (~C-x C-e~).
    #+begin_src text
      ?a ==> 97 (#o141, #x61, ?a)
    #+end_src

- To insert a character using its ASCII value, use the ~insert~ function
  #+begin_src text
    (insert 97)
    (insert #o141)
    (insert #x61)
  #+end_src

- Display the ASCII table in a dedicated buffer.
  #+begin_src emacs-lisp
    (use-package ascii-table
      :defer t
      :commands ascii-table
      :custom (ascii-table-base 10))
  #+end_src

** Calendar

#+begin_src emacs-lisp
  (use-package calendar
    :ensure nil                           ; built-in
    :defer t
    ;; add defines and commands to make compiler happy
    :defines displayed-month displayed-year
    :commands calendar-day-of-week
    :config
    (require 'holidays)
    (require 'cal-china-x nil t)
    )

  (use-package holidays
    :ensure nil                           ; built-in
    :defer t
    :config
    (defun holiday-new-year-bank-holiday ()
      "This & next copied from https://emacs.stackexchange.com/a/45352/9670"
      (let ((m displayed-month) (y displayed-year))
        (calendar-increment-month m y 1)
        (when (<= m 3)
          (let ((d (calendar-day-of-week (list 1 1 y))))
            (cond ((= d 6)
                   (list (list (list 1 3 y)
                               "NSW: New Year's Day (day in lieu)")))
                  ((= d 0)
                   (list (list (list 1 2 y)
                               "NSW: New Year's Day (day in lieu)"))))))))

    (defun holiday-christmas-bank-holidays ()
      (let ((m displayed-month) (y displayed-year))
        (calendar-increment-month m y -1)
        (when (>= m 10)
          (let ((d (calendar-day-of-week (list 12 25 y))))
            (cond ((= d 5)
                   (list (list (list 12 28 y)
                               "NSW: Boxing Day (day in lieu)")))
                  ((= d 6)
                   (list (list (list 12 27 y)
                               "NSW: Boxing Day (day in lieu)")
                         (list (list 12 28 y)
                               "NSW: Christmas Day (day in lieu)")))
                  ((= d 0)
                   (list (list (list 12 27 y)
                               "NSW: Christmas Day (day in lieu)"))))))))

    (setq calendar-mark-holidays-flag t)
    (let ((holiday-nsw-holidays '((holiday-fixed 1 1 "NSW: New Year's Day")
                                  (holiday-new-year-bank-holiday)
                                  (holiday-fixed 1 26 "NSW: Austrlia Day")
                                  (holiday-easter-etc -2 "NSW: Good Friday")
                                  (holiday-easter-etc -1 "NSW: Easter Saturday")
                                  (holiday-easter-etc 0 "NSW: Easter Sunday")
                                  (holiday-easter-etc 1 "NSW: Easter Monday")
                                  (holiday-fixed 4 25 "NSW: Anzac Day")
                                  (holiday-float 6 1 2 "NSW: Queen's Birthday")
                                  (holiday-float 10 1 1 "NSW: Labour Day")
                                  (holiday-fixed 12 25 "NSW: Christmas Day")
                                  (holiday-fixed 12 26 "NSW: Boxing Day")
                                  (holiday-christmas-bank-holidays)))
          (holiday-other-holidays '((holiday-fixed 10 31 "Halloween"))))
      (setq calendar-holidays (append holiday-nsw-holidays
                                      holiday-other-holidays)))
    )
#+end_src

*** Chinese calendar and holidays
#+begin_src emacs-lisp
  (use-package cal-china-x
    :defer t
    :defines cal-china-x-chinese-holidays
    :config
    (setq calendar-holidays (append calendar-holidays
                                    cal-china-x-chinese-holidays
                                    '((holiday-lunar 1 15 "元宵节"))
                                    ))
    )
#+end_src

** Dictionary and translation

Firstly, clone the package into the =my-downloads= directory:
#+begin_src bash
git clone https://github.com/honmaple/emacs-maple-translate ~/.emacs.d/downloads/emacs-maple-translate
#+end_src

#+begin_src emacs-lisp
  (use-package maple-translate
    :load-path (lambda() (concat my-downloads "emacs-maple-translate"))
    :commands (maple-translate maple-translate+)
    :custom (maple-translate-engine 'youdao)
    :bind (:map global-map
                ("C-h D" . maple-translate)
                ("C-h d" . maple-translate+))
    )
#+end_src

I no longer use =scdv= despite its offline capability due the difficulty in
finding and downloading dictionaries.

Using =webjump= to navigate to =dict.cn= etc. with the selected text or word at
point is another alternative. However, it is less inconvenient as it requires
closing the web browser tab and refocusing on Emacs.

** COMMENT Man pages
Nowadays the default "man" is already very convenient, no need of woman any
more.
#+begin_src emacs-lisp
  (use-package woman
    :custom
    (woman-use-own-frame nil)
    (woman-fill-frame t))
#+end_src
** Speed type
#+begin_src emacs-lisp
  (use-package speed-type
    :commands speed-type-region speed-type-text
    )
#+end_src

To improve typing speed, install =speed-type= and then use =speed-type-text= to
practice with random text snippets from the Gutenburg Project or
=speed-type-region= for the active region.

To avoid get boredom, I sometimes use =eww= to open a news page and then
=speed-type-region= it.

** Spelling alphabet

This is useful when you need to explain how to spell something over phone calls.
- Type in the word and =nato-region= it, then read it out. Or,
- =C-h v nato-alphabet= to list the alphabet in the HELP buffer and refer to it.

#+begin_src emacs-lisp
  (use-package morse                      ; built in
    ;; Nothing to customize, just list the commands etc. as a reminder
    :commands nato-region denato-region morse-region unmorse-region
    :defines nato-alphabet morse-code
    )
#+end_src

** Weather
#+begin_src emacs-lisp
  (use-package wttrin
    :defer t
    :defines wttrin-default-locations
    :custom
    (wttrin-default-locations '("Sydney, NSW"))
    (wttrin-font-name 'monaco)            ; for GUI Emacs only
    )
#+end_src

** World clock
#+begin_src emacs-lisp
  (use-package time                       ; built-in package
    ;; use `M-x world-clock' to display
    :custom
    (world-clock-time-format "%R %a %b\t%d %Z\t%z")
    (world-clock-list '(("UTC" "UTC")
                        ("Australia/Sydney" "Sydney")
                        ("America/New_York" "New York")
                        ("America/Chicago" "Chicago")
                        ("America/Los_Angeles" "Palo Alto")
                        ("Asia/Shanghai" "Beijing")
                        ("Asia/Kolkata" "Delhi")
                        ("Asia/Tel_Aviv" "Tel Aviv")
                        ("Europe/London" "Dublin")))
    )
#+end_src

* IDE

** Treemacs

#+begin_src emacs-lisp
  (use-package treemacs
    :defer t                    ; Only load it when I need it, as I rarely use it.
    )
#+end_src
Instead of using projectile etc., we can manually edit =treemacs-persist-file=
to add projects we need. Below is an example:
#+begin_src org
  ,* Default
  ,** My .dotfiles
   - path :: ~/.dotfiles
  ,** structure log mode
   - path :: ~/projects/emacs/structured-log-mode
#+end_src

** Completion: company

#+begin_src emacs-lisp
  (use-package company
    :delight
    :functions global-company-mode
    :init (global-company-mode)
    )
#+end_src

** Syntax check: flymake

#+begin_src emacs-lisp
  (use-package flymake
    ;; To jump to flymake diagnostics, use `consult-flymake'. To see the checkers
    ;; being used, check the buffer local var `flymake-diagnostic-functions'.
    ;; Sometimes it may be handy to list all the diagnostics in a buffer, this can
    ;; be done using `flymake-show-buffer-diagnostics' or
    ;; `flymake-show-project-diagnostics'.

    :bind (:map flymake-mode-map
                ("C-c p" . flymake-goto-prev-error)
                ("C-c n" . flymake-goto-next-error))

    :hook (prog-mode yaml-ts-mode)

    :config
    ;; Do not highlight flymake warnings due to the current high frequency of
    ;; warnings in our codebase. Instead, monitor the numbers of flymake
    ;; errors/warning/info in the mode line.
    (set-face-attribute 'flymake-warning nil :inherit nil)
  )
#+end_src

** Syntax parser: tree-sitter

#+begin_src emacs-lisp
  (use-package treesit
    ;; Remember to run `treesit-install-language-grammar' to install the grammar
    ;; for each designated language.
    :when
    (and (fboundp 'treesit-available-p) (treesit-available-p))

    :custom
    (major-mode-remap-alist
     '(
       (sh-mode . bash-ts-mode)
       (c++-mode . c++-ts-mode)
       (c-mode . c-ts-mode)
       (cmake-mode . cmake-ts-mode)
       (conf-toml-mode . toml-ts-mode)
       (js-json-mode . json-ts-mode)
       (python-mode . python-ts-mode)
       (yaml-mode . yaml-ts-mode)
       ))

    :functions py-thing

    :defines flg-up-level-thing-alist

    :config
    ;; define `py-thing' for `thing-at-point' so that the `focus-mode' can focus
    ;; on such python things.
    (defvar py-thing--thing nil
      "Store the thing at point. `thing-at-point' moves to the end of
  the thing first. We should not re-run `py-thing' after that."
      )

    (defvar py-things-to-focus
      '("class_definition"
        "function_definition"
        "try_statement"
        "except_clause"
        "if_statement"
        "else_clause"
        "for_statement"
        "while_statement"
        "module")
      "Node types considered as python thing.")

    (defun py-thing ()
      (treesit-parent-until
       (treesit-node-at (point))
       (lambda (parent) (member (treesit-node-type parent) py-things-to-focus))))

    (defun py-thing-begin ()
      (when-let ((thing (or py-thing--thing (py-thing))))
        (goto-char (treesit-node-start thing))))

    (defun py-thing-end ()
      (when-let ((thing (py-thing)))
        (setq py-thing--thing thing)
        (goto-char (treesit-node-end thing))))

    (put 'py-thing 'beginning-op 'py-thing-begin)
    (put 'py-thing 'end-op 'py-thing-end)

    (defcustom flg-up-level-thing-alist '((python-ts-mode . py-thing)
                                          (prog-mode . defun)
                                          (org-mode . org-element))
      "Used by `one-level-up` to determine thing at point."
      :type 'alist
      :group 'fanglungang
      )

    (defun up-level ()
      "Move point to the beginning of the parent of the thing at point."
      (interactive)
      (let* ((thing (or (cdr (assoc major-mode flg-up-level-thing-alist)) 'defun)))
        (goto-char (car (bounds-of-thing-at-point thing)))
        (forward-line -1)
        (goto-char (car (bounds-of-thing-at-point thing)))))

    )
#+end_src

** Code Formatter

Below are two general code formatter packages. For language-specific formatter
settings, refer to the corresponding programming language section.

*** reformatter

This package itself does not format code itself but provides functions necessary
to implement an formatter. It is required by tools =ruff-format= etc.

#+begin_src emacs-lisp
  (use-package reformatter
    :delight
    )
#+end_src

*** Prettier

This package formats JSON, YAML, and other file types.

NOTE:
- It is advisable to adhere to the default format settings as Prettier aims to
  standardize formatting and minimize disputes over style.
- To stop =yamllint= from complaining "too many spaces inside braces" for legacy
  code, add =bracketSpacing: false= to your =.prettierrc= temporarily.

1. *Globally* install the package (=-g=): =npm install -g prettier=.

2. Verify that =prettier= works, for example:
   #+begin_src bash
     npx prettier test.yml
   #+end_src

3. Hook prettier in Emacs
   #+begin_src emacs-lisp
     (use-package prettier
       :delight
       ;; Format json, yaml, markdown etc.;
       :hook (yaml-mode yaml-ts-mode)
       )
   #+end_src

**** COMMENT For shell scripts

Note: I'm using shfmt instead of this at the moment.

This does not work as Prettier is unable to find globally installed
plugins. Installing Prettier and the plugin locally and launching Emacs from the
same directory works; however, this approach is not ideal due to the
restriction of having to start Emacs from that specific directory.

- *Globally* install [[https://github.com/un-ts/prettier/tree/master/packages/sh][the shell script plugin]]
  #+begin_src bash
    npm install -g prettier-plugin-sh
  #+end_src
- Enable the plugin in =~/.prettierrc=:
  #+begin_src json
    {
      "plugins": ["prettier-plugin-sh"]
    }
  #+end_src

** Which function
#+begin_src emacs-lisp
  (use-package which-func
    :init (which-function-mode t)
    )
#+end_src

** Breadcrumb
#+begin_src emacs-lisp
  (use-package breadcrumb
    :defer t
    :custom
    (breadcrumb-project-max-length 0.3)
    (breadcrumb-imenu-max-length 0.9)
    )
#+end_src
- Note: consider replacing =which-function= with this.

** Imenu

#+begin_src emacs-lisp
  (use-package imenu
    :custom (imenu-auto-rescan t)
    )

  (use-package imenu-list
    :after imenu
    :bind (:map global-map ("M-s i" . imenu-list ))
    )
#+end_src

** Project

This now built-in package detects the current project and provides some utility
functions used by many other packages.

#+begin_src emacs-lisp
  (use-package project
    :custom
    ;; Help `project' to correctly identify project root directories
    (project-vc-extra-root-markers '("pyproject.toml"))
    )
#+end_src

** LSP: eglot

Works very well out of box without any configuration.
#+begin_src emacs-lisp
  (use-package eglot
    :defer t
    )
#+end_src

*** Note for MacOS

If you run Eglot + Pyright on MacOS, you may want to increase the "open files"
limit (=ulimit -n=), say to 65536.

The default value is 256, which Pyright easily hits when the python project is
non-trivial. In such situations, you can see the error message by setting
=debug-on-error= to =t= and then try enable Eglot again.

** DAP: dape

#+begin_src emacs-lisp
  (use-package dape
    ;; For Python, `pip3 install debugpy'. Run adapter `debugpy' to test a
    ;; program, adapter `debugpy-module' for testing a module.
    :after eglot
    :custom (dape-buffer-window-arrangement 'right)
    :config
    ;; Save files before sessions, useful for interpreted languages, such as
    ;; python; Cannot use `:hook' since this hook name doesn't end with "-hook"
    (add-hook 'dape-on-start-hooks 'save-some-buffers)
    )
#+end_src

*** Python examples

IMPORTANT: Ensure the Python project's virtual environment is activated, if
applicable.
- Debug a unit test run by =pytest=
  #+begin_src text
    Run adapter: debugpy-module :cwd "/home/lgfang/myproject/" :module "pytest" :args ["src/tests/test_xyz.py::TestCustomBuild"]
  #+end_src
- Debug a locust run
  #+begin_src text
    Run adapter: debugpy-module :cwd "/home/lgfang/myproject/workloads/currentOp/" :module "locust" :args ["--locustfile" "./src/currentOp_workload.py" ...]
  #+end_src

** xcscope

This section is kept for reference but excluded from the actual config. The
recommended alternative is ~eglot~ + a language server (e.g., ~clangd~ for C++).
See language-specific sections for details.

#+begin_src emacs-lisp :tangle no
  (use-package xcscope
    :custom
    ;; Use `global' (brew install global) instead of `cscope'
    (cscope-program "gtags-cscope")
    ;; The default database filename of `global'
    (cscope-database-file "GTAGS")
    ;; Disable database auto-rebuild (for huge projects)
    (cscope-do-not-update-database t)
    ;; Cross-project search paths
    (cscope-database-regexps
     '(
       (
        ( "^/users/jdoe/sources/proj1"
          ( t )
          ( "/users/jdoe/sources/proj2")
          ( "/users/jdoe/sources/proj3/mycscope.out")
          ( "/users/jdoe/sources/proj4")
          t
          ( "/some/master/directory" ("-d" "-I/usr/local/include") )
          )
        ( "^/users/jdoe/sources/gnome/"
          ( "/master/gnome/database" ("-d") )
          )
        )))

    :config
    (cscope-setup)
    )
#+end_src

* AI/LLM

** gptel

#+begin_src emacs-lisp
  (use-package gptel
    :defer
    :defines gptel-mode-map
    :commands (gptel-make-gh-copilot gptel-make-deepseek gptel-make-openai auth-source-search)
    :hook ((gptel-post-stream . gptel-auto-scroll))
    :bind (:map gptel-mode-map ("C-c C-c" . gptel-send))

    :custom
    (gptel-default-mode 'org-mode)

    :config
    (gptel-make-gh-copilot "CopilotChat")

    (gptel-make-deepseek "DeepSeek"
      :stream t
      :key (lambda ()
             (require 'auth-source)
             (let ((result (auth-source-search :host "deepseek" :require '(:secret))))
               (if result
                   (funcall (plist-get (car result) :secret))
                 (error "Failed to retrieve DeepSeek API key"))))
      )
    )
#+end_src

*** DeepSeek authentication note

To authenticate with the DeepSeek API, ensure your auth source includes an entry
like this:
#+begin_src text
machine deepseek login apikey password sk-*******
#+end_src

See [[*Store credentials: auth source][Store credentials: auth source]] for more information with regards to auth
source.

*** Choose backend

I didn't find an elegant approach to register multiple backends and switch
~gptel-backend~ (the default backend) among them with one-line configuration
change. Therefore, I decided to not set ~gptel-backend~ in the configuration
file but choose the model when start to use gptel.
1. Call ~C-u M-x gptel-send~
2. In transient menu: type in ~-m~ then select the designated backend (for
   instance, "DeepSeek:deepseek-reasoner")
3. Press ~<Enter>~ to actually send prompt or ~C-g~ to cancel.

*** Chat in a dedicated buffer
1. Run =M-x gptel= to create a dedicated buffer.
2. Type your questions or input in the buffer.
3. Run =M-x gptel-send= to send the text to the LLM backend.
4. Repeat steps 2 and 3 as needed.

NOTE: Unless a region is active, =gptel-send= sends all text from the
beginning of the buffer to the cursor position to maintain context. To save
costs, avoid unnecessarily long sessions.

*** Custom prompt on selected text

1. Select a snippet of text.
2. Run =C-u M-x gptel-send=
3. Optional: press =s= to set system message. (Ask AI for what is "system
   message").
4. Optional: press =d= and enter a custom instruction, say "explain this code
   snippet".
5. Optional: tweak other settings via the transient menu.
6. Press =RET= and wait for the response to complete.

*** Rewrite selected text

Rewriting selected text is a more specific type of request for selected text and
has a dedicated function: =gptel-rewrite=. This function offers slightly
simplified interactions.

1. Run =M-x gptel-rewrite= (no prefix =C-u= needed).
2. Optional: Press =s/d= to adjust settings if necessary.
3. Press =r= to send the request.
4. Wait for the server to respond.
5. Ensure the cursor is in the rewritten region, press =RET= and then choose an
   action following the screen output.

** Copilot chat

While gptel is already powerful and supports Copilot Chat, this package provides
additional convenience. For example, =M-x copilot-chat-explain= is much simpler
than manually crafting prompts with =C-u M-x gptel-send=.

#+begin_src emacs-lisp
  (use-package copilot-chat
    :commands (copilot-chat-display
               copilot-chat-custom-prompt-selection
               copilot-chat-optimize
               copilot-chat-explain
               copilot-chat-how
               )

    :defines (copilot-chat-prompt-mode-map copilot-chat-mode-map)

    :bind (:map global-map
                ("<f7>" . copilot-chat-display)
                :map copilot-chat-prompt-mode-map
                ("C-c C-c" . copilot-chat-prompt-send))

    :hook ((copilot-chat-prompt-mode copilot-chat-mode) . visual-line-mode)

    :custom
    (copilot-chat-frontend 'org)
    ;; `M-x copilot-chat-set-model` to change the value interactively.
    (copilot-chat-model "gemini-2.5-pro")

    :config
    (defun copilot-chat-how ()
      (interactive)
      (copilot-chat-custom-prompt-selection "how to "))
    )
#+end_src

*Authentication Note:* On first use, you must authenticate via a web browser.
- Local GUI Host: The browser will open automatically.
- Remote Headless Host:
  1. Ensure Emacs can open a browser successfully although we do not use that
     browser for the login flow. Typically this is done by setting the browser
     function to the built-in ~eww~.
     #+begin_src emacs-lisp :tangle no
       (setq browse-url-browser-function 'eww-browse-url)
     #+end_src
  2. Copy the authentication URL provided by Emacs.
  3. Open it in a browser on a windowing device (e.g., your local machine).
  4. Complete the login flow.

IMPORTANT: When using this for the first time, you'll be asked to authenticate
the application via a web page. On a remote host without GUI, you can
authenticate via a web browser on a different host, but the Emacs must be
configured to be able to open a web browser successfully, which can be achieved
via ~(setq browse-url-browser-function 'eww-browse-url)~

- How to ask questions (send prompts to the LLM):
  - In the dedicated buffer: press ~<f7>~ (bound to ~copilot-chat-display~) to
    go to the Copilot Chat buffer, type in your query in it and then press ~C-c
    C-c~ (~copilot-chat-prompt-send~) to send the query to the LLM server.
  - In any buffer: select the text of concern, then run =M-x
    copilot-chat-custom-prompt-selection= and type in your custom prompt and
    enter.
- An alternative configuration that use a shell CLI style front-end
  #+begin_src emacs-lisp :tangle no
    (use-package copilot-chat
       :load-path (lambda() (concat my-downloads "copilot-chat.el"))
       :custom
       (copilot-chat-frontend 'shell-maker)
       )

     (use-package copilot-chat-shell-maker
       :load-path (lambda() (concat my-downloads "copilot-chat.el"))
       :config
       (push '(shell-maker . copilot-chat-shell-maker-init) copilot-chat-frontend-list)
       )
  #+end_src

** Copilot

This is a plugin for copilot code completion.

For first time use, remember to run =M-x copilot-install-server= and =M-x
copilot-login=.

#+begin_src emacs-lisp
  (use-package copilot
    :commands copilot-mode
    :defines copilot-completion-map
    :bind (:map copilot-completion-map
                ("C-e" . copilot-accept-completion)
                ("M-f" . copilot-accept-completion-by-word)
                ("M-n" . copilot-next-completion)
                ("M-p" . copilot-previous-completion)
                )
    :custom (copilot-log-max 50000)
    ;; :hook (python-ts-mode python)
    )
#+end_src

** COMMENT Minuet

This is another code completion plugin. The following configuration uses
DeepSeek as its backend. The performance is quite slow - I'm unsure whether this
is due to my configuration or if it's inherently slow.

Firstly, add your DeepSeek API key to one of your =auth-source= files in the
following format:
#+begin_src text
  machine deepseek login apikey password your_deepseek_api_key
#+end_src
Replace =your_deepseek_api_key= with your actual API key (e.g., =sk-xxxxx=).

Then, add the following to your Emacs configuration file.
#+begin_src emacs-lisp
  (use-package minuet
    :after auth-source
    :defer t
    :defines minuet-openai-fim-compatible-options
    :functions auth-source-search minuet-set-optional-options

    :bind
    (:map global-map
          ("<f6>" . minuet-next-suggestion))

    :init                  ; use `:init` to set env *before* this module is loaded
    (let ((auth (auth-source-search :host "deepseek" :require '(:secret))))
      (if auth (setenv "DEEPSEEK_API_KEY" (funcall (plist-get (car auth) :secret)))
        (warn "DeepSeek unavailable: API key not in auth source")))

    :custom
    (minuet-provider 'openai-fim-compatible)
    (minuet-request-timeout 20)

    :config
    (minuet-set-optional-options minuet-openai-fim-compatible-options :max_tokens 256)
  )
#+end_src

* Version Control
** magit
#+begin_src emacs-lisp
  (use-package magit
    :defer t
    :bind (:map global-map ("C-x g" . magit-status))
    :custom (magit-log-margin-show-committer-date t)
    :hook
    (magit-refresh-buffer . (lambda() (when (fboundp 'custom-urls) (custom-urls))))
    )
#+end_src
** git-gutter
#+begin_src emacs-lisp
  ;; Choose this package over diff-hl because the later does not work in 'emacs
  ;; -nw'.
  (use-package git-gutter
    :delight
    :commands global-git-gutter-mode
    :custom
    (git-gutter:modified-sign " ")
    (git-gutter:added-sign " ")
    (git-gutter:deleted-sign " ")
    :init
    (global-git-gutter-mode t)
    :config
    (set-face-background 'git-gutter:modified "DarkOrange")
    (set-face-background 'git-gutter:added "green")
    (set-face-background 'git-gutter:deleted "red")
    :bind (:map global-map
                ("C-x v [" . git-gutter:previous-hunk)
                ("C-x v ]" . git-gutter:next-hunk)
                ("C-x v =" . git-gutter:popup-hunk)
                ("C-x v s" . git-gutter:stage-hunk)
                ("C-x v r" . git-gutter:revert-hunk)
                )
    )
#+end_src

To diff with a revision other than the latest one, in the repo root directory,
add content similar to the following to the emacs directory local variable file
(=.dir-locals.el=):
#+begin_src emacs-lisp :tangle no
((prog-mode . ((git-gutter:start-revision . "my_branch"))))
#+end_src
Or
#+begin_src text
((nil . ((git-gutter:start-revision . "my_branch"))))
#+end_src

** git-link

#+begin_src emacs-lisp
  (use-package git-link
    :custom
    (git-link-open-in-browser t)
    (git-link-use-commit nil)
    )
#+end_src

- Choosing =git-link-use-commit= value

  For my workflow, I find it more convenient to set =git-link-use-commit= to
  =nil= rather than =t=. This configuration directs =git-link= to use the
  current branch name in the generated URL, which offers greater flexibility, as
  a URL containing a branch name can be easily modified to point to a different
  branch. This is particularly helpful in situations where I am working on a
  local development branch (which may not yet be pushed or visible to others)
  but need to share a link that references the =master= or =main= branch.
  Editing the branch name in the URL is straightforward in such cases.

  In contrast, when =git-link-use-commit= is set to =t=, the URL includes a
  specific commit hash. While this creates a permalink (the same as "Copy
  permalink" in the corresponding github page), it can be less convenient for
  the scenario described, as changing the URL to point to the =master= branch
  from a local commit hash requires more adjustment.

** blamer
#+begin_src emacs-lisp
  (use-package blamer
    :defer t
    )
#+end_src

- I do not turn on =global-blamer-mode= but instead run =M-x blamer-mode= in a
  specific buffer when designated.

** code review

Our development process is centered around GitHub, with code review requests
being managed through GitHub Pull Requests (PRs). However, using the GitHub web
UI for reviewing PRs presents some challenges:
- Navigating to related code can be cumbersome.
- An active internet connection is required at all times.

*** Navigation made easy by checking out code locally

To mitigate the first issue, I review code locally using Emacs. Here's how I
streamline the process:
1. Preparation
   1) Fetch and Checkout: Begin by fetching and checking out the PR branch on your local machine.
   2) Generate a Diff: In the Magit status or Magit log buffer, select all the commits you need to review. Press d r to generate the diff.
2. Review
   - Press =e= to use ediff if needed.
   - Press =C-j= at a line to navigate to the corresponding source file,
     allowing you to move around the codebase as usual to examine related code.

*** Read and write feedback offline with forge and code-review

Normally I do not require this. However, when needed, I use a combination of
forge and code-review, though this setup is not entirely perfect. Forge can
fetch the PR list but could not display inline comments, whereas Code Review
displays inline comments but does not fetch PR lists. Here’s how I use both
tools together:
1. Use =N f f= to fetch the PR list.
2. Move cursor to the desired PR and copy its link by pressing =C-c C-w=.
3. Execute =M-x code-review-start= and paste the copied link from the previous
   step.

#+begin_src emacs-lisp
  (use-package forge
    :defer t
    :after magit
    :config
    (custom-set-faces
     ;; Do not share "MediumPurple" with merged pull requests.
     '(forge-pullreq-rejected ((t (:foreground "DarkRed" :strike-through t)))))
    )
#+end_src

#+begin_src emacs-lisp
  (use-package code-review
    :defer t
    :load-path (lambda() (concat my-downloads "code-review"))
    :commands (code-review-start)
    )
#+end_src

Apart from the above Emacs configuration, also remember to:
- Add github username into git config.
- Add the corresponding github token to auth source. For me, it is adding the
  following two lines to =~/.authinfo.gpg=
  #+begin_src text
        machine api.github.com login lgfang^forge password ******
        machine api.github.com login lgfang^code-review password ******
  #+end_src

NOTE:
- Display all PRs in the magit status buffer can slow down normal magit
  operations quit a bit. Use =M-x forge-toggle-display-in-status-buffer= to hide
  PR information when it is unnecessary.
- The official code-review is broken, use the following one
  #+begin_src text
    $ git remote -v
    origin  git@github.com:phelrine/code-review.git (fetch)
    origin  git@github.com:phelrine/code-review.git (push)

    $ git branch
    ,* fix/closql-update
  #+end_src

* ANSI color code

#+begin_src emacs-lisp
  (use-package ansi-color
    :hook (;; render color codes in the compilation buffer.
           (compilation-filter . ansi-color-compilation-filter))
    )

  (use-package flg-ansi-color-mode
    :after ansi-color
    :commands flg-ansi-color-mode
    )
#+end_src

* ASM

#+begin_src emacs-lisp
  (use-package asm-mode
    :ensure nil                           ; Explicitly disable for built-ins
    :mode "\\.asm\\'"
    :custom
    (asm-comment-char 59)                 ; 35 -> '#', 59 -> ';'
    )
#+end_src

* Bash

#+begin_src emacs-lisp
  (use-package sh-script                  ; built-in
    :defer
    :custom ((sh-basic-offset 2) (sh-indentation 2))
    )
#+end_src

** Language server
Eglot + [[https://github.com/bash-lsp/bash-language-server][bash-language-server]]

** Formatter
See also [[* Prettier]]

1. Install [[https://github.com/mvdan/sh][shfmt]] in command line.
2. Package install =shfmt=.

#+begin_src emacs-lisp
  (use-package shfmt
    :delight shfmt-on-save-mode
    :hook ((sh-mode bash-ts-mode) . shfmt-on-save-mode)
    :custom (shfmt-arguments '("-i" "2"))
    )
#+end_src

* C/C++

** Language server

Eglot + =clangd= (on MacOS, =clangd= comes with Developer Command Line Tools)

** Formatter

First, install =clang-format=:
- MacOS :: =brew install clang-format=
- Ubuntu =sudo apt install clang-format=.

Then configure in Emacs:
#+begin_src emacs-lisp
  (use-package clang-format
    :commands clang-format-buffer clang-format-region clang-format-on-save-mode
    :delight clang-format-on-save-mode
    ;; do not hook `clang-format-on-save-mode' due to legacy code
    )
#+end_src

** hide ifdefs

#+begin_src emacs-lisp
  (use-package hideif
    :ensure nil                           ; Built-in package
    :delight hide-ifdef-mode
    :hook ((c-mode c-ts-mode c++-mode c++-ts-mode) . hide-ifdef-mode)

    :custom
    ;; Fold all #ifdef blocks by default when `hide-ifdef-mode' is activated. This
    ;; prevents accidentally working in undefined blocks.
    (hide-ifdef-initially t)
    ;; (hide-ifdef-shadow t)                 ; shadow instead hide the text

    :config
    ;; Must set it in `:config' as `:custom' doesn't work for this variable
    (setq hide-ifdef-define-alist
     '(
       ;; Default alist (empty), fold all #ifdef (but *not* #ifndef) blocks
       (default)
       ;; MongoDB-specific macros for macOS
       (mongodb-mac __APPLE__
                    (__LIBCPP_STD_VER . 14)
                    )

       ))
    )
#+end_src

* CSV

Aligning columns in CSV files (=csv-align-mode=) is usually the most intuitive
presentation method. However, the added whitespace can sometimes extend lines
far beyond the screen width. In such cases, consider highlighting the columns
with different colors instead (=rainbow-csv-mode=).

#+begin_src emacs-lisp
  (use-package csv-mode
    :defer t
    :commands csv-align-mode
    )
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-csv
    :load-path (lambda() (concat my-downloads "rainbow-csv"))
    :defer t
    :delight
    :commands rainbow-csv-mode
    )
#+end_src

* Golang

No extra set up needed except for installing [[https://github.com/golang/tools/blob/master/gopls/README.md][gopls]] (the official language server
for golang).
- LSP: eglot + gopls
- Formatter: =eglot-format=
- Flymake: eglot as the backend

* Java

** Language server
Eglot + [[https://github.com/eclipse-jdtls/eclipse.jdt.ls][Eclipse JDT Language Server (JDTLS)]]

1. Download a milestone build of JDTLS and extract it to =~/.local=.
2. Add the path to =jdtls= to Emacs exec path:
   #+begin_src emacs-lisp
   (add-to-list 'exec-path (expand-file-name "~/.local/jdt-language-server/bin"))
   #+end_src
   Alternatively, add the path to the OS environment variable =PATH= and restart
   Emacs.

* JSON, JSON Lines

** JSON ts mode
#+begin_src emacs-lisp
  (use-package json-ts-mode
    :mode "\\.json\\(l?\\)\\'" "mongod.*\\.log" ; mongod logs are json lines
    )
#+end_src

** Structured log mode
This is a minor I wrote to display log files formatted as JSON lines in a more
human friendly way.
#+begin_src emacs-lisp
  (use-package structured-log-mode
    ;; my own package for viewing json format log files.
    :load-path (lambda() (concat my-elisps "structured-log-mode"))
    :commands structured-log-mode
    )
#+end_src

** JSON path to the node at point

This function is based on treesit (=json-ts-mode=)
#+begin_src emacs-lisp
  (use-package json-ts-mode
    :commands
    (treesit-node-at treesit-parent-until treesit-node-text treesit-node-index
                     lgf-json-path)
    :config
    (defun lgf-json-path (&rest _ignored)
      (let* ((pos (point))
             (node (treesit-node-at pos)) ; can be a punctuation node
             (filter (lambda(n)
                       (member (treesit-node-type n) '("pair" "array"))))
             (parent (treesit-parent-until node filter))
             (path nil))
        (while parent
          (setq path
                (cons
                 (pcase (treesit-node-type parent)
                   ("pair"
                    (treesit-node-text
                     (treesit-node-child (treesit-node-child parent 0) 1)
                     t))
                   ("array"
                    ;; NOTE: Cannot handle comments, but it is fine because the
                    ;; JSON standard says no comments.
                    (let* ((one-level-up (treesit-node-parent node))
                           (not-in-object (treesit-node-eq one-level-up parent))
                           (array-elem (if not-in-object node one-level-up))
                           )
                      (/ (1- (treesit-node-index array-elem)) 2))))
                 path))
          (setq node parent)
          (setq parent (treesit-parent-until parent filter)))
        (mapconcat (lambda(p) (format "%s" p)) path ".")))
    (defun lgf-json-path-set-up-eldoc ()
      (if (boundp 'eldoc-documentation-functions)
          (add-hook 'eldoc-documentation-functions #'lgf-json-path nil t)
        (setq-local eldoc-documentation-function #'lgf-json-path)))
    :hook ((json-ts-mode . lgf-json-path-set-up-eldoc))
    )
#+end_src

* LDAP Schema (LDIF)

Currently Emacs lacks support for editing LDAP schema (LDIF) files:
- The built-in package ~ldap.el~ is for LDAP server connections, *not* LDIF
  editing.
- The ~ldap-mode.el~ (v1.2, by Dave Love) offers very limited functionality
  (i.e. incomplete syntax highlighting) and is no longer maintained.

Hence, I recommend using ~fundamental-mode~ for LDIF files until a better
alternative emerges.

* Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode
    :defer t
    :custom (markdown-command "pandoc")
    )
#+end_src

* Mermaid chart

#+begin_src emacs-lisp
  (use-package mermaid-mode
    :mode "\\.mmd\\|.mermaid\\'"
    )
#+end_src

The ~mermaid-mode~ package depends on the mermaid cli tool, which is installed
on macOS using the following command:
#+begin_src bash
npm install -g @mermaid-js/mermaid-cli
#+end_src

* Perl

Both ~perl-mode~ and ~cperl-mode~ are now built-in packages. While ~perl-mode~
is the simpler default, I generally prefer the more sophisticated ~cperl-mode~.
#+begin_src emacs-lisp
  (use-package cperl-mode
    :ensure nil                           ; built-in
    :mode ("\\.\\([pP]\\([Llm]\\|erl\\|od\\)\\|al\\)\\'" . cperl-mode)
    :interpreter ("perl" . cperl-mode)    ; shebang support
    :init
    ;; Disable the default perl-mode autoloading
    (setq auto-mode-alist (rassq-delete-all 'perl-mode auto-mode-alist))
    :custom
    (cperl-indent-level 4)
    (cperl-close-paren-offset -4)
    (cperl-continued-statement-offset 4)
    (cperl-indent-parens-as-block t)
    (cperl-tab-always-indent t))
#+end_src

* PHP
#+begin_src emacs-lisp
  (use-package php-mode
    :mode ("\\.php\\'" "\\.phtml\\'") ; Auto-activate for .php and .phtml files
    :custom
    (php-mode-indent-offset 4)
    (php-align-assignments t)  ; Align assignments like $var = 'value';
    (php-electric-colon t)     ; Automatically insert '->' after class/object name
    (php-template-mode nil)    ; Set to t if work with mixed HTML/PHP extensively
    )
#+end_src

* Python

** Tree-sitter enhanced major mode
#+begin_src emacs-lisp
  (use-package python
    :hook ((python-mode python-ts-mode) . hs-minor-mode)
    :custom
    ;; triple quotes on their own lines
    (python-fill-docstring-style 'django)
    ;; for empty python files, as existing files use existing indent offset.
    (python-indent-offset 4)
    )
#+end_src

** Formatter
#+begin_src emacs-lisp
  (use-package ruff-format
    :delight ruff-format-on-save-mode
    :after reformatter
    :hook ((python-mode python-ts-mode) . ruff-format-on-save-mode)
    )
#+end_src

#+begin_src emacs-lisp
  (use-package ruff-fix
    :load-path (lambda() (concat my-elisps "emacs-ruff-fix"))
    :after reformatter
    :delight ruff-fix-on-save-mode
    :commands ruff-fix-buffer
    ;; :hook ((python-mode python-ts-mode) . ruff-fix-on-save-mode)
    )
#+end_src
NOTE: I prefer not to turn on the on =ruff-fix-on-save-mode= because it
sometimes can be a little bit obtrusive.

** Basic syntax check
#+begin_src emacs-lisp
  (use-package flymake-ruff
    ;; in addition to LSP
    :after flymake
    :hook ((python-mode . flymake-ruff-load)
           (python-ts-mode . flymake-ruff-load)
           ;; `flymake-ruff-load' can be safely added to `eglot-managed-mode-hook'
           ;; because it targets on python modes only.
           (eglot-managed-mode . flymake-ruff-load)))
#+end_src

** Poetry virtual environment

If the Python project uses Poetry for dependency management, this
package can activate the project's virtual environment in Emacs.

#+begin_src emacs-lisp
  (use-package poetry
    :defer
    :commands (poetry-tracking-mode poetry-venv-workon poetry-venv-deactivate)
    )
#+end_src

IMPORTANT:
- Run =poetry install= first to ensure packages are installed into the virtual
  environment.
- Run =M-x poetry-venv-workon= to manually activate a virtual environment.
- Run =M-x vterm= (or =M-x poetry-shell=), then execute =poetry env info= to
  verify the correct virtual environment is active.
  + If the wrong environment is activated (e.g., due to nested =pyproject.toml=
    files), re-run =poetry-venv-workon= with the desired =pyproject.toml= as the
    current buffer.
- Restart processes that depend on the virtual environment after activation. For
  example:
  - Run =M-x eglot-shutdown= followed by =M-x eglot= to restart the =pyright=
    used by =eglot=.
  - Kill the *Python* buffer and re-create it (=C-c C-p= or =M-x run-python=).

** LSP

pyright

* RFC
#+begin_src emacs-lisp
  (use-package rfc-mode
    :defer t
    :custom
    ;; ffap tries to find RFCs in these directories before giving a URL
    (ffap-rfc-directories '("~/projects/rfc"))
    ;; ffap no longer downloads RFCs, `rfc-mode-read` downloads RFC to this
    ;; directory.
    (rfc-mode-directory "~/projects/rfc")
    )
#+end_src
- g :: go to section
  - Note: it is *not* a =rfc-mode= issue that this (and imenu) does not work for
    some RFCs, such as RFC-3262. The issue lies with the RFCs themselves: they
    lack periods (.) after section numbers.
- n/p :: next/previous section
- PageDown/PageUp :: previous/next page
- TODO: u/d :: one level up/one level down

* Tcl & expect
#+begin_src emacs-lisp
  (use-package tcl
    :ensure nil                           ; built-in package
    :mode (("\\.tcl\\'" . tcl-mode))
    :config
    (add-to-list 'interpreter-mode-alist '("expect" . tcl-mode)))
#+end_src

* Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :mode "\\.tf\\'"
    :custom (terraform-indent-level 2)
    )
#+end_src

* Verilog
#+begin_src emacs-lisp
  (use-package verilog-mode
    :ensure nil                           ; built-in package
    :defer
    )
#+end_src

* Vimrc

#+begin_src emacs-lisp
  (use-package vimrc-mode
    :defer t
    :delight
    )
#+end_src

* XML

** nXML
#+begin_src emacs-lisp
  (use-package nxml-mode
    :defer t
    :mode ("\\.xml\\'"
           "\\.xsd\\'"
           "\\.sch\\'"
           "\\.rng\\'"
           "\\.xslt\\'"
           "\\.svg\\'"
           "\\.rss\\'")
    :magic ("<\\?xml ") ; Match files starting with <?xml
    :hook (nxml-mode . hs-minor-mode)
    :commands (nxml-backward-up-element xmltok-start-tag-local-name)
    :bind (:map nxml-mode-map
                ("M-'" . lgfang-toggle-level)
                ("<mouse-3>" . lgfang-toggle-level)
                )
    :config
    (defun nxml-where ()
      "Display XPath in mini buffer, from http://www.emacswiki.org/emacs/NxmlMode."
      (interactive)
      (let ((path nil))
        (save-excursion
          (save-restriction
            (widen)
            (while
                (and (< (point-min) (point)) ;; Doesn't error if point is at
                     ;; beginning of buffer
                     (condition-case nil
                         (progn
                           (nxml-backward-up-element) ; always returns nil
                           t)
                       (error nil)))
              (setq path (cons (xmltok-start-tag-local-name) path)))
            (if (called-interactively-p t)
                (message "/%s" (mapconcat 'identity path "/"))
              (format "/%s" (mapconcat 'identity path "/")))))))

    (add-to-list 'hs-special-modes-alist
                 '(nxml-mode
                   ;; "<!--\\|<[^/>]*[^/]>" ;; regexp for start block
                   ;; "-->\\|</[^/>]*[^/]>" ;; regexp for end block
                   "<!--\\|<[^/>][^>]*[^/]>" ;; our xml has names like calea/li
                   "-->\\|</[^/>][^>]*[^/]>"
                   "<!--" ;; regexp for comment start. (need this??)
                   nxml-forward-element
                   nil))
    )
#+end_src

** Relax-NG Compact (RNG & RNC)

#+begin_src emacs-lisp
  (use-package rnc-mode
    :defer t
    :config
    (defun rnc2rng ()
      "Convert current RNC buffer to RNG."
      (interactive)
      (let* ((rnc (buffer-file-name))
             (rng (concat (file-name-sans-extension rnc) ".rng")))
        (call-process "java" nil nil nil "-jar"
                      (expand-file-name "~/.emacs.d/downloads/trang.jar")
                      rnc rng)))
    )
#+end_src

* YAML

** Formatter
See [[* Prettier]]

** Tree-sitter enhanced major mode
#+begin_src emacs-lisp
  (use-package yaml-ts-mode
    :mode ("\\.y\\(a?\\)ml\\'" . yaml-ts-mode)
    )
#+end_src

** YAML pro
#+begin_src emacs-lisp
  (use-package yaml-pro
    :hook ((yaml-ts-mode . yaml-pro-ts-mode))
  )
#+end_src
Among the features, it provides the two most useful features when reading large YAML files
- Show the YAML path of the current node in the mini buffer via eldoc mode
- Support of imenu

** Flymake
#+begin_src emacs-lisp
  (use-package flymake-yamllint
    :after flymake
    :hook ((yaml-ts-mode . flymake-yamllint-setup))
    )
#+end_src

* To migrate

#+begin_src emacs-lisp
;; an intentional assignment to free variable. If the following setq is the
;; first line in corresponding flymake diagnostics buffer, then all the migrated
;; configurations are errors/warnings free
(setq ------OLD-CONFIG-START------ "")

;;; paths -- delete after .org.el is migrated as well
(defvar my-emacs-base
  (file-name-as-directory (expand-file-name "~/.emacs.d")))
(defvar my-extension-path
  (file-name-as-directory (expand-file-name "~/.emacs.d/emacs-extensions")))
(defvar my-backward-path
  (file-name-as-directory (concat my-extension-path "backward-compatibility")))

;; load path
(add-to-list 'load-path my-extension-path)
(add-to-list 'load-path my-backward-path t)

(load "~/.org" t nil nil)
(load "lgfang.emms" t nil nil)

(define-key global-map (kbd "M-/") 'hippie-expand)

;;; auto mode list
(setq auto-mode-alist (append
                       '(
                         ("\\.[xX]\\'" . c-mode)
                         ("\\.mak\\'" . makefile-mode)
                         ("\\.make\\'" . makefile-mode)
                         ("\\.gdb\\'" . gdb-script-mode)
                         )
                       auto-mode-alist))

(unless (eq system-type 'darwin)          ; OSX
  (setq browse-url-browser-function 'browse-url-firefox))

;;; Current path+filename
(defun current-file-path ()
  "Copy current path/to/file_name to the kill ring."
  (interactive)
  (let ((string (buffer-file-name)))
    (message (concat "current file: " string))
    (kill-new string)))

;;; ediff
(setq
 ;; ediff-diff-options "-w"
 ;; do not pop a frame for ediff
 ediff-window-setup-function 'ediff-setup-windows-plain
 ;; my screen is large enough
 ediff-split-window-function 'split-window-sensibly)

;;; elisp
(add-hook 'emacs-lisp-mode-hook
          (lambda()  (hs-minor-mode 1)))

;;; face, add our own keywords. ctypes.el is too heavy-weight
(add-hook 'find-file-hooks
          (lambda ()
            (font-lock-add-keywords
             nil '(("\\<\\(lgfang\\|TODO\\|FIXME\\|NOTE\\|IMPORTANT\\):"
                    . (0 font-lock-warning-face t))))))
(font-lock-add-keywords 'c-mode         ; for c mode only
                        '(("\\<\\(TRUE\\|FALSE\\)\\>"
                           . font-lock-constant-face)))

;;; hippie expand
(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-visible
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))

(require 'htmlize nil t)

;;; Javascript
(add-hook 'js-mode-hook
          (lambda()
            (define-key js-mode-map (kbd "M-'") 'lgfang-toggle-level)
            (define-key js-mode-map [mouse-3] 'lgfang-toggle-level)
            (hs-minor-mode 1)))

(setq messages-buffer-max-lines 500)    ; default value too small

;;; selective display
(defun lgfang-toggle-selective-display()
  "set-selective-display to current column or toggle
selective-display"
  (interactive)
  (let ((arg (progn (back-to-indentation) (1+ (current-column)))))
    (set-selective-display (if (eq arg selective-display) nil arg))))

;;; server (alternatively, you may use "emacs --daemon")
(require 'server)
(when (not (server-running-p))
  (server-start))

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(highlight-parentheses-colors '("#689d6a" "#d79921" "#458588" "#b16286" "#98971a"))
 '(package-selected-packages
   '(flymake-yamllint editorconfig company cue-mode git-gutter mermaid-mode protobuf-mode cmake-mode magit anaconda-mode eglot blacken git-link csv-mode emms json-reformat windata w3m solarized-theme showtip terraform-mode highlight-parentheses highlight-indentation org-contrib yasnippet-snippets hide-lines ox-gfm yasnippet pydoc-info pydoc markdown-mode jira-markup-mode ht go-mode flycheck f)))
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
#+end_src
