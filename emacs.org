# -*-mode:org; coding:utf-8; time-stamp-pattern:"8/#\\+DATE:[ \t]+%Y-%02m-%02d %5z$" -*-
# Created: Lungang Fang 2024-05-17

#+TITLE: My Emacs Configurations
#+AUTHOR: Fang Lungang
#+DATE: 2025-02-14 +1100
#+DESCRIPTION: My Emacs configurations
#+KEYWORDS: Emacs
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el :mkdirp yes

* Timestamp for tangling

This block itself is not tangled into any configuration file. However, during
the tangling process, it produces a timestamp that other blocks may reference.

#+name: tangle-time-stamp
#+begin_src emacs-lisp :tangle no
(concat user-full-name " " (format-time-string "%Y-%m-%d %5z"))
#+end_src

* Header

#+begin_src emacs-lisp :noweb yes
  ;;; init.el --- Lungang's init.el

  ;; Created: Fang Lungang 2004
  ;; Updated: <<tangle-time-stamp()>>

  ;;; Commentary:

  ;; This Emacs configuration file is generated from my "emacs.org" (see
  ;; https://github.com/lgfang/dotfiles)

  ;; Usage: Run Emacs with this configuration file. After start up, Emacs will
  ;; report missing packages. Normally you can continue using Emacs without these
  ;; packages. But, for better experience, please firstly run `M-x
  ;; package-refresh-contents` and then run `M-x package-install` to install
  ;; missing packages one after another.

  ;;; Code:
#+end_src

* Bootstrap

** Profile Emacs start time

It is fun to see how long each package takes to load and optimize if possible.
Hence, I use the following configuration.
#+begin_src emacs-lisp
  (use-package use-package-core
    :custom
    (use-package-compute-statistics t)
    )
#+end_src

Run =emacs --no-desktop= to ensure not opening any previous files. Then run the
following commands to see the statistics:
- =M-x use-package-report=
- =M-x emacs-init-time=

** Start up screen
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (inhibit-startup-screen t)
    (initial-scratch-message "")
    )
#+end_src

** Initialize "package"

#+begin_src emacs-lisp
  (use-package package
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    (package-initialize)
  )
#+end_src

To manually upgrade install packages in batch,
1. Run =M-x package-refresh-contents=
2. Run =M-x list-packages=
3. Then, following the prompt in the mini-buffer, type =U= and =x=

** Paths

Note that the =use-package emacs= thing is unnecessary. I'm using it to group
related configurations together.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (defvar my-emacs-d (file-name-as-directory (expand-file-name "~/.emacs.d")))
    (defvar my-downloads (file-name-as-directory (concat my-emacs-d "downloads")))
    (defvar my-elisps (file-name-as-directory (concat my-emacs-d "my-elisps")))
    (add-to-list 'load-path my-elisps t)
    (defvar my-personal-path (file-name-as-directory
                              (expand-file-name "~/mynotes/personal")))
  )
#+end_src

** Personal information

#+begin_src emacs-lisp
  (use-package my-confidential
     :load-path my-personal-path
     )
#+end_src

* Language environment and coding system

Set terminal coding system to utf-8 explicitly to display unicode chars
(including emojis/Chinese chars) correctly.

This block is needed only when utf-8 is supported but Emacs does not detect and
set it correctly, due to wrong shell locale etc. In such situation, try the
combinations of these settings until you find one that works.

Therefore, this block is *not* tangled by default. When necessary, delete
=:tangle no= from this block header to tangle it.

#+begin_src emacs-lisp :tangle no
  (set-terminal-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-language-environment 'utf-8)
#+end_src

* ZWJ (Zero Width Joiner) emoji handling.

Disable =auto-complete-mode= if running in a terminal as most terminal emulators
cannot handle Emoji ZWJ. See ZWJ examples in [[file:~/mynotes/emacs/emacs-unicode-test.org][my ZWJ test file]].

NOTE: disabling it on the fly does not work very well, must restart Emacs.

#+begin_src emacs-lisp
  (use-package emacs
    :if (not (display-graphic-p))
    :config
    (setq-default auto-composition-mode nil)
    )
#+end_src

* Interaction convenience

** mouse

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (mouse-yank-at-point t)
    (mouse-drag-copy-region t)
    :config
    (when (not window-system) (xterm-mouse-mode 1)) ;use mouse in xterm
    )
#+end_src

** y-or-n
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (fset 'yes-or-no-p 'y-or-n-p)         ; Type y/n to answer yes or no prompts.
    )
#+end_src

** comment dwim
#+begin_src emacs-lisp
  (defadvice comment-dwim (before lgfang-comment-wim activate compile)
    "Acts on comment smartly base on the current cursor position in the line."
    (unless (or mark-active (looking-at "[ \t]*$"))
      (goto-char (line-beginning-position))
      (set-mark-command nil)
      (goto-char (line-end-position))))
#+end_src

** Ibuffer

#+begin_src emacs-lisp
  (use-package ibuffer                    ; built-in package
    :commands ibuffer-switch-to-saved-filter-groups
    :custom
    (ibuffer-saved-filter-groups (quote (("default"
                                          ("Dired" (mode . dired-mode))
                                          ("Magit" (name . "^magit"))
                                          ("Emacs" (name . "^\\*.*\\*$"))
                                          ))))
    :bind (:map global-map ("C-x C-b" . ibuffer))
    :hook (ibuffer-mode . (lambda() (ibuffer-switch-to-saved-filter-groups "default")))
    )
#+end_src

** Repeat mode

#+begin_src emacs-lisp
  (use-package repeat                     ; built-in package
    :custom
    (repeat-too-dangerous '(kill-this-buffer))
    (repeat-exit-timeout 6)
    ;; (repeat-exit-key  "RET")
    :init
    (repeat-mode)
    )
#+end_src

This section contains general settings for repeat mode. To add repeat mode
support for modes without build in repeat mode support, see [[*org mode repeat map][org mode repeat map]]
for an example.


Note that there is normally no need of setting =repeat-eixt-key=, to exit repeat
mode before =repeat-exit-timeout=, just type any character which is no bound in
this particular repeat mode or =C-g=.

** Vertico + orderless + marginalia + consult
#+begin_src emacs-lisp
  (use-package vertico
    :defer t
    :defines vertico-map
    :functions vertico-mode vertico-multiform-mode
    :bind (:map vertico-map ("C-o" . vertico-quick-exit))
    :custom
    (vertico-resize nil)
    (vertico-cycle nil)
    ;; ;; Avoid `reverse' + `mouse', they are not compatible at the moment.
    ;; (vertico-multiform-categories '(
    ;;                                 ;; default, enable buffer & mouse
    ;;                                 (t buffer mouse)
    ;;                                 ))
    ;; (vertico-multiform-commands '(("imenu" buffer mouse)
    ;;                               ("recentf-.*" buffer mouse)
    ;;                               ))
    :init
    (vertico-mode 1)
    (vertico-multiform-mode 1)
    )

  (use-package orderless
    :defer t
    :custom (completion-styles '(basic
                                 partial-completion
                                 substring
                                 orderless
                                 flex))
    )

  (use-package marginalia
    :defer t
    :functions marginalia-mode
    :init
    (marginalia-mode 1)
    )

  (use-package consult
    :bind (:map global-map
                ("<f2>"  . consult-imenu)
                ;; ("M-s o" . occur             ; Built-in
                ("M-s l" . consult-line)     ; mnemonic: line,
                ("M-s d" . consult-flymake)  ; mnemonic: diagnostics
                ("M-y"   . consult-yank-pop) ; replaces `browse-kill-ring'
                )
    )
#+end_src

Other useful consult commands:
- =M-x consult-find= :: when you are certain that a file is within the current
  directory or project, but unsure about its specific sub-directly.

** Embark

#+begin_src emacs-lisp
  (use-package embark
    :defer t
    :bind (:map global-map ("C-x ." . embark-act))
    )
  (use-package embark-consult)
#+end_src

* Shortcuts to files and links

** ffap
#+begin_src emacs-lisp
  (use-package ffap                       ; built-in
    :defer t
    :bind (:map global-map ("C-x C-f" . ffap))
    :config
    ;; My extensions to ffap jira/sfsc tickets. Remember to define my-employer in
    ;; my-confidential.el
    (defun ffap-jira (name) ; ffap HELP-12345 etc. opens corresponding jira ticket
      (let ((company (if (boundp 'my-employer) my-employer "example")))
        (format "https://jira.%s.org/browse/%s" company name)))
    (add-to-list 'ffap-alist '("\\`\\(HELP\\|SERVER\\)-[0-9]+\\'" . ffap-jira))
    )
#+end_src

** Openwith mode
#+begin_src emacs-lisp
  (use-package openwith
    :defines openwith-associations
    :commands openwith-mode
    :custom (openwith-confirm-invocation t)
    :config
    (when (eq system-type 'darwin)
      ;; On MacOS, the system tool `open' opens the target file with system
      ;; default applications. So, for most types, passing the file to `open' is
      ;; enough.x
      (setq openwith-associations '(("\\.mp4" "open" (file))
                                    )))
    :init
    (openwith-mode)
    )
#+end_src

** Webjump

This provides the functionality similar to [[file:~/mynotes/utils/apple.org::*Define Chrome site search shortcuts][Chrome site search shortcuts]].
#+begin_src emacs-lisp
  (use-package webjump                    ; built-in package
    :bind (:map global-map ("C-c j" . webjump))
    :custom
    (webjump-sites '(("google"
                      . (concat "https://www.google.com/search?q="
                                (url-hexify-string
                                 (if (use-region-p)
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end))
                                   (thing-at-point 'word t)))))
                     ("dict.cn"
                      . (concat "https://dict.cn/search?q="
                                (url-hexify-string
                                 (if (use-region-p)
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end))
                                   (thing-at-point 'word t)))))
                     ))
    )
#+end_src

While Webjump is not necessarily more convenient than Chrome site search
shortcuts, it provides more flexibility.
- My webjump work flow
  1. C-c j :: run webjump
  2. Type in or select "jira ticket" + press enter
  3. Type in ticket number + enter
- My chrome site search shortcut work flow
  1. Cmd-9 Cmd-l :: go to Chrome URL address bar
  2. Type in "jira" + space :: trigger the site search shortcut
  3. Type in ticket number + enter

* Sessions and histories

#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; Save mini buffer history
    (savehist-mode t)
    ;; Save cursor places between sessions
    (save-place-mode t)
    ;; Reopen files etc. when Emacs restarts
    (desktop-save-mode 1)
    ;; Automatically close buffers inactive for a long time
    (midnight-mode t)
    )

  (use-package recentf                    ; built-in package
    :defines recentf-keep
    :custom (recentf-max-saved-items 666)
    :init
    (recentf-mode 1)
    (add-to-list 'recentf-keep 'file-remote-p)
    :bind (:map global-map ("<f1>" . recentf-open))
    )
#+end_src

Note that, for =recentf= we add =file-remote-p= to the head of the
=recentf-keep= list so that remote file names are kept without connecting to the
remote server to check if these files do exist.

* Frame and window

#+begin_src emacs-lisp
  (use-package emacs
    :commands scroll-bar-mode             ; make flymake happy
    :init
    (menu-bar-mode (if (display-graphic-p) 1 -1)) ; turn it on for GUI only
    (tool-bar-mode -1)                            ; turn it off
    (when (display-graphic-p)
      (scroll-bar-mode -1)
      (add-to-list 'default-frame-alist '(fullscreen . maximized))
      )
    )

  (use-package emacs
    :custom (split-width-threshold 200)
    )

  (use-package winner
    :init
    (winner-mode 1)
    ;; default key bindings: C-c <left>/<right>
    )

  (use-package transpose-frame
    ;; Do not bind any keys because the only command I use rather frequently is
    ;; `rotate-frame-clockwise' and I run it via `ace-window' dispatcher (see my
    ;; `ace-window' configuration)
    )

  (use-package ace-window
    :defines aw-dispatch-alist
    :bind (:map global-map ("M-o" . ace-window))
    :custom (aw-dispatch-always t)   ; dispatch even only two windows or less
    :config
    (add-to-list 'aw-dispatch-alist '(?t rotate-frame-clockwise))
    )

  (defun flg-toggle-window-dedicated ()
    "Toggle `set-window-dedicated-p' for the current window."
    (interactive)
    (let ((window (selected-window)))
      (set-window-dedicated-p window (not (window-dedicated-p window)))
      (message "Window %sdedicated to %s"
               (if (window-dedicated-p window) "" "no longer ")
               (buffer-name))))
#+end_src

With =ace-window= package, I feel no more need of =windmove=, =C-x 4 4= or
=lgf-tiling=. Below are Some =ace-window= hotkeys I frequently use (run =M-o ?=
to see more):
- =M-o n= :: jump back and forth between two windows.
- =M-o m= :: swap two windows.
- =M-o u= :: change the buffer of another window.
- =M-o t= :: run =rotate-frame-clockwise= (from =transpose-frame=).

** Popper

Summon and dismiss "pop-up" buffers with a single key-chord, minimize the impact
to the current window layout.

#+begin_src emacs-lisp
  (use-package popper
    :commands popper-mode popper-echo-mode
    :bind (:map global-map
                ;; C-` unavailable in some terms as it is interpreted as C-@
                ("<f8>" . popper-cycle)
                ("M-`" . popper-toggle))
    :custom
    (popper-reference-buffers
     '("personal.gtd"
       "work.gtd"
       "\\*Copilot.*\\*"
       "\\*maple-translate\\*"
       "\\*Python\\*"
       "\\*Org Agenda\\*"
       "\\*Flymake diagnostics for .*\\*"
       help-mode
       compilation-mode))
    :config
    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

* Fonts

Select the font for Chinese characters using =set-fontset-font=. This command
sets the fallback font when the default font doesn't support the current
character. By default, Emacs iterates all the fonts until it finds one that
supports the character.

Scale Chinese fonts so that the width of 1 Chinese char equals that of two
English chars. This list is manually maintained as the scale factors for
different fonts are determined through trial and error. Note:
- To check the font of the current character, run ~C-u C-x =~.
- To get more accurate data, compare longer lines of English/Chinese.

#+begin_src emacs-lisp
  (use-package emacs
    :if (display-graphic-p)
    :config
    (set-face-attribute 'default nil :font "Andale Mono-20:weight=normal")

    (let ((zh-font "SimSong"))
      (if ;; Check the availability first to avoid error
          (member zh-font (font-family-list))
          ;; "fall back" to the designated zh font for `han' characters. Guard the
          ;; following expression with `fboundp' to avoid the warning: "function
          ;; ... is not known to be defined" .
          (and (fboundp 'set-fontset-font) (set-fontset-font t 'han zh-font))))

    (setq face-font-rescale-alist '(("SimSong" . 1.25)
                                    ("PingFang SC" . 1.25)
                                    ))
    )
#+end_src

* Color theme

#+begin_src emacs-lisp
  ;; (use-package emacs
  ;;   :init
  ;;   (load-theme 'wombat)
  ;;   )

  (use-package solarized-theme
    :config
    (load-theme 'solarized-gruvbox-dark t)
    )
#+end_src

* Files and directories

** Auto revert-buffer

Auto-revert a buffer when corresponding file is modified by another process.
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (global-auto-revert-mode t)
    )
#+end_src

** Backup files
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (make-backup-files t)
    (version-control 'never)
    (backup-by-copying-when-linked t)
    )
#+end_src

** Dealing with huge files
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun lgf-huge-file-hook ()
      "Open huge files with minimum features.

  Huge files (normally log files) can make Emacs sluggish or even
  freeze. This hook tells Emacs to open such files with the
  `fundamental-mode' and turn off any extra features which cannot
  handle large files. In addition, it makes the buffer read only to
  avoid accidental modifications."
      (when (> (buffer-size) (* 1024 1024 16)) ; 16 MB
        (setq buffer-read-only t)
        (buffer-disable-undo)
        (fundamental-mode)
        (which-function-mode -1)
        (if (fboundp 'highlight-parentheses-mode) (highlight-parentheses-mode -1))
        ))
    (add-hook 'find-file-hook 'lgf-huge-file-hook)
    )
#+end_src

** Update timestamps before save

#+begin_src emacs-lisp
  (use-package emacs
    :hook ((before-save . time-stamp))
  )
#+end_src

Be aware that customizing =time-stamp-pattern= globally (for example, in
=init.el=) may conflict with others configuration. I.e. if you update files from
others who use a different timestamp format, then the timestamps will not be
updated. Hence, it is recommended to set timestamp format as a file local
variable.

Below are two examples:
- =#+DATE: 2024-07-11 +1000=

  #+begin_src org :tangle no
    # -*-mode:org; coding:utf-8; time-stamp-pattern:"8/#\\+DATE:[ \t]+%Y-%02m-%02d %5z$" -*-
  #+end_src

- =Modified: Fang Lungang 2024-07-11T16:41:47+1000=

  #+begin_src org :tangle no
    # -*-mode:org;coding:utf-8;time-stamp-pattern:"8/Updated[:][ \t]*%U %Y-%02m-%02dT%02H:%02M:%02S%5z$"-*-
  #+end_src

  Note: =Updated[:]= matches =Updated:=. The reason using the former is to avoid
  the pattern itself being replaced.

** Directories
#+begin_src emacs-lisp
  (use-package dired-x                    ; built-in package
    :custom
    (dired-recursive-copies 'top)
    (dired-recursive-deletes 'top)
    (dired-guess-shell-alist-user
     '(("\\.gpg\\'" "gpg --decrypt-files")
       ;; By default use `open', which chooses the correct application On MacOS.
       ("\\.*\\'" "open")))
    ;; `dired-omit-mode' hides all dot files, like `ls'
    (dired-omit-files "\\`[.#].*")
    (dired-kill-when-opening-new-dired-buffer nil)
    )
#+end_src

* Basic auto typing

** Fill

In the past, the suggestion was to limit code lines to 80 characters for optimal
printing on A4 paper or for neat screen display.

Nowadays, although larger monitors can comfortably display two buffers side by
side, each with 100 characters, there are still times we work on the build-in
smaller screens. Hence, we keep the fill column to 80.

#+begin_src emacs-lisp
(setq-default fill-column 80 comment-fill-column nil)
#+end_src

** Whitespace
#+begin_src emacs-lisp
  (use-package emacs                      ; clean up tab, indent and whitespace
    :custom
    (tab-width 4)
    (tab-stop-list nil)                   ; stops at every `tab-width' columns
    (indent-tabs-mode nil)                ; space instead of <tab> for indentation
    :hook
    ((before-save . whitespace-cleanup))
    )
#+end_src

** Yasnippet
#+begin_src emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    ;; Put personal/customized snippets into the first dir of `yas-snippet-dirs',
    ;; which is `~/.emacs.d/snippets' by default. NOTE: it is `yas-snippet-dirs'
    ;; NOT `yasnippet-snippets-dir'. The later is where the package
    ;; `yasnippet-snippets' stores its snippets.
    ;; TODO: cleanup duplicated/similar snippets in different directories.
    :functions yas-global-mode
    :init (yas-global-mode 1)
    )

  (use-package yasnippet-snippets
    :after yasnippet-snippets)
#+end_src

Below are some common snippets. For mode specific snippets, see the
corresponding sections.

*** timestamp
#+begin_src snippet :tangle ~/.emacs.d/snippets/fundamental-mode/timestamp :mkdirp yes
  # -*- mode: snippet -*-
  # key: ts
  # name: timestamp

  # Insert the string and comment it in a tmp buffer and the copy it into
  # the current buffer. This is to avoid the warning 'modified buffer in a
  # backquote expression'.

  # --
  `(let* ((mode major-mode))
       (with-temp-buffer
         (insert "-*- time-stamp-pattern:\"8/Updated:[ \\t]+%U %Y-%02m-%02d %5z$\" -*-\n"
          (format "Created: %s %s\n" (user-full-name) (format-time-string "%Y-%m-%d"))
          (format "Updated: %s %s\n" (user-full-name) (format-time-string "%Y-%m-%d %5z")))
         (funcall mode)
         (comment-region (point-min) (point-max))
         (buffer-string)))`
#+end_src

* Spelling check: flyspell

#+begin_src emacs-lisp
  (use-package flyspell
    :delight
    :hook ((prog-mode . flyspell-prog-mode)
           (yaml-mode . flyspell-prog-mode)
           (yaml-ts-mode . flyspell-prog-mode)
           (markdown-mode . flyspell-mode)
           (git-commit-setup . flyspell-mode)
           (org-mode . flyspell-prog-mode)
           )
    )
#+end_src

* Visual aids

** Display column number in the mode line

#+begin_src emacs-lisp
(use-package emacs
  :config
  (column-number-mode t)
  )
#+end_src

** Display line numbers

No configuration is needed. Add this block just to remind myself the command name.

#+begin_src emacs-lisp
  (use-package display-line-numbers       ; built-in package
    :defer t
    :commands display-line-numbers-mode global-display-line-numbers-mode
    ;; :custom
    ;; (display-line-numbers-widen t)
    ;; (display-line-numbers-major-tick 50)
    ;; (display-line-numbers-minor-tick 10)
    )
#+end_src

** Clean up mode line

*** Tool to remove minor mode lighter texts

#+begin_src emacs-lisp
  (use-package delight
    :ensure t
    :commands delight
    :config
    ;; delight built-in modes here.
    (delight '((subword-mode nil "subword") (global-subword-mode nil "subword")
               (superword-mode nil "subword") (global-superword-mode nil "subword")
               (eldoc-mode nil "eldoc")
               (hi-lock-mode nil "hi-lock")
               (hs-minor-mode nil "hideshow")
               ))
    )
#+end_src

*** Remove control (vc) info from the mode line

This info can take a lot of space (when the branch is long) and outdated (when
the file version change but the file is not re-opened).

Delete it from the mode line to make room for more useful information, say
"which-function-mode".

#+begin_src emacs-lisp
  (setq-default mode-line-format (delete '(vc-mode vc-mode) mode-line-format))
#+end_src

** Highlight whitespace

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (whitespace-line-column nil)          ; nil => use the value of `fill-column'
    (whitespace-style '(face
                        trailing
                        tabs
                        indentation
                        space-before-tab
                        space-after-tab
                        tab-mark
                        empty
                        ;; lines-tail - too harsh on eyes: highlights all the
                        ;; characters beyond the threshold can be harsh on eyes
                        ;; when the code has a lot of long lines.

                        ;; line-char - cannot highlight space: highlights the
                        ;; characters on the fill column only. If it happens to a
                        ;; be space, then no highlight.
                        ))

    :init
    ;; Do NOT turn `whitespace-mode' on globally. Because: a) in many situations,
    ;; like when using ediff or reading existing code, whitespace is expected but
    ;; may considered problem by `whitespace-mode'. b) Anyways whitespace issues
    ;; are fixed automatically because we add `whitespace-cleanup' (in a different
    ;; configuration section) to the before save hook.
    (global-whitespace-mode -1)
    )
#+end_src

** Show fill column indicator

#+begin_src emacs-lisp
  (use-package fill-column-indicator
    :defer t
    :commands fci-mode
    ;; :hook ((emacs-lisp-mode . fci-mode))
    )
#+end_src

NOTE: Do NOT add =fci-mode= to =emacs-lisp-mode-hook= to avoid the
=chicken-and-egg= problem: attempts to package-install any package, including
=fci-mode= itself, it will try to enable =fci-mode=, which isn't installed yet.

To to make a global minor mode, use the following code:
#+begin_src emacs-lisp :tangle no
  (define-globalized-minor-mode global-fci-mode
       fci-mode (lambda() (fci-mode 1)))
#+end_src

** Highlight indentation levels

#+begin_src emacs-lisp
  (use-package highlight-indentation
    :delight
    (highlight-indentation-current-column-mode)
    (highlight-indentation-mode)
    :custom
    ;; Disable highlight-indentation-blank-lines, as it prevents `C-a' from going
    ;; to the beginning of blank lines and causes some other issues.
    (highlight-indentation-blank-lines nil)
    ;; ;; manually set the face if desired ("gray20" suits dark themes)
    ;; (set-face-background 'highlight-indentation-face "gray20")

    :hook (((python-mode python-ts-mode) . highlight-indentation-current-column-mode)
           ((yaml-mode yaml-ts-mode) . highlight-indentation-current-column-mode)
           )
    )
#+end_src

** Highlight matching parenthesis

#+begin_src emacs-lisp
  (use-package highlight-parentheses
    :delight
    :commands global-highlight-parentheses-mode
    :init (global-highlight-parentheses-mode t)
    ;; :custom (hl-paren-colors    ; `M-x list-colors-display' to see named colors
    ;;          '("brown" "orange" "yellow" "forest green" "cyan" "blue" "violet"))
    )
#+end_src

** Highlight current line

Normally unnecessary, add this section just to remind myself the command names
in case they are needed.
#+begin_src emacs-lisp
  (use-package hl-line                    ; built-in
    :defer t
    :commands global-hl-line-mode hl-line-mode
    )
#+end_src

NOTE: this package, along with similar ones such as beacon, only updates the
*active* window. This means that if an action is performed in the current window
that moves the cursor in another window, the visual indicator of the current
line of the other window (inactive) will not be updated until you switch to it.

** Focus mode
#+begin_src emacs-lisp
  (use-package focus
    :defines focus-mode-to-thing
    :config
    (add-to-list 'focus-mode-to-thing '(python-ts-mode . py-thing))
    )
#+end_src

** Minimap

#+begin_src emacs-lisp
  (use-package minimap
    :defer t                         ; Just an eye candy which I almost never use.
    :custom (minimap-window-location 'right)
  )
#+end_src

* Finance bookkeeping
#+begin_src emacs-lisp
  (use-package ledger-mode
    :defer t
    :defines ledger-mode-map
    :bind
    (:map ledger-mode-map
          ("C-c ." . (lambda() (interactive)
                       (insert (format-time-string "%Y-%m-%d")))))
    :custom
    (ledger-report-use-strict t)
    (ledger-reconcile-default-commodity "AUD")
    )
#+end_src

** Snippets for ledger mode

#+begin_src snippet :tangle ~/.emacs.d/snippets/ledger-mode/council-rate :mkdirp yes
  # -*- mode: snippet -*-
  # key: council
  # name: Council rate
  # --
  `(format-time-string "%Y-%m-%d"))` * Council
      Expenses:House${1:A}:Fee         ${2:888}.${3:00} AUD
      Assets:Cash:${4:BankX}
#+end_src

* Encryption and credential management

** COMMENT Encrypt files with passwords: ccrypt

Automatically encrypt/decrypt =.cpt= files using =ccrypt=.

#+begin_src emacs-lisp
  (use-package ps-ccrypt
    :load-path my-downloads
    ;; remember to "brew install ccrypt".
    )
#+end_src

Note: while this one is simple and straightforward, I've switched to GPG, which
might appear to be complicated at the first glance but is actually more
convenient (due to gpg agent) and more secure.

** Encrypt files using keys: gnugpg

Automatically encrypt/decrypt =.gpg= files using gnupg. On MacOS, set it up as
below:
1. =brew install gpg=
2. =brew install pinentry-mac=
   * By default, =gpg= comes with =pinentry= which does not work well with GUI
     Emacs.
3. =echo "pinentry-program /opt/homebrew/bin/pinentry-mac" > ~/.gnupg/gpg-agent.conf=
   * Update =gpg-agent= configuration to use =pinentry-mac= instead of =pinentry=.
4. =killall gpg-agent=
   * Ensure the new gpg agent configuration takes effect.
5. Create/import gpg keys.
   * IMPORTANT: remember to export and backup keys.

Apart from the above I need NO explicit Emacs configuration in this regard
*yet*.

*** Why

I prefer keys (this) than passwords (i.e. ccrypt) for the use case of protecting
a number of local files on my laptop.

- Pros:

  + Easier to change the password: instead of re-encrypt all the files using the
    new password, you only need to re-encrypt the key file.

  + Enables network backup: it is rather safe to backup your data to network so
    long as you *do not upload the key file as well*.

  + Easier to dispose data: similarly, dispose your device is safer as
    deleting/overwriting the key file ensure the data is not accessible even if
    the disk isn't properly formatted.

  + Encrypting new files/data does not require password: encrypt is done using
    the public key.

  + Enables others to encrypt and send data to you online.

  + Can attach comments and notations to keys as reminders of the theirs
    usages/passphrases.

- Cons:
  - One extra thing (the keys) to maintain. Must remember to backup and update
    when a key is edited (say changed passphrase).
  - =gpg= does not support in place file encryption as =ccrypt= does.

*** Manage gpg keys (outside Emacs)

- Show existing: =gpg --list-keys=
- Generate: =gpg --full-gen-key=, then follow the screen prompts.
  #+begin_src text
    $ gpg --full-generate-key
    gpg (GnuPG) 2.4.5; Copyright (C) 2024 g10 Code GmbH
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.

    Please select what kind of key you want:
       (1) RSA and RSA
       (2) DSA and Elgamal
       (3) DSA (sign only)
       (4) RSA (sign only)
       (9) ECC (sign and encrypt) *default*
      (10) ECC (sign only)
      (14) Existing key from card
    Your selection? 1
    RSA keys may be between 1024 and 4096 bits long.
    What keysize do you want? (3072) 4096
    Requested keysize is 4096 bits
    Please specify how long the key should be valid.
             0 = key does not expire
          <n>  = key expires in n days
          <n>w = key expires in n weeks
          <n>m = key expires in n months
          <n>y = key expires in n years
    Key is valid for? (0) 0
    Key does not expire at all
    Is this correct? (y/N) y

    GnuPG needs to construct a user ID to identify your key.

    Real name: Fang lu***
    Email address: fang.lu***@gmail
    Comment: easy
    You selected this USER-ID:
        "Fang lu*** (easy) <fang.lu**@gmail>"

    Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? o
    ...
    public and secret key created and signed.

    pub   rsa4096 2024-06-05 [SC]
          1EAE54292D6D1495679106947AF7AA621A22738C
    uid                      Fang lu*** (easy) <fang.lu***@gmail>
    sub   rsa4096 2024-06-05 [E]
  #+end_src
- Change passphrase: =gpg --edit-key "easy" passwd=
- Export: =gpg --armor --export-secret-keys > my-keys.asc=
- Import: =gpg --import my-keys.asc=, *then edit trust*

*** Create, read, write gpg files in Emacs

To create a such file:
1. Switch to a *non-existent* buffer "test.txt.gpg".
2. Type something or insert a file/buffer into this buffer.
3. Try save, you'll be prompted to select a key.
   1. Move cursor to the designated key.
   2. Press "m" to mark
   3. Move cursor to "OK" and enter.

Later on, when Emacs opens this file, it will automatically encrypt/decrypt the
file. You only need to provide the passphrase when prompted.

P.S. To encrypt multiple files in command line:
#+begin_src bash
gpg -r easy --encrypt-files file1 file2
#+end_src

*** Encrypt region

- =M-x epa-encrypt-region=
- =M-x epa-decrypt-region=

IMPORTANT: Avoid embedding encrypt regions in files without version control, as
accidental changes are hard to detect and changing a single character can render
the entire region unreadable.

*** Cache passphrase

By default, a gpg agent is started. Hence you needn't type in password every
time a password is needed.

** Store credentials: auth source

#+begin_src emacs-lisp
  (use-package auth-source                ; built-in
    :defer t
    :custom
    (auth-sources '("~/.authinfo.gpg"))
    ;; I manually run `auth-source-search' for certain passwords. Do not
    ;; attemp to retrieve passwords automatically
    (auth-source-protocols '())
    )
#+end_src

This allows you to store multiple credentials in a few files and query them
easily.

*** Example auth info file (gpg encrypted)
#+begin_src authinfo
  machine atlas login api_pub_key password api-private-key-xxx
  machine some_host login username password pa$$w0rd
#+end_src

*** Retrieve and use credentials
Below is an example of how to do that in an org file (with org-babel).

NOTE: We must =(funcall secret)= to get the actual secret string.

#+begin_src org
  ,#+name: my-token
  ,#+begin_src emacs-lisp
    (let* ((credential (car (auth-source-search :host "atlas")))
           (user (plist-get credential :user))
           (secret (plist-get credential :secret))
           )
    (format "%s:%s" user (funcall secret)))
  ,#+end_src

  ,#+begin_src bash :results raw :var token=my-token()
    echo "$token"
  ,#+end_src
#+end_src

** References
- blog: [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Keeping Secrets in Emacs with GnuPG and Auth Sources]]
- youtube: [[https://www.youtube.com/watch?v=nZ_T7Q49B8Y][How to Encrypt Your Passwords with Emacs]]

* IRC

This section is for record only, no configuration is tangled into the actual configuration file.

I started with ERC, then switched to RCIRC, which appeared to be easier to set up.

I attempted to use them as Slack clients, but the experience was suboptimal, so I stopped using
them.

** ERC                                                             :obsolete:

#+begin_src emacs-lisp :tangle no
(require 'erc)
(add-to-list 'erc-modules 'notifications)
(setq erc-auto-query 'buffer
      erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                "324" "329" "332" "333" "353" "477"))

(defun my-slack ()
  "Join join slack team of company."
  (interactive)
  ;; All confidential information defined in another file
  (erc-tls :server slack-server
           :port slack-port
           :nick slack-nick
           :password slack-pass
           ))
#+end_src

** RCIRC                                                           :obsolete:

#+begin_src emacs-lisp :tangle no
  ;; All confidential information defined in another file
  (setq rcirc-server-alist `((,slack-server
                              :port ,slack-port
                              :encryption tls
                              :nick ,slack-nick
                              :password ,(concat slack-pass "-no_mpdm_greet")
                              :channels ("#tse-notifications"))
                             ("irc.freenode.net"
                              :channels ("#emacs" "#rcirc" "#mongodb"))
                             )
        ;; register nick name: https://freenode.net/kb/answer/registration
        rcirc-authinfo `(("freenode" nickserv ,my-net-id ,my-pub-passwd))
        rcirc-omit-responses '("JOIN" "PART" "QUIT" "NICK" "AWAY")
        ;; rcirc-nick-completion-format "@%s"
        rcirc-fill-flag nil
        rcirc-default-nick my-net-id)

  (add-hook 'rcirc-mode-hook
            (lambda ()
              (rcirc-track-minor-mode 1)
              (flyspell-mode 1)))
#+end_src

* News groups and emails - gnus                                    :obsolete:

In my previous job, I used Gnus to read newsgroups (mainly internal) and occasionally emails. When
the company decommissioned the NNTP servers, I stopped using Gnus.

Corresponding configuration files are in my Emacs notes directory for record only.

* Kubernetes
#+begin_src emacs-lisp
  (use-package kubel
    :defer t
    )
#+end_src

The packages works with limited privileges. Frequently used hotkeys
- R :: choose resource
- s :: set label selector
- ? :: help (dispatch list)

* Org mode

** Automatically tangle configurations

To ensure that the corresponding configuration files are updated every time I
modify this configuration file, add a =after-save-hook= to org-mode: when the
buffer file is my configuration file, tangle it. Otherwise, do nothing.

#+begin_src emacs-lisp
  (use-package emacs
    :commands org-babel-tangle
    :config
    (defvar my-config-org-files (mapcar #'expand-file-name
                                        '("~/.dotfiles/emacs.org"
                                          "~/.dotfiles/tmux.org"
                                          "~/.dotfiles/git.org"
                                          "~/.dotfiles/shell.org"
                                          "~/.dotfiles/window-manager.org"
                                          "~/.dotfiles/terminal-emulator.org"
                                          "~/.dotfiles/karabiner.org"
                                          )))
    (defun lgf-tangle-configs ()
      (add-hook 'after-save-hook
                (lambda()
                  (when (member (buffer-file-name) my-config-org-files)
                    (let ((org-confirm-babel-evaluate nil))
                      (org-babel-tangle))))))

    :hook ((org-mode . lgf-tangle-configs))
    )
#+end_src

*Note*:
- Remember to adjust =my-config-org-file= to point to your configuration file.

** Repeat map

#+begin_src emacs-lisp
  (use-package org
    :bind (:repeat-map my-org-repeat-map
                       ("C-n" . org-next-visible-heading)
                       ("C-p" . org-previous-visible-heading)
                       ("C-b" . org-backward-heading-same-level)
                       ("C-f" . org-forward-heading-same-level)
                       )
    )
#+end_src

** Structure templates
I.e. type =<s= + =TAB= to insert =#+begin_src= etc.
#+begin_src emacs-lisp
  (use-package org-tempo
    :config
    (add-to-list 'org-structure-template-alist '("sb" . "src bash"))
    (add-to-list 'org-structure-template-alist '("sj" . "src javascript"))
    ;; yasnippet-snippets/snippets/org-mode/style uses "<st" as well, which
    ;; overrides the one below. Modify that to "<sty" and then 'yas-reload-all"
    (add-to-list 'org-structure-template-alist '("st" . "src text"))
    (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
    )
#+end_src

** Agenda
#+begin_src emacs-lisp
  (use-package org-agenda
    :custom (org-agenda-use-time-grid nil)
  )
#+end_src

Turn off time grid as the grid lines between clocked items are annoying. An
alternative is to set =remove-match= as shown below. However, this can be
misleading as people typically expect equal intervals between grid lines.
Therefore, I chose to disable the time grid.
#+begin_src emacs-lisp :tangle no
  (setq org-agenda-time-grid
        '(((daily today remove-match)
           (800 1000 1200 1400 1600 1800 2000)
           "......" "----------------"))))
#+end_src
** Clock
#+begin_src emacs-lisp
  (use-package org-clock
    :bind (:map global-map
                ("<f9>"   . org-clock-in-last)
                ("S-<f9>" . org-clock-out))
    )
#+end_src

** Getting Things Done (GTD)
#+begin_src emacs-lisp
  (use-package org-capture
    :bind (:map global-map
                ("<f10>" . org-capture))
    )
#+end_src

** Babel
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-ditaa-jar-path (concat my-downloads "ditaa.jar"))
    (org-plantuml-jar-path (concat my-downloads "plantuml.jar"))
    (org-babel-load-languages '((emacs-lisp . t)
                                (shell . t)
                                (ditaa . t)
                                (plantuml . t)
                                (dot . t)
                                ))
    :config
    (defun my-org-confirm-babel-evaluate (lang body)
      ;; Do not request confirmation for the following languages
      (not (or (string= lang "ditaa")
               (string= lang "plantuml")
               (string= lang "dot"))))
    (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
    )
#+end_src

* PDF

#+begin_src emacs-lisp
  (use-package pdf-tools
    :defer t
    :magic ("%PDF" . pdf-view-mode)
    :commands pdf-tools-install
    :config
    (pdf-tools-install)
    )
#+end_src

* EPUB
#+begin_src emacs-lisp
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode)
  )
#+end_src

** Garbled text in Chinese books
According to [[https://emacs-china.org/t/emacs-epub/4713][this post in emacs-china]], the root cause is that these files do not
follow the standard, causing =nov= to handle UTF characters incorrectly.

The following workaround worked for me (at least for some books):
#+begin_src emacs-lisp
(with-no-warnings
    (defun my-nov-content-unique-identifier (content)
      "Return the the unique identifier for CONTENT."
      (when-let* ((name (nov-content-unique-identifier-name content))
                  (selector (format "package>metadata>identifier[id='%s']"
                                    (regexp-quote name)))
                  (id (car (esxml-node-children (esxml-query selector content)))))
        (intern id)))
    (advice-add #'nov-content-unique-identifier :override #'my-nov-content-unique-identifier))
#+end_src

** COMMENT EPUB 3 ID not found
Also from [[https://emacs-china.org/t/emacs-epub/4713][this post in emacs-china]], this is caused by epub2 books mistaken
identify them as epub3 ones.

Below is the workaround. Do not tangle this because I haven't hit issues and
hence haven't verified it yet.
#+begin_src emacs-lisp
(defun nov--content-epub2-files (content manifest files)
    (let* ((node (esxml-query "package>spine[toc]" content))
           (id (esxml-node-attribute 'toc node)))
      (when (not id)
        (throw 'error "EPUB 2 NCX ID not found"))
      (setq nov-toc-id (intern id))
      (let ((toc-file (assq nov-toc-id manifest)))
        (when (not toc-file)
          (throw 'error "EPUB 2 NCX file not found"))
        (cons toc-file files))))

  (defun nov--content-epub3-files (content manifest files)
    (let* ((node (esxml-query "package>manifest>item[properties~=nav]" content))
           (id (esxml-node-attribute 'id node)))
      (when (not id)
        (throw 'error "EPUB 3 <nav> ID not found"))
      (setq nov-toc-id (intern id))
      (let ((toc-file (assq nov-toc-id manifest)))
        (when (not toc-file)
          (throw 'error "EPUB 3 <nav> file not found"))
        (setq files (--remove (eq (car it) nov-toc-id) files))
        (cons toc-file files))))

  (defun nov-content-files (directory content)
    "Create correctly ordered file alist for CONTENT in DIRECTORY.
Each alist item consists of the identifier and full path."
    (let* ((manifest (nov-content-manifest directory content))
           (spine (nov-content-spine content))
           (files (mapcar (lambda (item) (assq item manifest)) spine)))
      (catch 'error (nov--content-epub3-files content manifest files))
      (catch 'error (nov--content-epub2-files content manifest files))))
#+end_src
* Terminal/shell
** vterm
#+begin_src emacs-lisp
  (use-package vterm
    :defer t
    )
#+end_src

Why:
- Integrated window/pane management & navigation
- Consistent color themes

Frequently used key bindings
- =C-c C-t= : toggle =copy-mode= (move around and copy in the vterm buffer).
- =C-c C-c= : send =C-c= to the term

Emacs as a terminal multiplexer:
1. Start Emacs daemon.
2. Run vterm (=M-x vterm=) in emacs clients.

** eshell

*** Customize prompt

Currently, there are no elaborate decorations. The primary changes are adding
the time and placing the path and dollar sign on separate lines.

#+begin_src emacs-lisp
  (use-package eshell
    :custom (eshell-prompt-function
             (lambda ()
               (concat
                (propertize "╭ " 'face `(:foreground "green"))
                (propertize (format-time-string "%H:%M " (current-time)) 'face `(:foreground "yellow"))
                (propertize (user-login-name) 'face `(:foreground "green"))
                (propertize "@" 'face `(:foreground "green"))
                (propertize (system-name) 'face `(:foreground "green"))
                (propertize "\n│ " 'face `(:foreground "green"))
                (propertize (concat (eshell/pwd)) 'face `(:foreground "green"))
                (propertize "\n╰ " 'face `(:foreground "green"))
                (propertize (if (= (user-uid) 0) "# " "$ ") 'face `(:foreground "green"))
                )))
    )
#+end_src

*** Customize aliases and commands
#+begin_src emacs-lisp
  (defun eshell/ep ()
    "In eshell, `ep' to go to the path of the previous buffer."
    (cd (with-current-buffer (other-buffer) default-directory)))

  (defun eshell/vi (&rest args)
    "Invoke `find-file' according to ARGS.
  `vi +66 foo` opens the file `foo` and goes to line 66 in the buffer."
    (while args
      (if (string-match "\\`\\+\\([0-9]+\\)\\'" (car args))
          (let* ((target-line (string-to-number (match-string 1 (pop args))))
                 (file (pop args)))
            (find-file file)
            (forward-line (- target-line (line-number-at-pos))))
        (find-file (pop args)))))
#+end_src

*** multiple eshell

To create an additional eshell buffer, run =C-u M-x eshell=.

* Utilities

** Calendar

#+begin_src emacs-lisp
  (use-package calendar
    ;; add defines and commands to make compiler happy
    :defines displayed-month displayed-year
    :commands calendar-day-of-week
    )

  (use-package holidays
    :config
    (defun holiday-new-year-bank-holiday ()
      "This & next copied from https://emacs.stackexchange.com/a/45352/9670"
      (let ((m displayed-month) (y displayed-year))
        (calendar-increment-month m y 1)
        (when (<= m 3)
          (let ((d (calendar-day-of-week (list 1 1 y))))
            (cond ((= d 6)
                   (list (list (list 1 3 y)
                               "NSW: New Year's Day (day in lieu)")))
                  ((= d 0)
                   (list (list (list 1 2 y)
                               "NSW: New Year's Day (day in lieu)"))))))))

    (defun holiday-christmas-bank-holidays ()
      (let ((m displayed-month) (y displayed-year))
        (calendar-increment-month m y -1)
        (when (>= m 10)
          (let ((d (calendar-day-of-week (list 12 25 y))))
            (cond ((= d 5)
                   (list (list (list 12 28 y)
                               "NSW: Boxing Day (day in lieu)")))
                  ((= d 6)
                   (list (list (list 12 27 y)
                               "NSW: Boxing Day (day in lieu)")
                         (list (list 12 28 y)
                               "NSW: Christmas Day (day in lieu)")))
                  ((= d 0)
                   (list (list (list 12 27 y)
                               "NSW: Christmas Day (day in lieu)"))))))))

    (setq calendar-mark-holidays-flag t)
    (let ((holiday-nsw-holidays '((holiday-fixed 1 1 "NSW: New Year's Day")
                                  (holiday-new-year-bank-holiday)
                                  (holiday-fixed 1 26 "NSW: Austrlia Day")
                                  (holiday-easter-etc -2 "NSW: Good Friday")
                                  (holiday-easter-etc -1 "NSW: Easter Saturday")
                                  (holiday-easter-etc 0 "NSW: Easter Sunday")
                                  (holiday-easter-etc 1 "NSW: Easter Monday")
                                  (holiday-fixed 4 25 "NSW: Anzac Day")
                                  (holiday-float 6 1 2 "NSW: Queen's Birthday")
                                  (holiday-float 10 1 1 "NSW: Labour Day")
                                  (holiday-fixed 12 25 "NSW: Christmas Day")
                                  (holiday-fixed 12 26 "NSW: Boxing Day")
                                  (holiday-christmas-bank-holidays)))
          (holiday-other-holidays '((holiday-fixed 10 31 "Halloween"))))
      (setq calendar-holidays (append holiday-nsw-holidays
                                      holiday-other-holidays)))
    )

#+end_src

*** Chinese calendar and holidays
#+begin_src emacs-lisp
  (use-package cal-china-x
    :after holidays
    :defines cal-china-x-chinese-holidays
    :config
    (setq calendar-holidays (append calendar-holidays
                                    cal-china-x-chinese-holidays
                                    '((holiday-lunar 1 15 "元宵节"))
                                    ))
    )
#+end_src

** Dictionary and translation

Firstly, clone the package into the =my-downloads= directory:
#+begin_src bash
git clone https://github.com/honmaple/emacs-maple-translate ~/.emacs.d/downloads/emacs-maple-translate
#+end_src

#+begin_src emacs-lisp
  (use-package maple-translate
    :load-path (lambda() (concat my-downloads "emacs-maple-translate"))
    :commands (maple-translate maple-translate+)
    :custom (maple-translate-engine 'youdao)
    :bind (:map global-map
                ("C-h D" . maple-translate)
                ("C-h d" . maple-translate+))
    )
#+end_src

I no longer use =scdv= despite its offline capability due the difficulty in
finding and downloading dictionaries.

Using =webjump= to navigate to =dict.cn= etc. with the selected text or word at
point is another alternative. However, it is less inconvenient as it requires
closing the web browser tab and refocusing on Emacs.

** Speed type
#+begin_src emacs-lisp
  (use-package speed-type
    :commands speed-type-region speed-type-text
    )
#+end_src

To improve typing speed, install =speed-type= and then use =speed-type-text= to
practice with random text snippets from the Gutenburg Project or
=speed-type-region= for the active region.

To avoid get boredom, I sometimes use =eww= to open a news page and then
=speed-type-region= it.

** Spelling alphabet

This is useful when you need to explain how to spell something over phone calls.
- Type in the word and =nato-region= it, then read it out. Or,
- =C-h v nato-alphabet= to list the alphabet in the HELP buffer and refer to it.

#+begin_src emacs-lisp
  (use-package morse                      ; built in
    ;; Nothing to customize, just list the commands etc. as a reminder
    :commands nato-region denato-region morse-region unmorse-region
    :defines nato-alphabet morse-code
    )
#+end_src

** Weather
#+begin_src emacs-lisp
  (use-package wttrin
    :defer t
    :defines wttrin-default-locations
    :custom
    (wttrin-default-locations '("Sydney, NSW"))
    (wttrin-font-name 'monaco)            ; for GUI Emacs only
    )
#+end_src

** World clock
#+begin_src emacs-lisp
  (use-package time                       ; built-in package
    ;; use `M-x world-clock' to display
    :custom
    (world-clock-time-format "%R %a %b\t%d %Z\t%z")
    (world-clock-list '(("UTC" "UTC")
                        ("Australia/Sydney" "Sydney")
                        ("America/New_York" "New York")
                        ("America/Chicago" "Chicago")
                        ("America/Los_Angeles" "Palo Alto")
                        ("Asia/Shanghai" "Beijing")
                        ("Asia/Kolkata" "Delhi")
                        ("Asia/Tel_Aviv" "Tel Aviv")
                        ("Europe/London" "Dublin")))
    )
#+end_src

* IDE

** Treemacs

#+begin_src emacs-lisp
  (use-package treemacs
    :defer t                    ; Only load it when I need it, as I rarely use it.
    )
#+end_src
Instead of using projectile etc., we can manually edit =treemacs-persist-file=
to add projects we need. Below is an example:
#+begin_src org
  ,* Default
  ,** My .dotfiles
   - path :: ~/.dotfiles
  ,** structure log mode
   - path :: ~/projects/emacs/structured-log-mode
#+end_src

** Completion: company

#+begin_src emacs-lisp
  (use-package company
    :delight
    :functions global-company-mode
    :init (global-company-mode)
    )
#+end_src

** Syntax check: flymake

#+begin_src emacs-lisp
  (use-package flymake
    ;; To jump to flymake diagnostics, use `consult-flymake'. To see the checkers
    ;; being used, check the buffer local var `flymake-diagnostic-functions'.
    ;; Sometimes it may be handy to list all the diagnostics in a buffer, this can
    ;; be done using `flymake-show-buffer-diagnostics' or
    ;; `flymake-show-project-diagnostics'.

    :bind (:map flymake-mode-map
                ("C-c p" . flymake-goto-prev-error)
                ("C-c n" . flymake-goto-next-error))

    :hook (prog-mode yaml-ts-mode)

    :config
    ;; Do not highlight flymake warnings due to the current high frequency of
    ;; warnings in our codebase. Instead, monitor the numbers of flymake
    ;; errors/warning/info in the mode line.
    (set-face-attribute 'flymake-warning nil :inherit nil)
  )
#+end_src

** Syntax parser: tree-sitter

#+begin_src emacs-lisp
  (use-package treesit
    ;; Remember to run `treesit-install-language-grammar' to install the grammar
    ;; for each designated language.
    :when
    (and (fboundp 'treesit-available-p) (treesit-available-p))

    :custom
    (major-mode-remap-alist
     '(
       (bash-mode . bash-ts-mode)
       (c++-mode . c++-ts-mode)
       (c-mode . c-ts-mode)
       (cmake-mode . cmake-ts-mode)
       (conf-toml-mode . toml-ts-mode)
       (js-json-mode . json-ts-mode)
       (python-mode . python-ts-mode)
       (yaml-mode . yaml-ts-mode)
       ))

    :functions py-thing

    :config
    ;; define `py-thing' for `thing-at-point' so that the `focus-mode' can focus
    ;; on such python things.
    (defvar py-thing--thing nil
      "Store the thing at point. `thing-at-point' moves to the end of
  the thing first. We should not re-run `py-thing' after that."
      )

    (defvar py-things-to-focus
      '("class_definition"
        "function_definition"
        "try_statement"
        "except_clause"
        "if_statement"
        "else_clause"
        "for_statement"
        "while_statement"
        "module")
      "Node types considered as python thing.")

    (defun py-thing ()
      (treesit-parent-until
       (treesit-node-at (point))
       (lambda (parent) (member (treesit-node-type parent) py-things-to-focus))))

    (defun py-thing-begin ()
      (when-let ((thing (or py-thing--thing (py-thing))))
        (goto-char (treesit-node-start thing))))

    (defun py-thing-end ()
      (when-let ((thing (py-thing)))
        (setq py-thing--thing thing)
        (goto-char (treesit-node-end thing))))

    (put 'py-thing 'beginning-op 'py-thing-begin)
    (put 'py-thing 'end-op 'py-thing-end)
    )
#+end_src

** Which function
#+begin_src emacs-lisp
  (use-package which-func
    :init (which-function-mode t)
    )
#+end_src

** Breadcrumb
#+begin_src emacs-lisp
  (use-package breadcrumb
    :defer t
    :custom
    (breadcrumb-project-max-length 0.3)
    (breadcrumb-imenu-max-length 0.9)
    )
#+end_src
- Note: consider replacing =which-function= with this.

** Code Formatter

Below are two general code formatter packages. For language-specific formatter
settings, refer to the corresponding programming language section.

*** reformatter

This package itself does not format code itself but provides functions necessary
to implement an formatter. It is required by tools =ruff-format= etc.

#+begin_src emacs-lisp
  (use-package reformatter
    :delight
    )
#+end_src

*** Prettier

This package formats JSON, YAML, and other file types.

NOTE:
- It is advisable to adhere to the default format settings as Prettier aims to
  standardize formatting and minimize disputes over style.
- To stop =yamllint= from complaining "too many spaces inside braces" for legacy
  code, add =bracketSpacing: false= to your =.prettierrc= temporarily.

1. *Globally* install the package (=-g=): =npm install -g prettier=.

2. Verify that =prettier= works, for example:
   #+begin_src bash
     npx prettier test.yml
   #+end_src

3. Hook prettier in Emacs
   #+begin_src emacs-lisp
     (use-package prettier
       :delight
       ;; Format json, yaml, markdown etc.;
       :hook (yaml-mode yaml-ts-mode)
       )
   #+end_src

**** COMMENT For shell scripts

Note: I'm using shfmt instead of this at the moment.

This does not work as Prettier is unable to find globally installed
plugins. Installing Prettier and the plugin locally and launching Emacs from the
same directory works; however, this approach is not ideal due to the
restriction of having to start Emacs from that specific directory.

- *Globally* install [[https://github.com/un-ts/prettier/tree/master/packages/sh][the shell script plugin]]
  #+begin_src bash
    npm install -g prettier-plugin-sh
  #+end_src
- Enable the plugin in =~/.prettierrc=:
  #+begin_src json
    {
      "plugins": ["prettier-plugin-sh"]
    }
  #+end_src

** LSP: eglot

Works very well out of box without any configuration.
#+begin_src emacs-lisp
  (use-package eglot
    :defer t
    )
#+end_src

*** Note for MacOS

If you run Eglot + Pyright on MacOS, you may want to increase the "open files"
limit (=ulimit -n=), say to 65536.

The default value is 256, which Pyright easily hits when the python project is
non-trivial. In such situations, you can see the error message by setting
=debug-on-error= to =t= and then try enable Eglot again.

** DAP: dape

#+begin_src emacs-lisp
  (use-package dape
    ;; For Python, `pip3 install debugpy'. Run adapter `debugpy' to test a
    ;; program, adapter `debugpy-module' for testing a module.
    :after eglot
    :custom (dape-buffer-window-arrangement 'right)
    :config
    ;; Save files before sessions, useful for interpreted languages, such as
    ;; python; Cannot use `:hook' since this hook name doesn't end with "-hook"
    (add-hook 'dape-on-start-hooks 'save-some-buffers)
    )
#+end_src

** Generative AI (GAI): copilot

For first time use, remember to run =M-x copilot-install-server= and =M-x
copilot-login=.

*** Copilot
#+begin_src emacs-lisp
  (use-package copilot
    :load-path (lambda() (concat my-downloads "copilot.el"))
    :commands copilot-mode
    :bind (:map copilot-completion-map
                ("TAB"       . copilot-next-completion)
                ("<backtab>" . copilot-previous-completion)
                ("M-f"       . copilot-accept-completion-by-word)
                ("C-e"       . copilot-accept-completion)
                )
    :custom (copilot-log-max 50000)

    ;; :hook (python-ts-mode python)

    ;; Do *not* add it to hook, otherwise we may see the following error during
    ;; Emacs start up: File mode specification error: (invalid-read-syntax \N{QUOTATION
    ;; MARK} 54 32)
    )
#+end_src

*** Copilot chat

TODO: when this package is stable and available in melpa, remove the load-path.

#+begin_src emacs-lisp
  (use-package copilot-chat
    :load-path (lambda() (concat my-downloads "copilot-chat.el"))

    :commands (copilot-chat-display copilot-chat-optimize copilot-chat-explain
                                    copilot-chat-how copilot-chat-reword)

    :bind (:map global-map
                ;; pop up the prompt window
                ("<f7>" . (lambda() (interactive)
                            (pop-to-buffer (cadr (copilot-chat--prepare-buffers)))))
                :map copilot-chat-prompt-mode-map
                ("C-c C-c" . copilot-chat-prompt-send))

    :hook ((copilot-chat-prompt-mode copilot-chat-mode) . visual-line-mode)

    :custom
    (copilot-chat-frontend 'org)

    :config
    ;; Define my own shortcut(s). For one-off usage, run
    ;; `copilot-chat-custom-prompt-selection` instead.
    (push '(how . "How to ") copilot-chat--prompts)
    (defun copilot-chat-how()
      "Ask Copilot how to {the text of the selected region}."
      (interactive)
      (copilot-chat--ask-region 'how))
    )
#+end_src

- How to ask questions:
  1. Run =M-x copilot-chat-display= if the =*copilot-chat-prompt*= buffer hasn't
     been created yet.
  2. Enter your query in the =*copilot-chat-prompt*= buffer, then press =C-c
     RET= (default) or =C-c C-c= (my key binding) to send the query to copilot.
     - If you're using this for the first time, you'll be asked to authenticate
       the application. Please note: even though you can authenticate via a web
       browser on a different host, it's mandatory to have a functional web
       browser on the Emacs host. If not, the authentication process will not be
       successful.
- An alternative configuration that use a shell CLI style front-end
  #+begin_src emacs-lisp :tangle no
    (use-package copilot-chat
       :load-path (lambda() (concat my-downloads "copilot-chat.el"))
       :custom
       (copilot-chat-frontend 'shell-maker)
       )

     (use-package copilot-chat-shell-maker
       :load-path (lambda() (concat my-downloads "copilot-chat.el"))
       :config
       (push '(shell-maker . copilot-chat-shell-maker-init) copilot-chat-frontend-list)
       )
  #+end_src

** Imenu

#+begin_src emacs-lisp
  (use-package imenu
    :custom (imenu-auto-rescan t)
    )

  (use-package imenu-list
    :after imenu
    )
#+end_src

* Version Control
** magit
#+begin_src emacs-lisp
  (use-package magit
    :defer t
    :custom (magit-log-margin-show-committer-date t)
    )
#+end_src
** git-gutter
#+begin_src emacs-lisp
  ;; Choose this package over diff-hl because the later does not work in 'emacs
  ;; -nw'.
  (use-package git-gutter
    :delight
    :commands global-git-gutter-mode
    :custom
    (git-gutter:modified-sign " ")
    (git-gutter:added-sign " ")
    (git-gutter:deleted-sign " ")
    :init
    (global-git-gutter-mode t)
    :config
    (set-face-background 'git-gutter:modified "DarkOrange")
    (set-face-background 'git-gutter:added "green")
    (set-face-background 'git-gutter:deleted "red")
    :bind (:map global-map
                ("C-x v [" . git-gutter:previous-hunk)
                ("C-x v ]" . git-gutter:next-hunk)
                ("C-x v =" . git-gutter:popup-hunk)
                ("C-x v s" . git-gutter:stage-hunk)
                ("C-x v r" . git-gutter:revert-hunk)
                )
    )
#+end_src

To diff with a revision other than the latest one, in the repo root directory,
add content similar to the following to the emacs directory local variable file
(=.dir-locals.el=):
#+begin_src emacs-lisp :tangle no
((prog-mode . ((git-gutter:start-revision . "my_branch"))))
#+end_src
Or
#+begin_src text
((nil . ((git-gutter:start-revision . "my_branch"))))
#+end_src

** git-link

#+begin_src emacs-lisp
  (use-package git-link
    :custom
    (git-link-open-in-browser t)
    (git-link-use-commit t)
    )
#+end_src

- "Use commit" equals "Copy permalink" in corresponding github page (?)

** blamer
#+begin_src emacs-lisp
  (use-package blamer
    :defer t
    )
#+end_src

- I do not turn on =global-blamer-mode= but instead run =M-x blamer-mode= in a
  specific buffer when designated.

** forge
#+begin_src emacs-lisp
  (use-package forge
    :defer t
    :after magit)
#+end_src

Apart from the above Emacs configuration, also remember to (see forge manual):
- Add github username into git config.
- Add the corresponding github token to auth source.

* ANSI color code

#+begin_src emacs-lisp
  (use-package ansi-color
    :hook (;; render color codes in the compilation buffer.
           (compilation-filter . ansi-color-compilation-filter))
    )

  (use-package flg-ansi-color-mode
    :after ansi-color
    :commands flg-ansi-color-mode
    )
#+end_src

* Bash

** Language server
Eglot + [[https://github.com/bash-lsp/bash-language-server][bash-language-server]]

** Formatter
See also [[* Prettier]]

1. Install [[https://github.com/mvdan/sh][shfmt]] in command line.
2. Package install =shfmt=.

#+begin_src emacs-lisp
  (use-package shfmt
    :delight shfmt-on-save-mode
    :hook (sh-mode . shfmt-on-save-mode)
    )
#+end_src

* CPP (C++)

** Language server

Eglot + =clangd= (on MacOS, =clangd= comes with Developer Command Line Tools)

** Formatter

Install the =clang-format= tool first, for instance =brew install clang-format=
or =sudo apt install clang-format=.

#+begin_src emacs-lisp
  (use-package clang-format
    ;; Do enable `clang-format-on-save-mode` due to legacy source code.
    ;; source code
    :delight clang-format-on-save-mode
    :commands clang-format-buffer clang-format-region clang-format-on-save-mode
    )
#+end_src

* Golang

No extra set up needed except for installing [[https://github.com/golang/tools/blob/master/gopls/README.md][gopls]] (the official language server
for golang).
- LSP: eglot + gopls
- Formatter: =eglot-format=
- Flymake: eglot as the backend

* Java

** Language server
Eglot + [[https://github.com/eclipse-jdtls/eclipse.jdt.ls][Eclipse JDT Language Server (JDTLS)]]

1. Download a milestone build of JDTLS and extract it to =~/.local=.
2. Add the path to =jdtls= to Emacs exec path:
   #+begin_src emacs-lisp
   (add-to-list 'exec-path (expand-file-name "~/.local/jdt-language-server/bin"))
   #+end_src
   Alternatively, add the path to the OS environment variable =PATH= and restart
   Emacs.

* JSON, JSON Lines

** JSON ts mode
#+begin_src emacs-lisp
  (use-package json-ts-mode
    :mode "\\.json\\(l?\\)\\'" "mongod.*\\.log" ; mongod logs are json lines
    )
#+end_src

** Structured log mode
This is a minor I wrote to display log files formatted as JSON lines in a more
human friendly way.
#+begin_src emacs-lisp
  (use-package structured-log-mode
    ;; my own package for viewing json format log files.
    :load-path (lambda() (concat my-elisps "structured-log-mode"))
    :commands structured-log-mode
    )
#+end_src

** JSON path to the node at point

This function is based on treesit (=json-ts-mode=)
#+begin_src emacs-lisp
  (use-package json-ts-mode
    :commands
    (treesit-node-at treesit-parent-until treesit-node-text treesit-node-index
                     lgf-json-path)
    :config
    (defun lgf-json-path (&rest _ignored)
      (let* ((pos (point))
             (node (treesit-node-at pos)) ; can be a punctuation node
             (filter (lambda(n)
                       (member (treesit-node-type n) '("pair" "array"))))
             (parent (treesit-parent-until node filter))
             (path nil))
        (while parent
          (setq path
                (cons
                 (pcase (treesit-node-type parent)
                   ("pair"
                    (treesit-node-text
                     (treesit-node-child (treesit-node-child parent 0) 1)
                     t))
                   ("array"
                    ;; NOTE: Cannot handle comments, but it is fine because the
                    ;; JSON standard says no comments.
                    (let* ((one-level-up (treesit-node-parent node))
                           (not-in-object (treesit-node-eq one-level-up parent))
                           (array-elem (if not-in-object node one-level-up))
                           )
                      (/ (1- (treesit-node-index array-elem)) 2))))
                 path))
          (setq node parent)
          (setq parent (treesit-parent-until parent filter)))
        (mapconcat (lambda(p) (format "%s" p)) path ".")))
    (defun lgf-json-path-set-up-eldoc ()
      (if (boundp 'eldoc-documentation-functions)
          (add-hook 'eldoc-documentation-functions #'lgf-json-path nil t)
        (setq-local eldoc-documentation-function #'lgf-json-path)))
    :hook ((json-ts-mode . lgf-json-path-set-up-eldoc))
    )
#+end_src

* Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode
    :defer t
    :custom (markdown-command "pandoc")
    )
#+end_src

* Python

#+begin_src emacs-lisp
  (use-package python
    :hook ((python-mode python-ts-mode) . hs-minor-mode)
    :custom
    ;; triple quotes on their own lines
    (python-fill-docstring-style 'django)
    ;; for empty python files, as existing files use existing indent offset.
    (python-indent-offset 4)
    )

  (use-package flymake-ruff
    ;; in addition to LSP
    :after flymake
    :hook ((python-mode python-ts-mode) . flymake-ruff-load)
    )

  (use-package ruff-format
    :delight ruff-format-on-save-mode
    :after reformatter
    :hook ((python-mode python-ts-mode) . ruff-format-on-save-mode)
    )
#+end_src

- LSP: pyright

* RFC
#+begin_src emacs-lisp
  (use-package rfc-mode
    :defer t
    :custom
    ;; ffap tries to find RFCs in these directories before giving a URL
    (ffap-rfc-directories '("~/projects/rfc"))
    ;; ffap no longer downloads RFCs, `rfc-mode-read` downloads RFC to this
    ;; directory.
    (rfc-mode-directory "~/projects/rfc")
    )
#+end_src
- g :: go to section
  - Note: it is *not* a =rfc-mode= issue that this (and imenu) does not work for
    some RFCs, such as RFC-3262. The issue lies with the RFCs themselves: they
    lack periods (.) after section numbers.
- n/p :: next/previous section
- PageDown/PageUp :: previous/next page
- TODO: u/d :: one level up/one level down

* YAML
** Formatter
See [[* Prettier]]

** Tree sitter major mode
#+begin_src emacs-lisp
  (use-package yaml-ts-mode)
#+end_src
** YAML pro
#+begin_src emacs-lisp
  (use-package yaml-pro
    :hook ((yaml-ts-mode . yaml-pro-ts-mode))
  )
#+end_src
Among the features, it provides the two most useful features when reading large YAML files
- Show the YAML path of the current node in the mini buffer via eldoc mode
- Support of imenu

** Flymake
#+begin_src emacs-lisp
  (use-package flymake-yamllint
    :after flymake
    :hook ((yaml-ts-mode . flymake-yamllint-setup))
    )
#+end_src

* To migrate

#+begin_src emacs-lisp
;; an intentional assignment to free variable. If the following setq is the
;; first line in corresponding flymake diagnostics buffer, then all the migrated
;; configurations are errors/warnings free
(setq old-config-start "----------------")

;;; paths -- delete after .org.el is migrated as well
(defvar my-emacs-base
  (file-name-as-directory (expand-file-name "~/.emacs.d")))
(defvar my-extension-path
  (file-name-as-directory (expand-file-name "~/.emacs.d/emacs-extensions")))
(defvar my-backward-path
  (file-name-as-directory (concat my-extension-path "backward-compatibility")))

;; load path
(add-to-list 'load-path my-extension-path)
(add-to-list 'load-path my-backward-path t)

;;; Personal Info

;; C-, M-, C-M- ... :(
(define-key global-map (kbd "C-x c l") 'org-store-link)
(define-key global-map (kbd "C-x c a") 'org-agenda)
(define-key global-map (kbd "C-x c o") 'org-open-at-point-global)
(define-key global-map (kbd "M-/") 'hippie-expand)
;; (define-key global-map (kbd "M-g c") 'move-to-column)
;; (define-key global-map (kbd "M-g ]") 'lgfang-goto-page)

;;; ascii mode
(autoload 'ascii-display "ascii" "Toggle ASCII code display." t)

;;; asm mode
(setq-default asm-comment-char 35)      ; 35 -> ascii code for '#'

;;; auto-complete - use company mode instead

;;; auto mode list
(setq auto-mode-alist (append
                       '(("\\.[xX]\\'" . c-mode)
                         ("\\.mak\\'" . makefile-mode)
                         ("\\.make\\'" . makefile-mode)
                         ("\\.gdb\\'" . gdb-script-mode)
                         ("\\.v\\'" . verilog-mode)
                         ("\\.ldif\\'" . ldap-mode))
                       auto-mode-alist))


;;; bbdb & bbdb-vcard-export - removed, use google/apple contacts etc.



(unless (eq system-type 'darwin)          ; OSX
  (setq browse-url-browser-function 'browse-url-firefox))

;;; c mode configuration
(defconst lgfang-c-style
  '((c-tab-always-indent        . t)
    (c-basic-offset . 4)
    (c-ignore-auto-fill . nil)
    (c-comment-only-line-offset . (0 . 0))
    (c-hanging-braces-alist     . ((substatement-open after before)
                                   (brace-list-open)))
    (c-hanging-colons-alist     . ((member-init-intro before)
                                   (inher-intro)
                                   (case-label after)
                                   (label after)
                                   (access-label after)))
    (c-cleanup-list             . (scope-operator
                                   empty-defun-braces
                                   defun-close-semi))
    (c-offsets-alist . ((knr-argdecl-intro . 5)
                        (arglist-intro . +)
                        (arglist-close . c-lineup-close-paren)
                        (inclass . +)
                        (member-init-intro . +)
                        (statement-block-intro . +)
                        (defun-block-intro . +)
                        (substatement-open . 0)
                        (label . 0)
                        (statement-case-open . +)
                        (statement-case-intro . +)
                        (case-label . 0)
                        (statement-cont . c-lineup-math)
                        (inline-open . 0)
                        (brace-list-open . +)
                        (topmost-intro-cont . 0)
                        (c . 1) ; "c" for continue of comment, not "c
                                ; programming language"
                        ))
    (c-special-indent-hook . c-gnu-impose-minimum)
    (c-block-comment-prefix . "lgf: ")
    (c-comment-prefix-regexp . ((awk-mode . "#+(lgf: )?")
                                (other ."lgf: \\|//+\\|\\**")))
    ;; go to this file and test if c block comments works
    ;; [[file:./patches/comments-test.c]]
    (c-echo-syntactic-information-p . t))
  "lgfang's C Programming Style")
(c-add-style "lgfang" lgfang-c-style nil)

(add-hook 'c-mode-common-hook
          (lambda ()
            (c-set-style "lgfang")
            (c-toggle-hungry-state 1)
            (hs-minor-mode 1)
            ;; (eldoc-mode 1)
            ))
;; Can't hook imenu-add-menubar-index to c-mode-common-hook since awk mode don't
;; support it
;; (dolist (hook '(c-mode-hook c++-mode-hook java-mode-hook))
;;   (add-hook hook 'imenu-add-menubar-index))


;;; Clipboard
;; from/to tmux buffer
(defun lgfang-send-to-tmux ()
  "Send content of active region or HEAD of the kill-ring to
tmux's buffer"
  (interactive)
  (let ((file (make-temp-file "/tmp/emacs-to-tmux.clip")))
    (if (region-active-p) (kill-ring-save (region-beginning) (region-end)))
    (with-temp-file file (insert-for-yank (current-kill 0)))
    (call-process "tmux" nil nil nil "load-buffer" file)
    (delete-file file)))

(defun lgfang-get-from-tmux ()
  "Get current tmux buffer."
  (interactive)
  (call-process "tmux" nil t nil "show-buffer"))

;; aliases to type less characters
(fset 'to-tmux 'lgfang-send-to-tmux)
(fset 'from-tmux 'lgfang-get-from-tmux)

;; From/to system clipboard. To use it in tmux, upgrade to tmux 2.6+.
(when (eq system-type 'darwin)
  (defun copy-from-osx ()
    (let ((tramp-mode nil) (default-directory "~"))
      (shell-command-to-string "pbpaste")))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))

  (setq interprogram-cut-function 'paste-to-osx)
  (setq interprogram-paste-function 'copy-from-osx))

(setq comment-style 'extra-line)

;;; company - auto completion


;;; compilation
(eval-after-load "compile"
  '(progn
     (setq compile-command "clang++ --std=c++11 "
           ;; compile-command "python -m unittest "
           compilation-scroll-output t)
     (define-key compilation-mode-map "n" 'next-error-no-select)
     (define-key compilation-mode-map "p" 'previous-error-no-select)
     (define-key compilation-mode-map " "
       (lambda () (interactive)
         (save-selected-window (compile-goto-error))))
     (define-key compilation-mode-map [return] 'compile-goto-error)
     (define-key compilation-mode-map "o"
       (lambda () (interactive)
         (compile-goto-error) (delete-other-windows)))
     (define-key compilation-mode-map "q" 'quit-window)))

;;; Copy/cut current line
;;; from http://blog.waterlin.org
(defadvice kill-ring-save (before slickcopy activate compile)
  "If region not active, copy current line."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

(defadvice kill-region (before slickcut activate compile)
  "If region not active, kill current line."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

;;; Current path+filename
(defun current-file-path ()
  "Copy current path/to/file_name to the kill ring."
  (interactive)
  (let ((string (buffer-file-name)))
    (message (concat "current file: " string))
    (kill-new string)))

;;; delete selection typed text replaces the selection (marked region)
;; (delete-selection-mode 0)

;;; default major mode
;; (setq default-major-mode 'text-mode)


;;; ediff
(setq
 ;; ediff-diff-options "-w"
 ;; do not pop a frame for ediff
 ediff-window-setup-function 'ediff-setup-windows-plain
 ;; my screen is large enough
 ediff-split-window-function 'split-window-sensibly)

;;; elisp
(add-hook 'emacs-lisp-mode-hook
          (lambda()  (hs-minor-mode 1)))


;;; emms configure in another file
(load "lgfang.emms" t nil nil)

;;; face, add our own keywords. ctypes.el is too heavy-weight
(add-hook 'find-file-hooks
          (lambda ()
            (font-lock-add-keywords
             nil '(("\\<\\(lgfang\\|TODO\\|FIXME\\|NOTE\\|IMPORTANT\\):"
                    . (0 font-lock-warning-face t))))))
(font-lock-add-keywords 'c-mode         ; for c mode only
                        '(("\\<\\(TRUE\\|FALSE\\)\\>"
                           . font-lock-constant-face)))

;;; gdb
;; (setq gdb-many-windows t)

;;; hide-ifdef-mode settings
(require 'hideif)

(defun hif-overlay-at (position)
  "An imitation of the one in hide-show, used by
lgfang-hif-toggle-block"
  (let ((overlays (overlays-at position)) ov found)
    (while (and (not found) (setq ov (car overlays)))
      (setq found (eq (overlay-get ov 'invisible) 'hide-ifdef)
            overlays (cdr overlays)))
    found))

(defun lgfang-hif-toggle-block ()
  "toggle hide/show-ifdef-block"
  (interactive)
  (require 'hideif)
  (let* ((top-bottom (hif-find-ifdef-block)) (top (car top-bottom)))
    (goto-char top)
    (hif-end-of-line)
    (if (hif-overlay-at (point)) (show-ifdef-block)
      (hide-ifdef-block))))

;;; Fold ifdef blocks by default. This is safer than showing them by default
;;; since when you see a code snippet folded, you know it is folded. In
;;; contrast, if they are not folded, you may learn in a hard way that you are
;;; in an undefined block.
(setq hide-ifdef-initially t
      hide-ifdef-define-alist
      ;; Add/remove "define" alist per your own need
      '((default)  ; An empty alist, makes every ifdef block folded, but not
                   ; ifndef blocks. See below for an example of how to define a
                   ; list per your project/environment.
        (mongodb-mac __APPLE__
                     (__LIBCPP_STD_VER . 14)
                     )
        ))
(defvar my-define-alist "mongodb-mac")

(defun lgfang-hide-ifdef-use-define-alist (name)
  "A wrapper for `hide-ifdef-use-define-alist' to use NAME define alist."
  (interactive
   (list (let* ((prompt "Use MACRO define list: ")
                (symbol-names
                 (mapcar (lambda (a) (symbol-name (car a)))
                         hide-ifdef-define-alist)))
           (completing-read prompt symbol-names))))
  (setq my-define-alist name) ; also apply this to buffers not opened yet
  (hide-ifdefs)                         ; for current buffer
  (hide-ifdef-use-define-alist name))

(dolist (hook '(c-mode-hook c++-mode-hook))
  (add-hook hook (lambda () (hide-ifdef-mode 1)
                   (hide-ifdef-use-define-alist my-define-alist))))

(eval-after-load "cc-mode"
  '(define-key c-mode-base-map (kbd "M-'") 'lgfang-hif-toggle-block))

;;; hide-show
(setq hs-allow-nesting t hs-isearch-open t)
(defun lgfang-toggle-level ()
  "hide/show the next level"
  (interactive) (hs-show-block) (hs-hide-level 1))

;;; hippie expand
(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-visible
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))

(require 'htmlize nil t)

;;; ispell - aspell instead
(setq ispell-program-name "aspell"
      ;; regardless locale settings, always use english refer to
      ;; ispell-dictionary-alist for details
      ispell-dictionary "english")

;;; Javascript
(add-hook 'js-mode-hook
          (lambda()
            (define-key js-mode-map (kbd "M-'") 'lgfang-toggle-level)
            (define-key js-mode-map [mouse-3] 'lgfang-toggle-level)
            (hs-minor-mode 1)))

;;; ldap mode for ldif files
(autoload 'ldap-mode "ldap-mode" "Edit ldif files" t)

;;; line number
;; (setq-default
;;  ;; Note that corresponding faces maybe undefined and hence the major/minor
;;  ;; ticks are not shown.

;;; long lines
(setq
 longlines-wrap-follows-window-size t
 ;; for visual-line-mode, indicates lines are wrapped
 visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))

;;; mermaid mode: package-installed, just remember to install mermaid cli:
;; 'npm install -g @mermaid-js/mermaid-cli'

(setq messages-buffer-max-lines 500)    ; default value too small

;;; nXML mode
(add-to-list 'auto-mode-alist
             '("\\.\\((xml\\|xsd\\|sch\\|rng\\|xslt\\|svg\\|rss\\)\\'"
               . nxml-mode))
(setq magic-mode-alist
      (cons '("<\\?xml " . nxml-mode) magic-mode-alist))
(fset 'xml-mode 'nxml-mode)
(fset 'html-mode 'nxml-mode)
(require 'rng-loc nil t)

(add-hook 'nxml-mode-hook (lambda() (hs-minor-mode 1)))

(add-to-list 'rng-schema-locating-files
             "~/mynotes/emacs/schema-locations.xml")

(add-to-list 'hs-special-modes-alist
             '(nxml-mode
               ;; "<!--\\|<[^/>]*[^/]>" ;; regexp for start block
               ;; "-->\\|</[^/>]*[^/]>" ;; regexp for end block
               "<!--\\|<[^/>][^>]*[^/]>" ;; our xml has names like calea/li
               "-->\\|</[^/>][^>]*[^/]>"
               "<!--" ;; regexp for comment start. (need this??)
               nxml-forward-element
               nil))

(eval-after-load "nxml-mode"
  '(progn
     (define-key nxml-mode-map (kbd "M-'") 'lgfang-toggle-level)
     (define-key nxml-mode-map [mouse-3] 'lgfang-toggle-level)))

(defun nxml-where ()
  "Display the hierarchy of XML elements the point is on as a
path. from http://www.emacswiki.org/emacs/NxmlMode"
  (interactive)
  (let ((path nil))
    (save-excursion
      (save-restriction
        (widen)
        (while
            (and (< (point-min) (point)) ;; Doesn't error if point is at
                                         ;; beginning of buffer
                 (condition-case nil
                     (progn
                       (nxml-backward-up-element) ; always returns nil
                       t)
                   (error nil)))
          (setq path (cons (xmltok-start-tag-local-name) path)))
        (if (called-interactively-p t)
            (message "/%s" (mapconcat 'identity path "/"))
          (format "/%s" (mapconcat 'identity path "/")))))))

;;; occur
(define-key occur-mode-map "n" 'next-error-no-select)
(define-key occur-mode-map "p" 'previous-error-no-select)
(define-key occur-mode-map " " 'occur-mode-display-occurrence)
(define-key occur-mode-map "o" (lambda () (interactive)
                                 (occur-mode-goto-occurrence)
                                 (delete-other-windows)))

;;; org mode
(load "~/.org" t nil nil)

;;; perl: using cperl-mode instead
(defalias 'perl-mode 'cperl-mode)
(setq cperl-indent-level 4
      cperl-close-paren-offset -4
      cperl-continued-statement-offset 4
      cperl-indent-parens-as-block t
      cperl-tab-always-indent t)

;;; PHP
(add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
;; Installed using M-x package-install
(autoload 'php-mode "php-mode" "Major mode for editing PHP code." t)

;;; Always end a file with a newline
(setq require-final-newline t)


;;; rnc mode - nxml mode uses rnc files
(add-to-list 'auto-mode-alist '("\\.rnc\\'" . rnc-mode))
(autoload 'rnc-mode "rnc-mode")
(setq ;; rnc-enable-imenu t
      rnc-jing-jar-file (expand-file-name
                         (concat my-extension-path "jing/bin/jing.jar")))
(defun rnc2rng ()
  (interactive)
  (let* ((rnc (buffer-file-name))
         (rng (concat (file-name-sans-extension rnc) ".rng")))
    (call-process "java" nil nil nil "-jar"
                  (cygpath
                   (expand-file-name
                    (concat my-extension-path "trang.jar")))
                  (cygpath rnc) (cygpath rng))))


(setq scroll-margin 0 scroll-conservatively 100) ;  scroll-step ?

;;; selective display
(defun lgfang-toggle-selective-display()
  "set-selective-display to current column or toggle
selective-display"
  (interactive)
  (let ((arg (progn (back-to-indentation) (1+ (current-column)))))
    (set-selective-display (if (eq arg selective-display) nil arg))))

;;; sentence end
(setq sentence-end-double-space nil)
;; (setq sentence-end
;;       "\\([。！？]\\|……\\|[.?!][]\"')}]*\\($\\|[ \t]\\)\\)[ \t\n]*")

;;; server (alternatively, you may use "emacs --daemon")
(require 'server)
(when (not (server-running-p))
  (server-start))

(global-subword-mode)

;;; Tcl & expect
(add-hook 'tcl-mode-hook
          (lambda ()
            (imenu-add-menubar-index)
            (hs-minor-mode 1)))
(add-to-list 'interpreter-mode-alist '("expect" . tcl-mode))

;;; Terraform (package install terraform-mode)
(setq-default terraform-indent-level 4)

;;; toggle-window-dedicated.el
(load "toggle-window-dedicated" t nil nil)

;;; tramp
(require 'tramp)
(setq tramp-debug-buffer t)
(add-to-list 'tramp-default-method-alist '("localhost" nil "su"))

;;; trash
(when (>= emacs-major-version 23)
  (setq delete-by-moving-to-trash nil)
  ;; works for *nix only
  (setq trash-directory "~/.trashbin"))

(setq-default truncate-lines nil)

;;; Uniquify buffer name with more meaningful names
(when (require 'uniquify nil t)
  (setq uniquify-buffer-name-style 'post-forward
        uniquify-strip-common-suffix t
        uniquify-separator "@"))

;;; verilog mode
(autoload 'verilog-mode "verilog-mode" "Verilog mode" t )

;;; vimrc mode
(autoload 'vimrc-mode "vimrc-mode")
(add-to-list 'auto-mode-alist '(".vim\\(rc\\)?$" . vimrc-mode))

;;; viper, those who miss vi so bad please change "nil" to "t"
(when nil
  (setq viper-inhibit-startup-message t
        viper-expert-level '5
        viper-mode t)
  (require 'viper))

;;; woman
(setq woman-use-own-frame nil
      woman-fill-frame t)

;;; word
(setq-default word-wrap t)

;;; to make the cursor as wide as the character it is over
(setq x-stretch-cursor t)

;;; xcscope,
;; NOTE: cscope is now just a backup. Normally eglot + clangd is more convient.
;; Just `M-x eglot` in a C/C++ buffer to activate eglot.
(when (require 'xcscope nil t)
  (cscope-setup)

  (setq
   ;; use gtags-cscope instead of the legacy cscope
   cscope-program "gtags-cscope"
   ;; set cscope-database-file accordingly. Otherwise xcscope looks for
   ;; "cscope.out" and fails and then build the database in the current
   ;; directory.
   cscope-database-file "GTAGS")

  ;; ;; Below are for huge code bases. No need of them at the moment
  ;; (require 'cscope-filter nil t)
  ;; (setq
  ;;  cscope-do-not-update-database t ; do not rebuild database for every search.
  ;;  cscope-database-regexps
  ;;  '(("\\(sandbox/trunk\\)"
  ;;     (t) ;; local cscope.out first
  ;;     ("/home/lgfang/projects/vsg/sandbox/lcp_lite/")
  ;;     ("/home/lgfang/projects/vsg/sandbox/libsoap-1.1.0/libcsoap/")
  ;;     ("/home/lgfang/projects/vsg/sandbox/libxml2/")
  ;;     t ; 't' doesn't work, comment out useless database-dir
  ;;     ;;("/remote/.../b2008.09_icc_us02/syn/icc_sh/cscope.out.bak")
  ;;     )))

  )

;;; xref
(setq xref-prompt-for-identifier t) ; always prompt for identifier to search

;;; ------ end General ------

;;; ------ begin MyFunction ------


;;; ------ end MyFunction ------

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(highlight-parentheses-colors '("#689d6a" "#d79921" "#458588" "#b16286" "#98971a"))
 '(package-selected-packages
   '(flymake-yamllint editorconfig company cue-mode git-gutter mermaid-mode protobuf-mode cmake-mode magit anaconda-mode eglot blacken git-link csv-mode emms json-reformat windata w3m solarized-theme showtip terraform-mode highlight-parentheses highlight-indentation org-contrib yasnippet-snippets hide-lines ox-gfm yasnippet pydoc-info pydoc markdown-mode jira-markup-mode ht go-mode flycheck f)))
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
#+end_src
